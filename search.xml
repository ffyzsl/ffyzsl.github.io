<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DB、DBMS简介</title>
    <url>/2021/07/05/DB%E3%80%81DBMS%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="DB、DBMS简介"><a href="#DB、DBMS简介" class="headerlink" title="DB、DBMS简介"></a>DB、DBMS简介</h2><p>将大量的数据保存起来，通过计算机加工而成的可以进行高效访问的数据集合称为<strong>数据库</strong>(<code>Database，DB</code>).而用来管理数据库的计算机系统称为<strong>数据库管理系统</strong>(<code>Database Management System，DBMS</code>)。</p>
<span id="more"></span>
<h3 id="DBMS的种类"><a href="#DBMS的种类" class="headerlink" title="DBMS的种类"></a>DBMS的种类</h3><p><strong>层次数据库</strong>(<code>Hierarchical Database，HDB</code>)：最古老的数据库之一，把数据通过层次结构（树形结构）的方式表现出来。</p>
<p><strong>关系数据库</strong>(<code>Relational Database，RDB</code>)：为目前应用最广泛的数据库。和Excel工作表一样，它也采用由行和列组成的二维表来管理数据，同时，他还使用专门的<code>SQL(Structured Query Language，结构化查询语言)</code>对数据进行操作。这种类型的DBMS称为关系数据库管理系统(Relational Database Management System，RDBMS)。</p>
<ul>
<li>Oracle Database：甲骨文公司的RDBMS</li>
<li>SQL Server：微软公司的RDBMS</li>
<li>DB2：IBM公司的RDBMS</li>
<li>PostgreSQL：开源的RDBMS</li>
<li>MySQL：开源的RDBMS</li>
</ul>
<p><strong>面向对象数据库</strong>(<code>Object Oriented Database，OODB</code>)：编程语言当中有一种被称为面向对象语言的语言，把数据以及对数据的操作集合起来以对象为单位进行管理。</p>
<p><strong>XML数据库</strong>(<code>XML Database，XMLDB</code>)：最近几年，XML作为在网络上进行交互的数据的形式逐渐普及起来，XML数据库可以对XML形式的大量数据进行高速处理</p>
<p><strong>键值存储系统</strong>(<code>Key-Value Stroe，KVS</code>)：单纯用来保存查询所使用的主键(Key)和值(Value)的组合的数据库</p>
<h2 id="数据库的结构"><a href="#数据库的结构" class="headerlink" title="数据库的结构"></a>数据库的结构</h2><h3 id="RDBMS常见的系统结构"><a href="#RDBMS常见的系统结构" class="headerlink" title="RDBMS常见的系统结构"></a>RDBMS常见的系统结构</h3><p>使用RDBMS时，最常见的系统结构就是客户机/服务器类型(C/S类型)</p>
<p><strong>服务器</strong>：用来接受其他程序发出的请求，并对该请求进行处理的程序（软件），或者是安装了此类程序的设备。</p>
<p><strong>客户机</strong>：像服务器发出请求的程序（软件），或是安装了该程序的设备。</p>
<h3 id="表的结构"><a href="#表的结构" class="headerlink" title="表的结构"></a>表的结构</h3><p> 表是由行和列组成的二维表，表存储在由RDBMS管理的数据库中，一个数据库可以管理多个表。</p>
<p>表的列称为<strong>字段</strong>，表的行称为<strong>记录</strong>，关系型数据库<strong>必须以行为单位</strong>进行数据读写。行和列的交汇处称为<strong>单元格</strong>，一个单元格只能输入一个数据。</p>
<h2 id="RDBMS的用户管理"><a href="#RDBMS的用户管理" class="headerlink" title="RDBMS的用户管理"></a>RDBMS的用户管理</h2><p>为了防止重要数据泄露，RDBMS只允许注册用户接触数据库。RDBMS允许注册多个用户</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>java开发环境搭建以及HelloWorld</title>
    <url>/2021/07/01/Day%20001%EF%BC%88java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Java-开发环境搭建"><a href="#Java-开发环境搭建" class="headerlink" title="Java 开发环境搭建"></a>Java 开发环境搭建</h1><p>JDK( java development Kit)<br>JRE(Java Runtime Environment)<br>JVM(Java Virtual Machine)*    虚拟机</p>
<span id="more"></span>

<h2 id="卸载JDK"><a href="#卸载JDK" class="headerlink" title="卸载JDK"></a>卸载JDK</h2><p>1、删除java安装目录<br>2、删除JAVA_HOME（清除环境变量）<br>3、删除path下关于Java的目录<br>4、win+r   cmd   Java_version（验证是否删除）</p>
<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>1、下载相对版本的JDK<br>2、安装JDK<br>3、我的电脑  属性  高级系统设置   环境变量  系统变量  新建     JAVA_HOME 并找到安装JDK的路径<br>4、配置path变量，%JAVA_HOME%\bin  %JAVA_HOME%\jre\bin</p>
<h1 id="HelloWorld-及-简单语法规则"><a href="#HelloWorld-及-简单语法规则" class="headerlink" title="HelloWorld 及 简单语法规则"></a>HelloWorld 及 简单语法规则</h1><p>1、新建文件夹，存放代码<br>2、新建一个java文件。    （*.java）<br>3、编写代码 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、编译  Javac  Java文件，会生成一个class文件。<br>5、运行，java class文件              截图（win+shift+s）</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>1、单词大小不能出现问题，不能出现中文符号<br>2、输入的字符尽量用英文<br>3、文件名和类名必须保证一致，并且首字母大写</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>运算符以及if语句</title>
    <url>/2021/07/02/Day%20003%EF%BC%88%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A5%E5%8F%8Aif%E8%AF%AD%E5%8F%A5%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、运算符"><a href="#一、运算符" class="headerlink" title="一、运算符"></a>一、运算符</h2><h3 id="算术运算符：-–"><a href="#算术运算符：-–" class="headerlink" title="算术运算符：+  -  *  /  ++ –  %"></a>算术运算符：+  -  *  /  ++ –  %</h3><span id="more"></span>

<p>注：（不确定优先级的，加小括号）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        a=i%<span class="number">2</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>++ 或–  出现在变量<strong>前</strong>，先加后用<br>       ++或–  出现在变量<strong>后</strong>，先用后加</p>
<h3 id="关系运算符-gt-gt-lt-lt"><a href="#关系运算符-gt-gt-lt-lt" class="headerlink" title="关系运算符     &gt;   &gt;=   &lt;   &lt;=   ==   !="></a>关系运算符     &gt;   &gt;=   &lt;   &lt;=   ==   !=</h3><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><strong>&amp; 逻辑与</strong>（两边的算子都是true，结果才是true）<br>        <strong>| 逻辑或</strong>（两边的算子只要有一个是true，结果就是true）<br>       <strong>！逻辑非</strong>（取反，!false就是true,!true就是false）<br>       **^ 逻辑异或 **  (两边的算子只要不一样，就是true)<br>       <strong>&amp;&amp;  短路与</strong><br>       <strong>|| 短路或</strong><br>1、逻辑运算符要求两边的算子都是布尔类型，并且逻辑运算符最终的运算结果也是一个布尔类型。<br>2、短路与和逻辑与最终的运算结果相同，只不过短路与存在短路现象。<br>3、短路或和逻辑或最终的运算结果相同，只不过短路或存在短路现象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">11</span>;</span><br><span class="line">        System.out.println(<span class="keyword">false</span> &amp; ++x&lt;y);</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">11</span>;</span><br><span class="line">        System.out.println(<span class="keyword">false</span> &amp;&amp; ++x&lt;y);</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>当<strong>短路与</strong>在第一个表达式时的结果是false，导致最终结果必然是false，所以后面的表达式没必要执行。而逻辑与不管第一个表达式为false还是true，他会把所有表达式全部执行。<br>当<strong>短路或</strong>在第一个表达式的结果为true，导致最终结果必然是true，所以后面的表达式没必要执行，而逻辑或不管第一个表达式为false还是true，他会把所有表达式全部执行。<br>注：（从某个方面而言，短语与，短路或更加智能，执行效率更高，但在实际应用中，还是要看情况逻辑）</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><strong>基本的赋值运算符  =</strong><br>       *<em>拓展的赋值运算符  +=   -=  <em>=   /=    %=  (可以翻译成“追加/累加”)</em></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        s=a+b;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        s=<span class="number">10</span>;</span><br><span class="line">        s*=a+b;<span class="comment">//s=s*(a+b);</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        s/=<span class="number">4</span>;<span class="comment">//s=s/4    </span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b =<span class="number">10</span>;</span><br><span class="line">b=b+<span class="number">5</span>;<span class="comment">//报错  编译器只检查语法，不运行程序 ，编译器发现b+5的类型为int，b变量的类型为byte</span></span><br><span class="line">b=<span class="keyword">byte</span>(b+<span class="number">5</span>);<span class="comment">//正确</span></span><br><span class="line">b+=<span class="number">5</span>;<span class="comment">//正确  等同于b=byte(b=5);不等同与b=b+5;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k=<span class="number">10</span>;</span><br><span class="line">k+=<span class="number">5</span>;<span class="comment">//等同于k=(int)(k+5);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：（byte的取值范围为-128至127，损失精度，超过溢出）</p>
<p><em><strong>拓展类的赋值运算符不改变运算结果类型，假设最初这个变量的类型是byte类型，无论怎么进行追加或追减，不改变最初变量类型</strong></em></p>
<h3 id="字符串连接运算符"><a href="#字符串连接运算符" class="headerlink" title="字符串连接运算符"></a>字符串连接运算符</h3><p><strong>+</strong>   加法运算，字符串连接运算</p>
<p>1、当“+“运算符两边的数据都是数字的话，一定是进行加法运算<br>       2、当”+“运算符两边的数据只要有一个数据是字符串，一定会进行字符串连接运算，并且，连接运算之后的结果还是一个字符串类型。<br>       3、在一个式子中有多个”+“号时，且没有小括号的前提下，遵循自左向右的顺序执行。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">20</span>;</span><br><span class="line">System.out.println(a+<span class="string">&quot;+&quot;</span>+b+”=“+（a+b));</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>+<span class="number">20</span>=<span class="number">30</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//引用类型String</span></span><br><span class="line">        <span class="comment">//String时SUN在JAVASE当中提供的字符串类型</span></span><br><span class="line">        <span class="comment">//String.class字节码文件</span></span><br><span class="line">        <span class="comment">//int时基本数据类型，i是变量名，10是int类型的字面值</span></span><br><span class="line">        <span class="comment">//String s=&quot;abc&quot;;</span></span><br><span class="line">        String unername=<span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;登陆成功，欢迎&quot;</span>+unername+<span class="string">&quot;回来！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">登陆成功，欢迎zhangsan回来！</span><br></pre></td></tr></table></figure>

<h3 id="三元运算符-三目运算符-条件运算符"><a href="#三元运算符-三目运算符-条件运算符" class="headerlink" title="三元运算符/三目运算符/条件运算符"></a>三元运算符/三目运算符/条件运算符</h3><p>1、语法规则  <strong>布尔表达式？表达式1：表达式2</strong><br> 布尔表达式为true，执行结果为表达式1的执行结果<br> 布尔表达式为false，执行结果为表达式2的执行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> sex = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">char</span> c1= sex? <span class="string">&quot;n&quot;</span>:<span class="string">&quot;y&quot;</span>;<span class="comment">//报错，类型不兼容   char c1=sex?&#x27;n&#x27;:&#x27;y&#x27;;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Boolean sex=<span class="keyword">false</span>;</span><br><span class="line">String s = sex?<span class="string">&quot;男的&quot;</span>;<span class="string">&quot;女的&quot;</span>;<span class="comment">//不报错</span></span><br></pre></td></tr></table></figure>

<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="if语句和if-else-语句"><a href="#if语句和if-else-语句" class="headerlink" title="if语句和if else 语句"></a>if语句和if else 语句</h4><p>1、if语句的语法结构</p>
<p>第一种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">   java语句</span><br><span class="line">   ……</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>第二种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">   java语句</span><br><span class="line">   ……</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   java语句</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌套</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;  </span><br><span class="line">    java语句   </span><br><span class="line">    ……  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式)&#123;   </span><br><span class="line">    java语句 </span><br><span class="line">    ……</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    java语句</span><br><span class="line">     ……</span><br><span class="line">……</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;  </span><br><span class="line">    java语句   </span><br><span class="line">    ……  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式)&#123;   </span><br><span class="line">    java语句 </span><br><span class="line">    ……</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    java语句</span><br><span class="line">     ……</span><br><span class="line">……&#123;</span><br><span class="line">     </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>练习</strong><br>需求：判断当前的天气：当外边下雨的时候：带雨伞，判断性别，当性别为男，带一把大黑伞，当性别为女，带一把小花伞，当外边是晴天的时候，判断天气的温度，超过30度以上，当性别为男，戴墨镜，当性别为女，擦防晒霜。<br>天气状况、温度、性别需要从键盘输入<br>温度直接用数字即可<br>性别，1为男，0为女</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">iftest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        java.util.Scanner s=<span class="keyword">new</span> java.util.Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> weather=s.nextInt();</span><br><span class="line">        <span class="keyword">int</span> temperature=s.nextInt();</span><br><span class="line">        <span class="keyword">int</span> sex=s.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (weather==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sex == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;带一把大黑伞&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sex == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;带一把小花伞&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (weather==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temperature&gt;<span class="number">30</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (sex==<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;戴墨镜&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sex==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;擦防晒霜&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型、类型转换、变量以及常量</title>
    <url>/2021/07/02/Day%20002%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E5%B8%B8%E9%87%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><p>1、要求变量的使用要严格符合规定，所有变量必须先定义后才能使用。</p>
<span id="more"></span>

<p>1bit表示1位<br>       1Byte表示一个字节， 1B=8b<br>       1024B=1KB<br>       1024KB=1M<br>       1024M=1G</p>
<p><strong>分两大类：基本类型，引用类型</strong></p>
<p>基本类型</p>
<table>
<thead>
<tr>
<th align="left">键字</th>
<th align="left">类型</th>
<th align="left">位数 (8位一字节)</th>
<th align="left">取值范围(表示范围)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">整型</td>
<td align="left">8</td>
<td align="left">-2^7 ~ 2^7-1</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">整型</td>
<td align="left">16</td>
<td align="left">-2^15 ~ 2^15-1</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">整型</td>
<td align="left">32</td>
<td align="left">-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">整型</td>
<td align="left">64</td>
<td align="left">-2^63 ~ 2^63-1</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">浮点数</td>
<td align="left">32</td>
<td align="left">3.402823e+38 ~ 1.401298e-45</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">浮点数</td>
<td align="left">64</td>
<td align="left">1.797693e+308~ 4.9000000e-324</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">文本型</td>
<td align="left">16</td>
<td align="left">0 ~ 2^16-1</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">布尔值</td>
<td align="left">32/8</td>
<td align="left">true/false</td>
</tr>
</tbody></table>
<p>引用类型</p>
<table>
<thead>
<tr>
<th>类</th>
</tr>
</thead>
<tbody><tr>
<td>接口</td>
</tr>
<tr>
<td>数组</td>
</tr>
</tbody></table>
<p> <em><strong>long类型后加L</strong></em></p>
<p><em><strong>float类型后要加字母F</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> num1=<span class="number">25.1F</span>;<span class="comment">//float类型后要加字母F</span></span><br><span class="line">        <span class="keyword">long</span> num3=<span class="number">30L</span>;<span class="comment">//long类型后要加字母L</span></span><br><span class="line">        <span class="keyword">double</span> num2=<span class="number">25.122324343534343</span>;</span><br><span class="line">        <span class="comment">//字符</span></span><br><span class="line">        <span class="keyword">char</span> name=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">//字符串，String不是关键字，而是类</span></span><br><span class="line">        String name2=<span class="string">&quot;可以是中文and english&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//布尔值</span><br><span class="line">boolean flag=true;</span><br><span class="line">boolean flag2=false;</span><br></pre></td></tr></table></figure>

<h3 id="1、整数拓展"><a href="#1、整数拓展" class="headerlink" title="1、整数拓展"></a>1、整数拓展</h3><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><p><strong>二进制0b     十进制     八进制0    十六进制0x</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i2=<span class="number">010</span>; <span class="comment">//八进制</span></span><br><span class="line">        <span class="keyword">int</span> i3=<span class="number">0x10</span>;<span class="comment">//十六进制</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line">        System.out.println(i3);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>

<h3 id="2、浮点数拓展"><a href="#2、浮点数拓展" class="headerlink" title="2、浮点数拓展"></a>2、浮点数拓展</h3><p>一、浮点数：<em><strong>有限，离散，舍入误差，大约，接近但不等于</strong></em>（最好完全避免使用浮点数进行比较）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> f=<span class="number">0.1f</span>;</span><br><span class="line">        <span class="keyword">double</span> d=<span class="number">1.0</span>/<span class="number">10</span>;</span><br><span class="line">        System.out.println(f==d);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<p>二、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">float</span> i=<span class="number">12453232232323232f</span>;</span><br><span class="line">     <span class="keyword">float</span> i2=i+<span class="number">1</span>;</span><br><span class="line">        System.out.println(i==i2);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><em>当数值较大时，应使用  BigDecimal 数学工具类</em></p>
<h3 id="3、字符拓展"><a href="#3、字符拓展" class="headerlink" title="3、字符拓展"></a>3、字符拓展</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     char c1=&#x27;a&#x27;;</span><br><span class="line">     char c2=&#x27;中&#x27;;</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println((int)c1);//强制转换</span><br><span class="line">        System.out.println((int)c2);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">a</span><br><span class="line">中</span><br><span class="line">97</span><br><span class="line">20013</span><br></pre></td></tr></table></figure>

<p>所有的字符本质还是数字。   编码 Unicode           2字节</p>
<p><strong>转义字符</strong></p>
<p>\n 换行</p>
<p>\t  制表符</p>
<p>……</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sa=<span class="keyword">new</span> String(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">String sb=<span class="keyword">new</span> String(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">System.out.println(sa==sb);</span><br><span class="line">String sc=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">String sd=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">System.out.println(sc==sd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="4、布尔值拓展"><a href="#4、布尔值拓展" class="headerlink" title="4、布尔值拓展"></a>4、布尔值拓展</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (flag==<span class="keyword">true</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">if</span>(flat)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、类型转化"><a href="#二、类型转化" class="headerlink" title="二、类型转化"></a>二、类型转化</h2><p>低———————————————–&gt;&gt;&gt;高</p>
<p>byte,short,char—&gt; int —&gt; long —&gt; float —&gt; double</p>
<p><strong>强制转化：（类型）变量名   高——低</strong></p>
<p><strong>自动转换      低——高</strong></p>
<p>运算中，不同类型的数据先转化为同一类型，然后进行运算。</p>
<p>注：1、不能对布尔进行转换</p>
<p>​        2、不能把对象类型转化为不相干的类型</p>
<p>​        3、在把高容量转换到低容量的时候，强制转换</p>
<p>​        4、转换时可能出现内存溢出，或者精度问题（操作比较大的数字时，注意溢出问题）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">128</span>;</span><br><span class="line"><span class="keyword">byte</span> b=(<span class="keyword">byte</span>)i;<span class="comment">//内存溢出</span></span><br><span class="line">System.out.println(i);</span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br><span class="line"><span class="number">128</span></span><br><span class="line">-<span class="number">128</span></span><br></pre></td></tr></table></figure>

<p>注：（byte的表示范围为：-128~127）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println((<span class="keyword">int</span>)<span class="number">25.54</span>); </span><br><span class="line">System.out.println((<span class="keyword">int</span>)-<span class="number">45.89f</span>); </span><br><span class="line"></span><br><span class="line"><span class="number">25</span></span><br><span class="line">-<span class="number">45</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> b=c+<span class="number">1</span>;</span><br><span class="line">System.out.println(b);</span><br><span class="line">System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line"></span><br><span class="line"><span class="number">98</span></span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p>JDK7新特性，数字之间可以用下划线分割，且输出时不被显示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> money=<span class="number">10_0000_0000</span>;<span class="comment">//或后加一个L</span></span><br><span class="line"><span class="keyword">int</span> year=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> total=money*year;<span class="comment">//-1474836480,计算时溢出</span></span><br><span class="line"><span class="keyword">long</span> total1=money*year;<span class="comment">//默认为int，转换之间已经存在问题</span></span><br><span class="line"><span class="keyword">long</span> total2=money*((<span class="keyword">long</span>)year);<span class="comment">//先把一个数字转化为long</span></span><br></pre></td></tr></table></figure>

<h2 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h2><p>定义变量和c语言一样</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类变量  static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> salary =<span class="number">2500</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//属性：变量</span></span><br><span class="line">    <span class="comment">//实例变量：从属于对象，如果不自行初始化，这个类型的默认值</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//main方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//局部变量，必须声明和初始化值</span></span><br><span class="line">        <span class="comment">//变量类型 变量名字 = new HelloWorld();</span></span><br><span class="line">        HelloWorld helloWorld = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">        System.out.println(HelloWorld.age);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//类变量  static</span></span><br><span class="line">        System.out.println(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>在实例变量中，从属于对象，如果不自行初始化，值为这个类型的默认值，如 0  0.0  false  null</p>
<p>除了基本类型，其余的默认值都是null</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>不会变动的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> pi =<span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<p>final  类型  变量名 = 值;</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>switch语句、循环语句以及循环控制语句</title>
    <url>/2021/07/02/Day%20004%EF%BC%88switch%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%89/</url>
    <content><![CDATA[<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><span id="more"></span>

<p>switch语句结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">int</span>或String类型的字面值或变量)&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="keyword">int</span>或String类型的字面值或变量：</span><br><span class="line">         java语句;</span><br><span class="line">         ……</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="keyword">int</span>或String类型的字面值或变量：</span><br><span class="line">         java语句;</span><br><span class="line">         ……</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     ……</span><br><span class="line">     <span class="keyword">default</span>；</span><br><span class="line">         Java语句;</span><br><span class="line">         ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、和c语言一样，如果没有break语句，那自上而下匹配成功语句执行后，下面的语句不管能不能匹配成功，都一定执行，称为<strong>case穿透。</strong></p>
<p>2、switch后面和case后面只能为int 和String类型，不能探测其他类型。</p>
<p>3、当然byte,short,char也可以直接写到是switch和case后面，因为他们可以进行自动类型转换，byte，short，char可以自动转换为int类型。</p>
<p>4、case可以合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(i)&#123;</span><br><span class="line">    case1:case2:case3:case4:<span class="comment">//i可以等于1，2，3，4，都可以执行</span></span><br><span class="line">      i=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习</p>
<p>实现计算器当中的加减乘除运算</p>
<p>1、选择所有数据从键盘输入</p>
<p>2、使用swithc语句进行判断</p>
<p>3、需要从控制台输入</p>
<p>第一个数字，运算符，第二个数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">operation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.util.Scanner s=<span class="keyword">new</span> java.util.Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num1=s.nextInt();</span><br><span class="line">        String operation=s.next();</span><br><span class="line">        <span class="keyword">int</span> num2=s.nextInt();</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result=num1+num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result=num1-num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result=num1*num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result=num1/num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;输入的运算符有问题！&quot;</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(num1+<span class="string">&quot;&quot;</span>+operation+<span class="string">&quot;&quot;</span>+num2+<span class="string">&quot;=&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for语法结构"><a href="#for语法结构" class="headerlink" title="for语法结构"></a>for语法结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式;布尔表达式;更新表达式)&#123;</span><br><span class="line">    <span class="comment">//代码行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、初始化表达式，布尔表达式，更新表达式都不是必须的（两个分号必须）</p>
<p>2、初始化表达式最先执行，并且在整个for循环中只执行一次</p>
<p>3、执行过程：</p>
<p>先执行初始化表达式，并且表达式只执行一次</p>
<p>布尔表达式为true，执行循环体，执行更新表达式，再去判断布尔表达式</p>
<p>布尔表达式为false，结束循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">circulation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束循环后i的值&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">报错，循环结束了i的内存被释放，找不到符号</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">circulation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束循环后i的值&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结束循环后的值<span class="number">11</span></span><br></pre></td></tr></table></figure>

<p> 1、内存循环时，与外层循环变量名不能重名</p>
<p>九九乘法表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jiujiuchengfabiao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;=<span class="number">9</span>;a++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">1</span>;b&lt;=a;b++)&#123;</span><br><span class="line">                System.out.println(a+<span class="string">&quot;*&quot;</span>+b+<span class="string">&quot;=&quot;</span>+a*b);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>语句结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(布尔表达式)&#123;</span><br><span class="line">    循环体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do while 语句"></a>do while 语句</h3><p>语句结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure>

<p>至少执行一次</p>
<h2 id="控制循环的语句"><a href="#控制循环的语句" class="headerlink" title="控制循环的语句"></a>控制循环的语句</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>1、break语句使用在switch语句中，用来终止switch语句执行</p>
<p>2、break语句同样使用在循环语句中，用来跳出循环</p>
<p>3、<strong>break可以指定跳出哪一层循环</strong>(以下语法使用较少)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">breakxintexing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        for1:<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            for2:<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">break</span> for1;<span class="comment">//表示跳出for1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>1、主要出现在循环语句中，用来控制循环的执行。</p>
<p>2、表示直接进入下一次循环，和break一样，可以跳出任意一层循环。</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>方法（函数）</title>
    <url>/2021/07/02/Day%20005%EF%BC%88%E6%96%B9%E6%B3%95(%E5%87%BD%E6%95%B0)%EF%BC%89/</url>
    <content><![CDATA[<p>练习，循环找出1-10000中所有的素数</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">prime_number</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i%j==<span class="number">0</span>) &#123;</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                System.out.println(i+<span class="string">&quot;是素数！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法-函数"><a href="#方法-函数" class="headerlink" title="方法(函数)"></a>方法(函数)</h2><p>方法定义在类体当中，在一个类当中可以定义多个方法，方法没有编写顺序，可以随意。</p>
<p>方法体中不能定义方法。</p>
<p>方法体由java语句构成，自上而下执行。</p>
<p>1、定义语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符列表】 返回值类型 方法名(形式参数列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、方法的修饰符列表当中有static关键字的话，**-  类名.方法名（实际参数列表）;**</p>
<p>3、一个方法的返回值，为定义的返回值类型。</p>
<p>4、也可能这个方法执行结束后不返回任何数据，当一个方法执行结束后，不返回任何数据的话，返回值类型位置必须写<strong>void关键字</strong></p>
<p>5、返回值类型若不是void，表示这个方法执行结束之后必须返回一个具体的数值。 </p>
<p>6、当返回值类型为void时，方法体中<strong>不能出现”return值“</strong>这样的语句，但要注意可以编写“return”这样的语句。</p>
<p>7、当在方法体中遇到“return”语句时，return语句所在的<strong>方法</strong>就结束</p>
<p>8、方法名首字母小写，后面的每个单词首字母大写</p>
<p>9、方法体必须由大括号括起来，由java语句构成。</p>
<p>10、形参为局部变量，形参之间用逗号隔开，形参中决定性作用的是形参的数据类型。实参类型与形参数据类型必须一致。</p>
<p>调用：   <strong>类名.方法名(实参列表)；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public 表示公开的，class表示定义类，method是一个类名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">method</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*public表示公开的，static表示静态的，void表示方法执行结束之后不返回任何数据，main是方法名，主方法</span></span><br><span class="line"><span class="comment">    (String[] args) 形式参数列表，其中String[]是一种引用数据类型，args是一个局部变量的变量名</span></span><br><span class="line"><span class="comment">    主方法就需要这样固定编写，这是程序的入口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">        method.sum(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c=x+y;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在方法中输出</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,x;</span><br><span class="line">        x=method.sum(a,b);</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c=x+y;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在主方法中输出</span><br></pre></td></tr></table></figure>

<p>在方法调用中，存在自动类型转换。</p>
<p>11、方法的修饰符列表当中static关键字，完整的调用方式是；<strong>类名.方法名(实参列表);</strong></p>
<p>对于方法的修饰符列表当中有static关键字是，”类名.”可以省略不写。<strong>如果不写类，那就在当前类中寻找方法。</strong></p>
<p>12、调用可以不接收返回值</p>
<p>13、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//编译报错，编译器无法保证一定有返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>14、return下不能编写代码。</p>
<p>15、返回值为void类型的方法，return的作用为终止方法执行。</p>
<h3 id="方法执行时，内存分配"><a href="#方法执行时，内存分配" class="headerlink" title="方法执行时，内存分配"></a>方法执行时，内存分配</h3><p>方法在执行过程中，在JVM中的内存分配</p>
<p>方法只定义，不调用，是不会执行的，并且在JVM中不会给该方法分配“运行所属”的内存空间，只有在调用这个方法是，才会动态的给这个方法分配所需的内存空间。</p>
<p>17、在JVM内存划分上有这样三块主要内存空间。</p>
<p>方法区内存，堆内存，栈内存</p>
<p>18、栈数据结构</p>
<p>​         栈：stack，是一种数据结构</p>
<p>​          数据结构反应的是数据的存储形态</p>
<p>19、方法代码片段属于.class字节码文件的一部分，字节码文件在类加载的时候，将其放到了方法区当中，所以JVM中的三块主要的内存空间中方法区内存最先有数据，其中存放代码片段。</p>
<p>代码片段虽然在方法区内存中只有一份，但可以被重复调用。每一次调用这个方法时，需要给该方法在栈内存中分配独立的活动场所。</p>
<p>方法在调用的瞬间，会给该方法分配内存空间，会在栈中发生<strong>压栈</strong>动作，方法执行结束后，分配的内存空间全部释放，此时发生<strong>弹栈</strong>动作。</p>
<p>局部变量在栈中存储，局部变量在“方法体”中声明。</p>
<h3 id="方法的重载机制-overload"><a href="#方法的重载机制-overload" class="headerlink" title="方法的重载机制/overload"></a>方法的重载机制/overload</h3><p>当几个方法功能不同，但功能相似，比如都是求和，对于起了三个名字的方法而言，记忆复杂，不方便。</p>
<p>方法重载机制可以让使用这些方法像使用一个方法一样</p>
<p>用法：把方法名定义一样，<strong>调用方法时根据实参类型和形参类型来判断使用哪一个方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">method2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">1L</span>,<span class="number">2L</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">1.0</span>,<span class="number">2.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、方法重载又称为；overload</p>
<p>2、方法名一样，形参列表不同（数量不同，顺序不同，类型不同）</p>
<p>3、方法重载和修饰符列表无关</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>空指针异常、封装性以及构造方法</title>
    <url>/2021/07/02/Day%20007%EF%BC%88%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h3 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h3><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stduent</span></span>&#123;</span><br><span class="line">    String student_number;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">School</span></span>&#123;</span><br><span class="line">    Student s=<span class="keyword">new</span> Student();</span><br><span class="line">    s=<span class="keyword">null</span>;</span><br><span class="line">    System.out.println(s.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当给引用s赋值null时，空引用访问”实例“相关的数据，一定会出现空指针异常。编译会通过，但运行出现空指针异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">seekcomputer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer c=<span class="keyword">new</span> Computer();</span><br><span class="line">        c.brand=<span class="string">&quot;LEGION&quot;</span>;</span><br><span class="line">        c.model=<span class="string">&quot;i7&quot;</span>;</span><br><span class="line">        c.color=<span class="string">&quot;yellow&quot;</span>;</span><br><span class="line">        Student s=<span class="keyword">new</span> Student();</span><br><span class="line">        s.stu_number=<span class="number">1234</span>;</span><br><span class="line">        s.name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        s.brain=c;</span><br><span class="line">        System.out.println(s.brain.color);</span><br><span class="line">        <span class="comment">//修改颜色</span></span><br><span class="line">        s.brain.color=<span class="string">&quot;blue&quot;</span>;</span><br><span class="line">        System.out.println(s.brain.color);</span><br><span class="line">        <span class="comment">//张三又买了一个新电脑</span></span><br><span class="line">        Computer c2=<span class="keyword">new</span> Computer();</span><br><span class="line">        c.color=<span class="string">&quot;hot&quot;</span>;</span><br><span class="line">        s.brain=c;</span><br><span class="line">        System.out.println(s.brain.color);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stu_number;</span><br><span class="line">    String name;</span><br><span class="line">    Computer brain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    String brand;</span><br><span class="line">    String model;</span><br><span class="line">    String color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个类中都可以写主方法，但是一般情况下，一个系统只有一个入口，所以主方法一般写一个。</p>
<h2 id="面向对象的封装性"><a href="#面向对象的封装性" class="headerlink" title="面向对象的封装性"></a>面向对象的封装性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stu_number;</span><br><span class="line">    String name;</span><br><span class="line">    Computer brain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于此类中的属性来说，外部程序可以随意访问，导致不安全。</p>
<p><strong>封装性的好处：</strong></p>
<p>1、封装之后，对于那个事物来说，看不到这个事物复杂的一面，只能看到该事物简单的一面，方便用户使用</p>
<p>2、封装之后才会形成真正的“对象”，真正的“独立体”</p>
<p>3、封装意味着以后的程序可以重复使用，并且这个事物应该适应性比较强，在任何场合都可以使用。</p>
<p>4、封装之后，对于事物本身，提高了安全性</p>
<p><strong>封装的步骤</strong></p>
<p>1、所有属性私有化，使用private关键字进行修饰，修饰的所有数据只能在本类中访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">privat <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure>

<p>此时，外部程序是访问不了类当中的age属性的。</p>
<p>2、对外提供简单的操作入口。</p>
<p>通常使用类中的属性，无非为：访问（get）和修改（set）</p>
<p>所以对外提供两个公开的方法，set方法和get方法</p>
<p><em><strong>set方法的命名规范</strong></em>(<strong>没有返回值，set方法只负责修改)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    age=a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>get方法的命名规范</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、setter and getter 方法没有static关键字</p>
<p>2、有static关键字修饰的方法调用：<strong>类名.方法名(实参);</strong></p>
<p>​     没有static关键字修饰的方法怎么调用：<strong>引用.方法名(实参);</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        age=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        user.setAge(-<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        System.out.println(user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error!</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>IDEA在代码空白处右击，点击Generate，在弹出的界面内选择setter和getter。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>1、又被称为构造函数/构造器/Constructor</p>
<p>2、构造方法语法结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 构造方法名(形式参数列表)&#123;</span><br><span class="line">    构造方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、对于构造方法来说，“返回值类型”不需要指定，并且也不能写void</p>
<p>4、<strong>构造方法名必须和类名保持一致</strong></p>
<p>5、构造方法的作用：通过构造方法，可以创建对象。 </p>
<p>6、</p>
<p>​       <strong>普通方法调用</strong>：方法修饰符中有static：类名.方法名(实参列表);</p>
<p>​                           没有static：引用.方法名(实参列表);</p>
<p>​       <strong>构造方法调用</strong>：new  构造方法名(实参列表)</p>
<p>7、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User s=<span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>

<p>有返回值，但这个 <strong>return 值</strong>  这样的语句不用写</p>
<p>并且放回类型为构造方法所在类的类型，由于构造方法返回值类型就是类本身，所以返回值类型不需要编写。</p>
<p>8、当一个类中没有定义任何构造方法的话，系统默认给该类提供一个无参数的构造方法，这个构造方法称为缺省构造器。</p>
<p>9、当一个类显示的构造方法定义出来了，那么系统则不</p>
<p>再默认这个类提供缺省构造器</p>
<p>10、<strong>构造方法支持重载机制</strong>，在一个类当中编写多个构造方法，则形成了方法重载机制</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>OOP三大特征、类和对象的概念和创建，JVM内存简单分析</title>
    <url>/2021/07/02/Day%20006%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E5%92%8CJVM%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%89/</url>
    <content><![CDATA[<h3 id="方法的递归调用"><a href="#方法的递归调用" class="headerlink" title="方法的递归调用"></a>方法的递归调用</h3><p>可以不用递归，尽量别用</p>
<span id="more"></span>

<h2 id="面向对象（重要）"><a href="#面向对象（重要）" class="headerlink" title="面向对象（重要）"></a>面向对象（重要）</h2><h3 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h3><p>面向过程：主要关注点是：实现的具体过程，因果关系</p>
<p>​                   优点：对于业务逻辑比较简单的程序，可以达到快速开发，前期投入成本较低</p>
<p>​                    缺点：采用面向过程的方式开发很难解决非常复杂的业务逻辑，另外面向过程的方式导致软件元素之间“耦合度”非常高，只要其中一环出问题，整个系统受到影响，导致最终的软件扩展力差，另外，由于没有独立体的概念，所以无法达到组件复用</p>
<p>面向对象：主要关注点是：主要关注对象【独立体】能完成那些功能</p>
<p>​                     优点：耦合度低，扩展力强，更容易解决现实世界当中更复杂的业务逻辑，组件复用性强。</p>
<p>​                      缺点：前期投入成本较高，需要进行独立体的抽取，大量的系统分析与设计。</p>
<h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><p><strong>封装</strong></p>
<p><strong>继承</strong></p>
<p><strong>多态</strong></p>
<p>所有面向对象的编程语言都有这三大特征。</p>
<p>采用面向对象的方式开发一个软件，生命周期当中：</p>
<p><strong>1、面向对象的分析(OOA)</strong></p>
<p><strong>2、面向对象的设计(OOD</strong>)</p>
<p><strong>3、面向对象的编程(OOP)</strong></p>
<h3 id="类和对象的概念"><a href="#类和对象的概念" class="headerlink" title="类和对象的概念"></a>类和对象的概念</h3><p><strong>类</strong>在现实世界中不存在，是一个模板，是一个概念，是人类大脑思考抽象的结果</p>
<p>类代表了一类事物</p>
<p>在现实世界当中，对象A和B之间具有相同特征，进行抽象总结出一个模板，这个模板被称为类。</p>
<p>类是对象的抽象</p>
<p><strong>对象</strong>是实际存在的个体，现实世界当中实际存在，对象是类的实例化</p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>语法结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    属性;</span><br><span class="line">    方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性通常采用一个变量的形式才完成定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;  <span class="comment">//类名为Student 代表了所有的学生对象，是一个学生模板</span></span><br><span class="line">    <span class="keyword">int</span> Student_number;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">boolean</span> sex;</span><br><span class="line">    String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的创建和使用"><a href="#对象的创建和使用" class="headerlink" title="对象的创建和使用"></a>对象的创建和使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Student_number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、类体=属性+方法</p>
<p>2、由于变量定义在类体当中，这种变量称为成员变量<br>要访问其中的成员变量，要通过对象来访问</p>
<p>3、学号信息不能直接通过“类”访问，所以这种成员变量又被叫做；实例变量</p>
<p>4、对象又被成为实例，实例变量又被称为对象变量</p>
<p>5、不创建对象，这个Student_number变量的内存空间不存在，只有创建了对象，这个Student_number变量内存空间才会创建</p>
<p>6、成员变量没有手动赋值的话，系统赋默认值</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte,short,int ,long</td>
<td>0</td>
</tr>
<tr>
<td>float,double</td>
<td>0.0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>引用数据类型</td>
<td>null,空值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ootest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s=<span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、实例化对象的语法：new 类名（）；</p>
<p>2、new是java语言中的一个运算符</p>
<p>3、new运算符的作用是创建对象，在JVM堆内存中开辟新的内存空间</p>
<p>4、Student()是一个引用数据类型</p>
<p>5、s是一个变量名，是局部变量，（在栈内存中存储，存储的为一个地址，指向堆内存中的Student对象）<strong>s称为对象</strong></p>
<p>6、new Student()是一个学生对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">读取数据：引用.变量名;</span><br><span class="line">修改数据：引用.变量名=值;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ootest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s=<span class="keyword">new</span> Student();</span><br><span class="line">        <span class="keyword">int</span> stu_stu_number=s.Student_number;</span><br><span class="line">        <span class="keyword">int</span> stu_age=s.age;</span><br><span class="line">        String stu_address=s.address;</span><br><span class="line">        System.out.println(stu_stu_number);<span class="comment">// System.out.println(s.Student_number);</span></span><br><span class="line">        System.out.println(stu_age);<span class="comment">// System.out.println(s.age);</span></span><br><span class="line">        System.out.println(stu_address);<span class="comment">// System.out.println(s.address);</span></span><br><span class="line">        s.address=<span class="string">&quot;北京&quot;</span>;</span><br><span class="line">        s.age=<span class="number">12</span>;</span><br><span class="line">        System.out.println(s.address);</span><br><span class="line">        System.out.println(s.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">北京</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">School</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no;</span><br><span class="line">    String name;</span><br><span class="line">    Student addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addr是一个实例变量，也是一个引用。（在栈内存中保存一个地址，指向堆内存中的对象）</p>
<p>name是一个实例变量，也是一个引用。</p>
<h3 id="JVM的内存分析"><a href="#JVM的内存分析" class="headerlink" title="JVM的内存分析"></a>JVM的内存分析</h3><p>JVM主要包括三块内存空间：栈内存，堆内存，方法区内存</p>
<p>1、堆内存和栈内存各有一个，一个线程一个栈内存</p>
<p>2、在程序运行中，用new运算符创建的java对象，存储在堆内存中，当对象内部有实例变量，所以实例变量存储在堆内存当中</p>
<p>3、局部变量：方法体中声明</p>
<p>​     成员变量：方法体外声明</p>
<p>​                      实例变量：前边修饰符没有static</p>
<p>​                      静态变量：前面修饰符中有static</p>
<p>4、静态变量存储在方法区内存中。</p>
<p>5、三块内存当中变化最频繁的是栈内存，最先有数据的为方法区内存，垃圾回收器主要针对的是堆内存。</p>
<p>6、当堆内存当中的java对象成为垃圾数据的时候 ，会被垃圾回收器回收。（没有更多的引用指向它的时候），这个对象无法被访问，因为访问对象只能通过引用的方式访问。</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>this关键字、static关键字</title>
    <url>/2021/07/02/Day%20009%EF%BC%88this%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/</url>
    <content><![CDATA[<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>方法定义中有static，需要用类名访问。没有则用引用访问</p>
<span id="more"></span>

<p>实例变量需要引用访问</p>
<p>因为使用类名访问，没有当前对象，所以不能用this，而用引用来访问，是有对象的，所以可加this（代表当前对象）</p>
<p>1、在<strong>带有</strong>static不能直接访问实例变量和实例方法，因为实例变量和实例方法都需要对象的存在。而static方法当中是没有this的，也就是说当前对象不存在，所以无法访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">thisTest02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        thisTest02 c=<span class="keyword">new</span> thisTest02();</span><br><span class="line">        System.out.println(c.i);</span><br><span class="line">        thisTest02.dosome();<span class="comment">//dosome();</span></span><br><span class="line">        <span class="comment">//thisTest02.doother()编译错误，实例方法必须先创建对象，通过引用的方式访问</span></span><br><span class="line">        <span class="comment">//doother（），调用当前对象的doother方法，但由于main方法中没有this，所以不能调用</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dosome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//doother为实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doother</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doother&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        doother();<span class="comment">//run是一个实例方法，调用run方法的一定有对象存在，所以doother当前对象就是调用run的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="this用法"><a href="#this用法" class="headerlink" title="this用法"></a>this用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        id=a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  以下程序的id和实例变量id无关，不能采用这种方式</span></span><br><span class="line"><span class="comment">    public void setId(int id) &#123;</span></span><br><span class="line"><span class="comment">        id = id;  可以写为this.id=id;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line">    <span class="comment">//当调用以下无参数构造方法时，默认创建日期为1970-1-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years=<span class="number">1970</span>;</span><br><span class="line">        <span class="keyword">this</span>.month=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.day=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 以上三行可以写为  this(1970,1,1)</span></span><br><span class="line"><span class="comment">           可以调用其他构造方法，</span></span><br><span class="line"><span class="comment">           不可以使用new Date(1970,1,1)因为会创建一个新的对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">int</span> years,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years=years;</span><br><span class="line">        <span class="keyword">this</span>.month=month;</span><br><span class="line">        <span class="keyword">this</span>.day=day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供一个方法可以打印输出日期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.years+<span class="string">&quot;年&quot;</span>+<span class="keyword">this</span>.month+<span class="string">&quot;月&quot;</span>+<span class="keyword">this</span>.day+<span class="string">&quot;日&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYears</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> years;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setYears</span><span class="params">(<span class="keyword">int</span> years)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> month;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMonth</span><span class="params">(<span class="keyword">int</span> month)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.month = month;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDay</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date d1=<span class="keyword">new</span> Date();</span><br><span class="line">        d1.print();</span><br><span class="line">        Date d2=<span class="keyword">new</span> Date(<span class="number">2008</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">        d2.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日</span><br><span class="line"><span class="number">2008</span>年<span class="number">1</span>月<span class="number">1</span>日</span><br></pre></td></tr></table></figure>

<p>1、可以使用在实例方法当中，代表当前对像【this.】</p>
<p>2、可以使用在构造方法中，通过当前的构造方法调用其他的构造方法【 this(实参)；】</p>
<p><strong>this（）只能出现在构造方法中第一行</strong></p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> </span>&#123;</span><br><span class="line">    String id;</span><br><span class="line">    String name;</span><br><span class="line">    String country;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">(String id,String name,String country)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.country=country;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staticworld</span> </span>&#123;</span><br><span class="line">    Chinese zhangsan=<span class="keyword">new</span> Chinese(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;China&quot;</span>);</span><br><span class="line">    Chinese lisi=<span class="keyword">new</span> Chinese(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;China&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为两个人的国家都是China，所以可以使用static关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> </span>&#123;</span><br><span class="line">    String id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">static</span> String country=<span class="string">&quot;China&quot;</span>;<span class="comment">//静态变量，静态变量在类加载的时候初始化，不需要创建对象，内存就开辟了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">(String id,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staticworld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chinese zhangsan=<span class="keyword">new</span> Chinese(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(zhangsan.id+zhangsan.name+Chinese.country);</span><br><span class="line">        Chinese lisi=<span class="keyword">new</span> Chinese(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(lisi.id+lisi.name+Chinese.country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实例变量</strong>：所有对象都有这个属性，且属性的值<strong>会</strong>随着对象的变化而变化</p>
<p><strong>静态变量</strong>：所有对象都有这个属性，且属性的值<strong>不会</strong>随着对象的变化而变化</p>
<p>1、static修饰的方法是静态方法</p>
<p>2、static修饰的变量是静态变量</p>
<p>3、所有static修饰的元素都称为静态的，都可以使用”类名.“方法访问，当然也可以用引用， 但不建议</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>1、语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    java语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、静态代码块在类加载时执行，且只执行一次</p>
<p>3、可以编写多个，自上而下执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类加载1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类加载2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类加载<span class="number">1</span></span><br><span class="line">类加载<span class="number">2</span></span><br><span class="line">主方法</span><br></pre></td></tr></table></figure>

<p>4、静态代码用处：与具体的需求有关，例如在类加载的时候                      执行代码完成日志的记录。静态代码时java为程序员准备的一个特殊的时刻，这个时刻被称为类加载时刻。如希望在此刻执行一段特殊的程序，这段程序可以直接放到静态代码块当中</p>
<p>5、通常在静态代码块中完成预备工作，完成数据的准备工具</p>
<h3 id="方法声明为静态"><a href="#方法声明为静态" class="headerlink" title="方法声明为静态"></a><strong>方法声明为静态</strong></h3><p>1、方法描述的是动作，当所有的对象执行这个动作时，结果都是一样的，可以将这个对象提升为类级别的动作，模板级别的动作</p>
<p>静态方法中无法直接访问实例变量和实例方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c =Math.cheng(a,b);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        <span class="keyword">double</span> i=<span class="number">55.5</span>,j=<span class="number">5.5</span>;</span><br><span class="line">        <span class="keyword">double</span> g= Math.chu(i,j);</span><br><span class="line">        System.out.println(g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cheng</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">chu</span><span class="params">(<span class="keyword">double</span> q,<span class="keyword">double</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q/w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>继承、方法的覆盖，多态及instanceof语法结构</title>
    <url>/2021/07/02/Day%20010%EF%BC%88%E7%BB%A7%E6%89%BF%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96%E3%80%81%E5%A4%9A%E6%80%81%E4%BB%A5%E5%8F%8Ainstanceof%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    <content><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><span id="more"></span>

<p>1、语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;修饰符列表&#125; <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类名</span>&#123;</span><br><span class="line">    类体=属性+方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、基本作用：代码复用，有了继承才有以后方法的覆盖和多态机制</p>
<p>3、java语言当中的继承只支持单继承，一个类不能同时继承很多类，只能继承一个类，在c++中支持多继承</p>
<p>4、B类继承A类。</p>
<p>​      A类称为：父类，基类，superclass</p>
<p>​      B类称为：子类，派生类，subclass</p>
<p>5、子类继承父类</p>
<p>​       私有的不支持继承</p>
<p>​       构造方法不支持继承</p>
<p>​       其他数据都可以继承</p>
<p>6、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C extends B&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">B extends A&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">A extends T&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C直接继承B类，但是C类间接继承T，A类。</p>
<p>7、java语言中假设一个类没有显示继承任何类，该类默认继承JavaSE库当中提供的java.lang.Object类。（java语言中任何一个类中都有Object类的特征）</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String actno;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account01</span><span class="params">(String actno, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actno = actno;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getActno</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> actno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActno</span><span class="params">(String actno)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actno = actno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreditAccount</span> <span class="keyword">extends</span>  <span class="title">Account01</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> credit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreditAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCredit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> credit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCredit</span><span class="params">(<span class="keyword">double</span> credit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.credit = credit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CreditAccount act01=<span class="keyword">new</span> CreditAccount();</span><br><span class="line">        act01.setActno(<span class="string">&quot;001&quot;</span>);</span><br><span class="line">        act01.setBalance(<span class="number">100.5</span>);</span><br><span class="line">        act01.setCredit(<span class="number">0.99</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;账户&quot;</span>+act01.getActno()+<span class="string">&quot;余额&quot;</span>+act01.getBalance()+<span class="string">&quot;信用&quot;</span>+act01.getCredit());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">账户<span class="number">001</span>余额<span class="number">100.5</span>信用<span class="number">0.99</span></span><br></pre></td></tr></table></figure>

<h2 id="方法的覆盖"><a href="#方法的覆盖" class="headerlink" title="方法的覆盖"></a>方法的覆盖</h2><p>1、当父类中的方法无法满足当前子类的业务需求，子类需要将父类继承过来的方法进行重写或覆盖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在MOVE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在walk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟在fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverwirteTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a=<span class="keyword">new</span> Animal();</span><br><span class="line">        a.move();</span><br><span class="line"></span><br><span class="line">        Cat c=<span class="keyword">new</span> Cat();</span><br><span class="line">        c.move();</span><br><span class="line"></span><br><span class="line">        Bird b=<span class="keyword">new</span> Bird();</span><br><span class="line">        b.move();</span><br><span class="line">        </span><br><span class="line">        yingwu y=<span class="keyword">new</span> yingwu();</span><br><span class="line">        y.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">动物在MOVE</span><br><span class="line">猫在walk</span><br><span class="line">鸟在fly</span><br><span class="line">鸟在fly</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">yingwu</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、方法重写发生在具有继承关系的父子类之间</p>
<p>​      方法重写的时候：<strong>方法名相同，返回值类型相同，形参列表相同。</strong>访问权限不能更低，可以更高。抛出异常不能更多，可以更少</p>
<p>3、注意：私有方法不能继承，所以不能覆盖</p>
<p>​                 构造方法不能继承，所以不能覆盖</p>
<p>​                 静态方法不存在覆盖</p>
<p>4、覆盖只针对方法，不针对属性</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>1、关于多态中涉及到的几个概念：</p>
<p>​        向上转型（upcasting）：子类型——-&gt;父类型</p>
<p>​        向下转型（down casting）：父类型—–&gt;子类型【需要加强制类型转换符】</p>
<p><strong>注意：转型必须有继承关系</strong>     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal在MOVE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat在WALK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫捉老鼠！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird在FLY&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird没在fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a1=<span class="keyword">new</span> Animal();</span><br><span class="line">           a1.move();</span><br><span class="line">        Bird b1=<span class="keyword">new</span> Bird();</span><br><span class="line">           b1.move();</span><br><span class="line">        Cat c1=<span class="keyword">new</span> Cat();</span><br><span class="line">           c1.move();</span><br><span class="line">        c1.catchMouse();</span><br><span class="line">        Animal a2=<span class="keyword">new</span> Cat();<span class="comment">//new Cat()创建的对象类型是Cat，a2这个引用的数据类型是Animal，可见它们进行了类型转化。子类型转换为父类型，向上转换</span></span><br><span class="line">        a2.move();</span><br><span class="line">        <span class="comment">//a2.catchMouse编译错误，编译器只知道a2的类型为Animal，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal在MOVE</span><br><span class="line">Bird在FLY</span><br><span class="line">Cat在WALK</span><br><span class="line">猫捉老鼠！</span><br><span class="line">Cat在WALK</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/02/Day%20010%EF%BC%88%E7%BB%A7%E6%89%BF%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96%E3%80%81%E5%A4%9A%E6%80%81%E4%BB%A5%E5%8F%8Ainstanceof%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84%EF%BC%89/Users\樊飞扬\AppData\Roaming\Typora\typora-user-images\image-20210116152555543.png" alt="image-20210116152555543"></p>
<p>java程序分为编译阶段和运行阶段，编译无法通过则无法运行</p>
<p>编译阶段：a2被编译器认定为是Animal类型，所以只能运行Animal中存在的方法，否则编译出错 </p>
<p>运行阶段：因为在堆内存中创建的是一个Cat对象，所以运行结果为Cat从Animal那里继承的方法的结果（如果在Cat类中使用了方法重写，那么结果为重写之后运行的结果）</p>
<p>如果想在a2中使用catchMouse方法，可以强制将a2类型转换为Cat类型。父类转换为子类，向下转型，（当调用的方法或者访问的属性是子类中特有的，在父类中不存在，必须进行向下转型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat a2=Cat(a2);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a3=<span class="keyword">new</span> Bird();</span><br><span class="line">Cat a4=(Cat)a3;<span class="comment">//编译通过，但运行出错，因为Cat类和Bird类没有继承关系</span></span><br></pre></td></tr></table></figure>

<p>这个异常被称为：<strong>java.lang.ClassCsatException</strong></p>
<p>这种异常常常在“向下转型”的时候发生</p>
<p>这样避免这种异常：使用<strong>instanceof</strong>运算符可以避免出现以上的异常</p>
<h3 id="instanceof语法结构"><a href="#instanceof语法结构" class="headerlink" title="instanceof语法结构"></a>instanceof语法结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(引用 <span class="keyword">instanceof</span> 数据类型名)</span><br></pre></td></tr></table></figure>

<p>以上运算符的执行结果类型为布尔类型，true or  false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> Animal</span><br></pre></td></tr></table></figure>

<p>true表示：a这个引用指向的对象是一个Animal类型</p>
<p>false表示：a这个引用指向的对象不是一个Animal类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (a2 <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            Cat c2=(Cat)a2;<span class="comment">//c2是一个新的引用</span></span><br><span class="line">            c2.catchMouse();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a2 <span class="keyword">instanceof</span> Bird)&#123;</span><br><span class="line">            Bird b2=(Bird)a2;</span><br><span class="line">            b2.Fly();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">新增</span><br><span class="line">猫捉老鼠！</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>final关键字、super关键字</title>
    <url>/2021/07/02/Day%20011%EF%BC%88final%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/</url>
    <content><![CDATA[<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>-final是一个关键字，表示最终的，不可变的<br>       -final修饰的类无法被继承</p>
<span id="more"></span>
<pre><code>   -final修饰的方法无法被覆盖
   -final修饰的变量一旦赋值之后，不可重新赋值
</code></pre>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>1、<strong>this</strong></p>
<p>this能出现在实例方法和构造方法中</p>
<p>​     语法结构：this.     this()</p>
<p>this不能使用在静态方法中。</p>
<p>this只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中其他的构造方法，目的是：代码复用</p>
<p>2、<strong>super</strong></p>
<p>super能出现在实例方法和构造方法中</p>
<p>​     语法结构：super.    super()</p>
<p>super不能使用在静态方法中。</p>
<p>super()     只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中其他的构造方法，目的是：创建子类对象时，先初始化父类型特征</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A类的无参数构造方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//super()  默认有这一段代码</span></span><br><span class="line">            System.out.println(<span class="string">&quot;B类的无参数构造方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">A类的无参数构造方法</span><br><span class="line">B类的无参数构造方法</span><br></pre></td></tr></table></figure>

<p>super()  表示通过了子类的构造方法调用父类的构造方法，模拟现实世界中的这种场景：要想有儿子，需要先有父亲</p>
<p>如果在A类中手动创建一个构造方法，这系统不在提供无参数构造系统，这时运行出错。</p>
<p><strong>当一个构造方法第一行，既没有this()又没有super()的话，默认会有一个super()；表示通过当前子类的构造方法调用父类的无参数构造方法，所以必须保证父类的无参数构造方法是存在的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A类的有参数构造方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="number">123</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;B类的无参数构造方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">A类的有参数构造方法</span><br><span class="line">B类的无参数构造方法</span><br></pre></td></tr></table></figure>

<p>对super的调用必须是构造方法中第一个语句</p>
<p>注意：this()和super()不能共存，他们都只能出现在构造方法的第一行</p>
<p>无论怎样，父类的构造方法一定执行</p>
<p>练习</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类的无参数构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B类的无参数构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B类的有参数构造方法执行（String）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">C</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;C类的无参数构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">C</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C类的有参数构造方法执行（String）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">C</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;C类的有参数构造方法执行（String，age）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A类的无参数构造方法执行</span><br><span class="line">B类的无参数构造方法执行</span><br><span class="line">C类的有参数构造方法执行（String）</span><br><span class="line">C类的无参数构造方法执行</span><br></pre></td></tr></table></figure>

<p>例子：银行输入查找账户，余额，信誉度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankSeek</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CreditAccount act01=<span class="keyword">new</span> CreditAccount();</span><br><span class="line">        System.out.println(<span class="string">&quot;账户&quot;</span>+act01.getActno()+<span class="string">&quot;  余额&quot;</span>+act01.getBalance()+<span class="string">&quot;  信誉度&quot;</span>+act01.getCredit());</span><br><span class="line">        CreditAccount act02=<span class="keyword">new</span> CreditAccount(<span class="string">&quot;1111&quot;</span>,<span class="number">10000.0</span>,<span class="number">0.99</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;账户&quot;</span>+act02.getActno()+<span class="string">&quot;  余额&quot;</span>+act02.getBalance()+<span class="string">&quot;  信誉度&quot;</span>+act02.getCredit());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String actno;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">        <span class="comment">//actno=null;</span></span><br><span class="line">        <span class="comment">//balance=0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String actno,<span class="keyword">double</span> balance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actno=actno;</span><br><span class="line">        <span class="keyword">this</span>.balance=balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getActno</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> actno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActno</span><span class="params">(String actno)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actno = actno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditAccount</span> <span class="keyword">extends</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> credit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreditAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">        <span class="comment">//credit=0.0;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreditAccount</span><span class="params">(String actno,<span class="keyword">double</span> balance, <span class="keyword">double</span> credit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(actno,balance);<span class="comment">//可以通过super()来调用父类的构建方法进行赋值。</span></span><br><span class="line">        <span class="keyword">this</span>.credit=credit;</span><br><span class="line">        <span class="comment">//在这里不能用同样的方法给actno，balance赋值，因为这两个变量是父类中的私有变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCredit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> credit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCredit</span><span class="params">(<span class="keyword">double</span> credit)</span> </span>&#123;</span><br><span class="line">        credit = credit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序在JVM中：</p>
<p><img src="/2021/07/02/Day%20011%EF%BC%88final%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Users\樊飞扬\AppData\Roaming\Typora\typora-user-images\image-20210117142547227.png" alt="image-20210117142547227"></p>
<p>注意：父类中有，子类中有 ，如果想在子类中访问“父类的特征”，super，不能省略</p>
<p>super.属性名  【访问父类的属性】</p>
<p>super.方法名(实参)   【访问父类的方法】</p>
<p>super(实参)       【调用父类的构造方法】</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>任务调度</title>
    <url>/2021/07/16/Linux%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="crontab任务调度"><a href="#crontab任务调度" class="headerlink" title="crontab任务调度"></a>crontab任务调度</h2><p><code>crontab</code>进行定时任务的设置</p>
<span id="more"></span>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>任务调度：是指系统在某个时间执行的特定的命令或程序</p>
<p>任务调度分类：系统工作：有些重要的工作必须周而复始地执行。个别用户可能希望执行某个程序。</p>
<p><code>crontab [选项]</code></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>编辑crontab定时任务</td>
</tr>
<tr>
<td>-l</td>
<td>查询crontab任务</td>
</tr>
<tr>
<td>-r</td>
<td>删除当前用户所有的crontab任务</td>
</tr>
</tbody></table>
<p>例如：每一分钟都执行一次<code>ls -l /etc/ &gt; /tmp/to.txt</code>，输入<code>crontab -e</code>命令，接着输入任务到调度文件，如：<code>*/1****ls -l /etc/ &gt; /tmp/to.txt</code>。意思为每小时的每分钟执行一次。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个“*”</td>
<td>一小时当中的第几分钟</td>
<td>0~59</td>
</tr>
<tr>
<td>第二个“*”</td>
<td>一天当中的第几小时</td>
<td>0~23</td>
</tr>
<tr>
<td>第三个“*”</td>
<td>一个月当中的第几天</td>
<td>1~31</td>
</tr>
<tr>
<td>第四个“*”</td>
<td>一年当中的第几月</td>
<td>1~12</td>
</tr>
<tr>
<td>第五个“*”</td>
<td>一周当中的星期几</td>
<td>0~7（0和7都代表星期日）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表任何时间</td>
</tr>
<tr>
<td>，</td>
<td>代表不连续时间</td>
</tr>
<tr>
<td>-</td>
<td>代表连续的时间范围</td>
</tr>
<tr>
<td>*/n</td>
<td>代表每隔多久执行一次</td>
</tr>
</tbody></table>
<h2 id="at任务调度机制"><a href="#at任务调度机制" class="headerlink" title="at任务调度机制"></a>at任务调度机制</h2><p>概述：<code>at</code>命令使一次性定时任务，<code>at</code>的守护进程<code>atd</code>会以后台模式运行，检查作业队列来运行。默认情况下，<code>atd</code>守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。<code>at</code>命令时一次性定时计划任务，执行完一个任务后不再执行此任务了。在使用<code>at</code>命令的时候，一定要保证<code>atd</code>进程的启动，可以使用相关指令来查看。</p>
<p><code>at [选项] [时间]</code>,<code>Ctrl + D</code>结束at命令的输入。</p>
<ul>
<li><code>ps -ef | grep atd</code>“：可以检测<code>atd</code>是否在运行</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-m</td>
<td>当指定的任务被完成后，给用户发送邮件，即使没有标准输出</td>
</tr>
<tr>
<td>-I</td>
<td>atq的别名</td>
</tr>
<tr>
<td>-d</td>
<td>atrm的别名</td>
</tr>
<tr>
<td>-v</td>
<td>显示任务将被执行的时间</td>
</tr>
<tr>
<td>-c</td>
<td>打印任务的内容到标准输出</td>
</tr>
<tr>
<td>-V</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>-q&lt;队列&gt;</td>
<td>使用指定的队列</td>
</tr>
<tr>
<td>-f&lt;文件&gt;</td>
<td>从指定文件读入任务而不是从标准输入读入</td>
</tr>
<tr>
<td>-t&lt;时间参数&gt;</td>
<td>以时间参数的形式提交要运行的任务</td>
</tr>
</tbody></table>
<p>时间指定方法：</p>
<ul>
<li>接受在当天的hh:mm（小时：分钟）式的时间指定，如果时间已经过去，则在第二天执行</li>
<li>使用midnight（深夜），noon（中午），teatime（饮茶时间，通常为以下四点）等比较模糊的词语指定</li>
<li>采用12小时计时制，即在时间后面加上AM或PM来说明上午或者下午。</li>
<li>指定命令执行的具体日期，指定格式为：month day（月，日）或者 mm/dd/yy（月/日/年）或dd.mm.yy(日.月.年)指定的日期必须跟在指定时间的后面。</li>
<li>使用相对计时法，指定格式为：now+count time-units，now就是当前时间，time-units是时间单位，例如：now+5 minutes</li>
<li>直接使用today，tomorrow来指定</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>压缩和解压类</title>
    <url>/2021/07/12/Linux%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h2><p><code>gzip/gunzip</code>指令</p>
<span id="more"></span>
<ul>
<li><code>gzip 文件</code>：压缩文件，只能将文件压缩为<code>*.gz</code>文件</li>
<li><code>gunzip 文件.gz</code>：解压缩文件命令</li>
</ul>
<p><code>zip/unzip</code>指令</p>
<ul>
<li><p><code>zip [选项] XXX.zip 将要压缩的内容</code>：压缩文件和目录的命令</p>
</li>
<li><p><code>unzip [选项] XXX.zip</code>：解压缩文件</p>
<p>zip常用选项：<code>-r</code>：递归压缩，即压缩目录</p>
<p>unzip常用选项：<code>-d &lt;目录&gt;</code>：指定解压后的文件的存放目录</p>
</li>
</ul>
<p><code>tar</code>指令：打包/解包指令，最后打包的文件是<code>.tar.gz</code>的文件</p>
<ul>
<li><code>tar [选项] XXX.tar.gz 打包的内容</code>：打包目录，压缩后的文件格式<code>.tar.gz</code></li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>产生.tar打包文件</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细信息</td>
</tr>
<tr>
<td>-f</td>
<td>指定压缩后的文件名</td>
</tr>
<tr>
<td>-z</td>
<td>打包同时解压</td>
</tr>
<tr>
<td>-x</td>
<td>解包<code>.tar</code>文件</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux开机、重启和用户登录注销，用户管理</title>
    <url>/2021/07/09/Linux%E5%BC%80%E6%9C%BA%E3%80%81%E9%87%8D%E5%90%AF%E5%92%8C%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%B3%A8%E9%94%80%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86md/</url>
    <content><![CDATA[<h2 id="Linux开机、重启和用户登录注销"><a href="#Linux开机、重启和用户登录注销" class="headerlink" title="Linux开机、重启和用户登录注销"></a>Linux开机、重启和用户登录注销</h2><h3 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h3><p><code>shutdown -h now</code> 立即进行关机</p>
<span id="more"></span>
<p><code>shutdown -h 1</code> 一分钟后关机</p>
<p><code>shutdown -r now</code> 重启计算机</p>
<p><code>halt</code> 关机，作用和上面一样</p>
<p><code>reboot</code> 现在重新启动计算机</p>
<p><code>sync</code> 把内存的数据同步到磁盘</p>
<p>注意：不管是重启系统还是关闭系统，首先要运行SYNC命令，把内存的数据写到磁盘中</p>
<h3 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h3><p><code>su -用户名</code> 切换用户</p>
<p><code>logout</code> 注销用户</p>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>Linux是一个多用户多任务的系统，想要使用系统资源，必须有一个账务</p>
<h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p><code>useradd 用户名</code>   添加一个名为”用户名“的用户，默认该用户的家目录在<code>/home/用户名</code></p>
<p><code>useradd -d  指定目录  新的用户名</code>   在指定目录，创建一个<code>新的用户名</code></p>
<h3 id="指定-修改密码"><a href="#指定-修改密码" class="headerlink" title="指定/修改密码"></a>指定/修改密码</h3><p><code>passwd 用户名</code></p>
<p><code>pwd</code> 显示当前用户所在的目录</p>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><ol>
<li>删除用户，但保留家目录（<code>userdel 用户名</code>）</li>
<li>删除用户以及家目录（<code>userdel -r 用户名</code>）</li>
</ol>
<h3 id="查询用户信息指令"><a href="#查询用户信息指令" class="headerlink" title="查询用户信息指令"></a>查询用户信息指令</h3><p><code>id 用户名</code></p>
<h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p><code>su -要切换的用户名</code></p>
<p>注意：从权限高的用户切换到权限低的用户，不需要密码，反之则需要。当需要返回到原来用户时，使用<code>exit/logout</code>的指令</p>
<h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>系统可以对有共性/权限的多个用户进行统一的管理</p>
<h3 id="新增组"><a href="#新增组" class="headerlink" title="新增组"></a>新增组</h3><p><code>groupadd 组名</code></p>
<h3 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h3><p><code>groupdel 组名</code></p>
<h3 id="增加用户时直接加上组"><a href="#增加用户时直接加上组" class="headerlink" title="增加用户时直接加上组"></a>增加用户时直接加上组</h3><p><code>useradd -g 用户组 用户名</code></p>
<p>注意：如果没有写用户组，那么会新增一个以用户名为名字的用户组，并把新增的用户名加到用户组里</p>
<h3 id="修改用户的组"><a href="#修改用户的组" class="headerlink" title="修改用户的组"></a>修改用户的组</h3><p><code>usermod -g 用户组 用户名</code></p>
<h2 id="用户和组相关的文件"><a href="#用户和组相关的文件" class="headerlink" title="用户和组相关的文件"></a>用户和组相关的文件</h2><ol>
<li><p><code>/etc/passwd</code>文件，用户（user）的配置文件，记录用户的各种信息<br><strong>意义</strong>：<code>用户名:口令:用户标识号:注释行描述:主目录:登录Shell</code></p>
</li>
<li><p><code>/etc/shadow</code>文件，口令的配置文件</p>
<p><strong>意义</strong>：<code>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code>。</p>
</li>
<li><p><code>/etc/group</code>文件，组(group)的配置文件，记录Linux包含的组的信息</p>
<p><strong>意义</strong>：<code>组名:口令:组标识号:组内用户列表</code></p>
</li>
</ol>
<h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><h3 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h3><p>0：关机</p>
<p>1：单用户（找回丢失密码）</p>
<p>2：多用户状态没有网络服务</p>
<p>3：多用户状态有网络服务</p>
<p>4：系统未使用保留给用户</p>
<p>5：图形界面</p>
<p>6：系统重启</p>
<p>注意：常用运行级别是3和5，也可以指定默认运行级别</p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>可以通过查看<code>/etc/inittab</code>文件，得知当前运行级别</p>
<h4 id="切换运行级别"><a href="#切换运行级别" class="headerlink" title="切换运行级别"></a>切换运行级别</h4><p><code>init [级别]</code><br>注意：如果希望一开机就运行指定级别，可以直接修改<code>/etc/inittab</code>文件的级别即可</p>
<h2 id="找回root密码"><a href="#找回root密码" class="headerlink" title="找回root密码"></a>找回root密码</h2><p>首先，重新启动系统，在界面按“e“，进入编辑界面</p>
<p>找到Linux16开头的内容所在行数，在行的最后输入：<code>init=/bin/sh</code></p>
<p>接着，直接按快捷键<code>ctrl+x</code>进入单用户模式</p>
<p>接着，在光标闪烁位置输入：<code>mount -o remount,rw/</code>,然后按下回车键</p>
<p>在新的一行最后面输入：<code>passwd</code>，再次按下回车键，输入密码，然后再次确认密码即可</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>文件目录类</title>
    <url>/2021/07/10/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%B1%BB/</url>
    <content><![CDATA[<p><code>pwd</code> ：显示当前工作目录的绝对路径</p>
<span id="more"></span>
<p><code>ls  [参数]  目录或文件 </code> ：</p>
<ul>
<li> -a：显示当前目录所有的文件或目录，包括隐藏的</li>
<li>  -l：以列表的方式显示信息</li>
</ul>
<p><code>cd 目录</code>： 切换到指定目录</p>
<ul>
<li><code>cd ~</code> 或者 <code>cd </code> 回到自己的家目录</li>
<li><code>cd ..</code>回到当前目录的上一级目录</li>
</ul>
<p><code>mkdir [选项]</code> ：用于创建目录</p>
<ul>
<li><p>-p ：创建多级目录</p>
<p> （<code>mkdir</code>默认创建一级目录，如果想要创建多级目录，必须使用<code>mkdir -p [目录]</code>）</p>
</li>
</ul>
<p><code> rmdir [选项]  要删除的空目录</code></p>
<ul>
<li>注意：<code>rmdir</code>删除的是空目录，如果目录下有内容无法删除，如果需要删除非空目录，需要使用<code>rm -rf [目录]</code></li>
</ul>
<p><code>touch 文件名称</code> ：创建空文件</p>
<p><code>cp [选项] 文件 指定目录</code>：拷贝文件到指定目录</p>
<ul>
<li><p>-r ：递归复制整个文件夹</p>
<p> 注意：如果在复制完成之后对某些文件进行更新，如果需要再次复制，那么系统会提示是否覆盖，输入<code>y/n</code>，如果想要所有更新文件全部覆盖，这可以把命令行的首字母<code>cp</code>替换为输入强制覆盖不提示的：<code>\cp</code></p>
</li>
</ul>
<p><code>rm [选项]  要删除的文件或目录</code></p>
<ul>
<li>-r：递归删除整个文件夹</li>
<li>-f：强制删除不提示</li>
</ul>
<p><code>mv 旧文件名称  新文件名称</code>  （重命名）、        <code>mv 目录下的文件 目录</code>（移动文件）<code>mv 目录 目录</code>（将前目录整体移动到后目录）</p>
<p><code>cat [选项] 要查看的文件 </code>：查看文件内容</p>
<ul>
<li><p>-n：显示行号</p>
</li>
<li><p><code>cat</code>只能浏览文件，而不能修改文件，为了浏览方便，一般会带上 管道命令<code>| more</code></p>
</li>
</ul>
<p><code>more</code>指令：more指令时一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件。more指令中内置了若干快捷键。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>space</td>
<td>代表向下翻一页</td>
</tr>
<tr>
<td>Enter</td>
<td>代表向下翻一行</td>
</tr>
<tr>
<td>q</td>
<td>代表立刻离开more，不再显示该文件内容</td>
</tr>
<tr>
<td>Ctrl+F</td>
<td>向下滚动一屏</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>返回上一屏</td>
</tr>
<tr>
<td>=</td>
<td>输出当前行的行号</td>
</tr>
<tr>
<td>:f</td>
<td>输出文件名和当前行的行号</td>
</tr>
</tbody></table>
<p><code>less</code>指令：less指令用来分屏查看文件内容，它的功能和more指令类似，但是比more指令更加强大，支持各种显示终端，less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>space</td>
<td>向下翻动一页</td>
</tr>
<tr>
<td>[pagedown]</td>
<td>向下翻动一页</td>
</tr>
<tr>
<td>[pageup]</td>
<td>向上翻动一页</td>
</tr>
<tr>
<td>/字串</td>
<td>向下搜寻[字串]的功能；n：向下查找；N：向上查找；</td>
</tr>
<tr>
<td>?字串</td>
<td>向上搜寻[字串]的功能；n：向上查找；N：向下查找；</td>
</tr>
<tr>
<td>q</td>
<td>离开less这个程序</td>
</tr>
</tbody></table>
<p><code>echo [选项] [输出内容]</code>输出内容到控制台</p>
<p><code>head [-n] 文件</code>：用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容，</p>
<ul>
<li>例如：<code>head 文件</code>（显示文件的前10行），<code>head -n 数字 文件</code>（显示“数字”行内容）</li>
</ul>
<p><code>tail</code>指令：</p>
<ul>
<li><code>tail 文件</code>：查看文件尾10行内容</li>
<li><code>tail -n 5 文件</code>：查看文件尾5行内容，5可以是任意数字</li>
<li><code>tail -f 文件</code>：实时追踪该文档的所有更新</li>
</ul>
<p><code>&gt;</code>指令和<code>&gt;&gt;</code>指令：<code>&gt;</code>输出重定向和 &gt;&gt; 追加</p>
<ul>
<li><code>ls -l &gt; 文件</code>：列表的内容写到文件当中（覆盖）</li>
<li><code>ls -al &gt;&gt; 文件</code>：列表的内容追加到文件的末尾</li>
<li><code>cat 文件1 &gt; 文件2</code>：将文件1的内容覆盖到文件2</li>
<li><code>echo &quot;内容&quot;  &gt;&gt;  文件</code></li>
</ul>
<p><code>cal</code>：显示当前日历信息</p>
<p><code>ln</code>指令：软链接也成为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径。</p>
<ul>
<li><code>ln -s [原文件或目录] [软链接名]</code>：给原文件创建一个软链接</li>
</ul>
<p><code>history</code>指令：查看已经执行过历史命令，也可以执行历史命令</p>
<ul>
<li><code>history</code>：查看所有执行过的历史命令</li>
<li><code>history [数字]</code>：查看最近使用过的“数字”个指令</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>时间日期类，搜索查找类</title>
    <url>/2021/07/10/Linux%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BB%EF%BC%8C%E6%90%9C%E7%B4%A2%E6%9F%A5%E6%89%BE%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><p><code>date</code>：显示当前日期</p>
<span id="more"></span>
<ul>
<li><p><code>date</code>：显示当前时间</p>
</li>
<li><p><code>date +%Y</code>：显示当前年份</p>
</li>
<li><p><code>date +%m</code>：显示当前月份</p>
</li>
<li><p><code>date +%d</code>：显示当前哪一天</p>
</li>
<li><p><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>：显示年月日时分秒</p>
</li>
<li><p> <code>date -s 字符串时间</code>：设置系统当前时间</p>
</li>
</ul>
<h2 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h2><p><code>find</code>指令：从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p>
<p><code>find [搜索范围] [选项]</code></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-name &lt;查询方式&gt;</td>
<td>按照指定的文件名查找模式查找文件</td>
</tr>
<tr>
<td>-user &lt;用户名&gt;</td>
<td>查找属于指定用户名所有的文件</td>
</tr>
<tr>
<td>-size &lt;文件大小&gt;</td>
<td>按照指定的文件大小查找文件</td>
</tr>
</tbody></table>
<ul>
<li>例如： <code>find /home -name hello,world.txt</code>(在home目录下搜索文件名为hello,world的文件)。<code>find /home -user ffyzsl</code>（在home目录下搜索属于用户名为ffyzsl的文件）<code>find /home -size +/-200M</code>（在home目录下搜索大小为200M的文件，+200M代表大于200M的文件，-200M代表小于200M的文件，200M代表等于200M的文件）</li>
</ul>
<p><code>locate</code>指令：可以快速定位文件路径，locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。locate指令无需遍历整个文件系统，查询速度较快，为了保证查询结果的准确度，管理员必须定期更新locate时刻。</p>
<ul>
<li><code>locate 搜索文件</code>：由于locate指令基于数据库进行查询，所以第一次运行前，必须使用<code>updatedb</code>指令创建locate数据库。</li>
</ul>
<p><code>grep</code>指令和管道符号：<code>grep</code>过滤查找，管道符<code>|</code>,表示将前一个命令的处理结果输出传递给后面的命令处理。</p>
<ul>
<li><code>grep [选项] 查找内容 源文件</code></li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>显示匹配行及行号</td>
</tr>
<tr>
<td>-i</td>
<td>忽略字母大小写</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux权限</title>
    <url>/2021/07/16/Linux%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><span id="more"></span>

<p>![ls -l示意图](./Linux权限/ls -l示意图.PNG)</p>
<p>显示的内容如下：<code>-rwxrw-r--1 root root  4096 7月   9 15:21 animal </code></p>
<p>第一个root代表所有者，第二个root代表所属组，4096代表文件大小（字节）， 7月 9 15：21代表最后修改日期，animal代表文件名。</p>
<p><strong>0~9位说明：</strong></p>
<p>1、第0位确定文件类型（d,-,l,c,b）</p>
<ul>
<li><code>l</code>是链接</li>
<li><code>d</code>是目录</li>
<li><code>c</code>是字符设备文件，鼠标，键盘</li>
<li><code>b</code>是块设备</li>
<li><code>-</code>是普通文件</li>
</ul>
<p>2、第1~3位确定所有者拥有该文件的权限</p>
<p>3、第4~6位确定所属组拥有该文件的权限</p>
<p>4、第7~9位确定其他用户拥有该文件的权限</p>
<h2 id="rwx权限"><a href="#rwx权限" class="headerlink" title="rwx权限"></a>rwx权限</h2><h3 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a>rwx作用到文件</h3><p>1、<code>r</code>：代表可读（read），读取，查看</p>
<p>2、<code>w</code>：代表可写（write），可以修改文件内容，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在目录有写权限</p>
<p>3、<code>x</code>：代表可执行（execute），可以被执行</p>
<h3 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a>rwx作用到目录</h3><p>1、<code>r</code>：代表可读（read），可以读取，ls查看目录内容</p>
<p>2、<code>w</code>：代表可写（write），可以修改，对目录内创建，删除，重命名目录</p>
<p>3、<code>x</code>：代表可执行（execute），可以进入该目录</p>
<h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><h3 id="修改文件或目录权限"><a href="#修改文件或目录权限" class="headerlink" title="修改文件或目录权限"></a>修改文件或目录权限</h3><p><code>chmod</code>：修改文件或者目录权限</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>所有者权限</th>
<th>所属组权限</th>
<th>其他用户权限</th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td>rwx</td>
<td>rwx</td>
<td>r-x</td>
</tr>
</tbody></table>
<p>u：所有者，g：所有组，o：其他用户，a：所有用户（u，g，o的总和）</p>
<p>第一种方式：+，-，=变更权限</p>
<ul>
<li><code>chmod u=rwx,g=rx,o=x 文件/目录</code></li>
<li><code>chmod o+w 文件/目录</code></li>
<li><code>chmod a-x 文件/目录</code></li>
</ul>
<p>第二种方式：通过数字变更权限，r=4,w=2,x=1</p>
<ul>
<li> <code>chmod u=rwx,g=rwx,o=x 文件/目录</code>相当于<code>chmod 751</code></li>
</ul>
<h3 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h3><p><code>chown</code>：修改文件所有者</p>
<ul>
<li> <code>chown newowner 文件/目录</code>：改变所有者</li>
<li><code>chown newowner:newgroup 文件/目录</code>：改变所有者和所在组</li>
<li><code>-R</code>：如果是目录，则使其下所有者子文件或目录递归生效</li>
</ul>
<h3 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h3><p><code>chgrp</code>：修改文件所在组</p>
<ul>
<li><code>chgrp newgroup 文件/目录</code>：改变所有组</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux概述</title>
    <url>/2021/07/08/Linux%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="Linux入门"><a href="#Linux入门" class="headerlink" title="Linux入门"></a>Linux入门</h1><h2 id="Linux介绍"><a href="#Linux介绍" class="headerlink" title="Linux介绍"></a>Linux介绍</h2><p>1、Linux是一块操作系统（免费、开源、安全、高效、稳定、处理高并发非常强悍）</p>
<span id="more"></span>
<h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p>Linux的文件系统采用级层式的树状目录结构，在此结构上的根目录是<code>/</code>,  <img src="/2021/07/08/Linux%E6%A6%82%E8%BF%B0/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="Linux目录结构"></p>
<h2 id="各个目录介绍"><a href="#各个目录介绍" class="headerlink" title="各个目录介绍"></a>各个目录介绍</h2><ul>
<li><p><strong>/bin</strong>：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p>
</li>
<li><p><strong>/boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
</li>
<li><p><strong>/dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p>
</li>
<li><p><strong>/etc：</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><strong>/home</strong>：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p>
</li>
<li><p><strong>/lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><strong>/media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
<li><p><strong>/opt</strong>：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>/proc</strong>：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure></li>
<li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p><strong>/sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>/selinux</strong>：<br> 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
<li><p><strong>/srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>/sys</strong>：</p>
<p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>/tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><strong>/usr</strong>：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>
</li>
<li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>/usr/src：</strong><br>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p><strong>/run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1、Linux的目录中有且只有一个根目录</p>
<p>2、Linux的各个目录存放的内容是有规定的</p>
<p>3、Linux是以文件的形式来管理设备的（Linux系统中一切皆为文件）</p>
<p>4、了解Linux的各个文件内的内容和作用</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux磁盘和分区</title>
    <url>/2021/07/18/Linux%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>1、Linux归根到底只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分</p>
<span id="more"></span>
<p>2、Linux采用“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来，这时要载入的一个分区将使它的存储空间在一个目录下获得。</p>
<p><img src="/2021/07/18/Linux%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA/Linux%E5%88%86%E5%8C%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<ul>
<li><code>lsblk</code>或者<code>lsblk -k</code>：查看所有设备挂在情况</li>
</ul>
<h3 id="硬盘说明"><a href="#硬盘说明" class="headerlink" title="硬盘说明"></a>硬盘说明</h3><p>1、Linux硬盘分为IDE硬盘和SCSI硬盘，目前基本上使SCSI硬盘</p>
<p>2、对于IDE硬盘，驱动器标识符为<code>“hdx~”</code>，其中<code>“hd”</code>表明分区所在设备的类型，这里是指IDE硬盘了，<code>“x”</code>为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），<code>“~”</code>代表分区，前四个分区用数字1到4表示，他们是主分区或扩展分区，从5开始就是逻辑分区。例如：hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区，hdb2表示第二个IDE硬盘上的第二个主分区或扩展分区。</p>
<p>3、对于SCSI硬盘则标识为<code>“sdx~”</code>，SCSI硬盘是用<code>“sd”</code>来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。</p>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>增加一块硬盘</p>
<ul>
<li>虚拟机添加硬盘</li>
<li>分区</li>
<li>格式化</li>
<li>挂载</li>
<li>设置可以自动挂载</li>
</ul>
<p>1、为虚拟机添加硬盘可以直接在软件里设置。设置后重启，然后使用命令<code>lsblk</code>查看分区情况。</p>
<p><img src="/2021/07/18/Linux%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA/%E6%96%B0%E5%A2%9E%E7%A1%AC%E7%9B%98.png"></p>
<p>此时这块硬盘还未分区。</p>
<p>使用分区命令：<code>fdisk /dev/sdb</code></p>
<ul>
<li><code>m</code>：显示命令列表</li>
<li><code>p</code>：显示磁盘分区 同 <code>fdisk -l</code></li>
<li><code>n</code>：新增分区</li>
<li><code>d</code>：删除分区</li>
<li><code>w</code>：写入并退出</li>
</ul>
<p><img src="/2021/07/18/Linux%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA/%E5%88%86%E5%8C%BA.png"></p>
<p>再使用<code>lsblk</code></p>
<p><img src="/2021/07/18/Linux%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA/%E5%88%86%E5%8C%BA%E5%AE%8C%E6%88%90.png"></p>
<p>然后格式化磁盘：</p>
<p>分区命令：<code>mkfs -t ext4 /dev/sdb2</code>，其中</p>
<p><img src="/2021/07/18/Linux%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA/%E6%A0%BC%E5%BC%8F%E5%8C%96.png"></p>
<p>准备挂载，将其挂载到newdisk目录</p>
<p>挂载：将一个分区与一个目录联系起来</p>
<ul>
<li><code>mount 设备名称  挂载目录</code></li>
</ul>
<p>卸载：取消联系</p>
<ul>
<li><code>umount 设备名称 或者 挂载目录</code></li>
</ul>
<p>首先在根目录创建一个newdisk目录，<code>mkdir newdisk</code></p>
<p>挂载：<code>mount /dev/sdb2 /newdisk</code></p>
<p><img src="/2021/07/18/Linux%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA/%E5%AE%8C%E6%88%90.png"></p>
<p>注意：用命令行挂载，重启后会失效</p>
<p><img src="/2021/07/18/Linux%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA/%E9%87%8D%E5%90%AF%E5%90%8E%E5%A4%B1%E6%95%88.png"></p>
<h2 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h2><p><code>df -h</code>：查询系统整体磁盘使用情况</p>
<p><code>du -h</code>：查询指定目录的磁盘占用情况，默认为当前目录</p>
<ul>
<li><code>-s</code>：指定目录占用大小汇总</li>
<li><code>-h</code>：带计量单位</li>
<li><code>-a</code>：含文件</li>
<li><code>--max-depth=1</code>：子目录深度</li>
<li><code>-c</code>：列出明细的同时，增加汇总值</li>
</ul>
<h2 id="磁盘相关指令"><a href="#磁盘相关指令" class="headerlink" title="磁盘相关指令"></a>磁盘相关指令</h2><p>1、统计/opt文件夹下文件的个数</p>
<p>2、统计/opt文件夹下目录的个数</p>
<p>3、统计/opt文件夹下文件的个数，包括子文件夹里的</p>
<p>4、统计/opt文件夹下目录的个数，包括子文件夹里的</p>
<p>5、以树状显示目录结构</p>
<ul>
<li><code>ls -l /opt | grep &quot;^-&quot; | wc -l</code></li>
<li><code>ls -l /opt | grep &quot;^d&quot; | wc -l</code></li>
<li><code>ls -lR /opt | grep &quot;^-&quot; | wc -l</code></li>
<li><code>ls -lR /opt | grep &quot;^d&quot; | wc -l</code></li>
<li><code>tree /opt</code></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux网络配置</title>
    <url>/2021/07/19/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><span id="more"></span>
<p>原理图：<img src="/2021/07/19/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/NAT%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.png"></p>
<h3 id="查看网络IP和网关"><a href="#查看网络IP和网关" class="headerlink" title="查看网络IP和网关"></a>查看网络IP和网关</h3><p><code>ifconfig</code>：查看网络配置（Linux）</p>
<p><code>ipconfig</code>：查看网络配置（Windows）</p>
<p><code>ping 目的主机</code>：测试当前服务器是否可以连接目的主机</p>
<h3 id="网络环境配置"><a href="#网络环境配置" class="headerlink" title="网络环境配置"></a>网络环境配置</h3><p>第一种：自动获取，登陆后，通过界面来设置自动获取ip，Linux启动后会自动获取ip，但每次自动获取的ip地址可能不一样。</p>
<p><img src="/2021/07/19/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF.png"></p>
<p><img src="/2021/07/19/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96ip%E5%9C%B0%E5%9D%80.png"></p>
<p>第二种方法：指定IP，直接修改配置文件来指定IP，并可以连接到外网。编辑<code>vi  /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<p><img src="/2021/07/19/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"></p>
<p>文件说明：</p>
<ul>
<li><p><code>DEVICE=eth0</code>：接口名（设备：网卡）</p>
</li>
<li><p><code>HWADDR=……</code>：MAC地址</p>
</li>
<li><p><code>TYPE=Ethernet</code>：网络类型（通常是Ethernet）</p>
</li>
<li><p><code>UUID=&quot;be18edbb-aea5-4cd4-9839-c765ced61bf3&quot;</code>(随机id)</p>
</li>
<li><p><code>ONBOOT=&quot;yes&quot;</code>：系统启动时网络接口是否有效</p>
</li>
<li><p>IP的配置方法<code>[none][static][bootp][dhcp]</code>（引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议）</p>
<ul>
<li><code>BOOTPROTO=static</code></li>
<li><code>IPADDR=……</code>：IP地址</li>
<li><code>GATEWAY=……</code>：网关</li>
<li><code>DNS1=……</code>：域名解析器</li>
</ul>
</li>
</ul>
<p>配置完成后，再在虚拟网络编辑器中进行相应的编辑</p>
<h3 id="设置主机名和hosts映射"><a href="#设置主机名和hosts映射" class="headerlink" title="设置主机名和hosts映射"></a>设置主机名和hosts映射</h3><h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><p>1、为了方便记忆，可以给Linux系统设置主机名，也可以根据需求更改主机名</p>
<p>2、指令<code>hostname</code>：查看主机名</p>
<p>3、修改文件在<code>/etc/hostname</code>指定</p>
<p>4、修改后，重启生效</p>
<h4 id="设置hosts映射"><a href="#设置hosts映射" class="headerlink" title="设置hosts映射"></a>设置hosts映射</h4><p>Hosts文件是一个文本文件，用来记录IP和Hostname（主机名）的映射关系。可以通过主机名找到Linux系统。</p>
<ul>
<li> Windows：在<code>C:\Windows\System32\drivers\etc\hosts</code>文件指定即可</li>
<li>Linux：在<code>/etc/hosts</code>文件指定</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux进程管理</title>
    <url>/2021/07/22/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>在Linux中，每个执行的程序都称为一个进程，每一个进程都分配一个ID号（pid，进程号）</p>
<span id="more"></span>
<p>每个进程都可能以两种方式存在，前台与后台，所谓前台进程就是用户目前在屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</p>
<p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才结束。</p>
<h3 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h3><p><code>ps</code>命令是用来查看目前系统中，有哪些正在执行，以及他们执行的状况，可以不加任何参数。</p>
<p><img src="/2021/07/22/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/ps%E6%8C%87%E4%BB%A4.png"></p>
<ul>
<li><code>PID</code>：进程识别号</li>
<li><code>TTY</code>：终端机号</li>
<li><code>TIME</code>：此进程所消CPU时间</li>
<li><code>CMD</code>：正在执行的命令或进程名</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ps -a</td>
<td>显示当前终端的所有进程信息</td>
</tr>
<tr>
<td>ps -u</td>
<td>以用户的格式显示进程信息</td>
</tr>
<tr>
<td>ps -x</td>
<td>显示后台进程运行的参数</td>
</tr>
</tbody></table>
<p><img src="/2021/07/22/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/ps-aux%E6%8C%87%E4%BB%A4.png"></p>
<ul>
<li><code>USER</code>：进程执行用户</li>
<li><code>PID</code>：进程识别号</li>
<li><code>CPU</code>：占用CPU的百分比</li>
<li><code>MEM</code>：占用物理内存的百分比</li>
<li><code>VSZ</code>：占用虚拟内存的百分比</li>
<li><code>RSS</code>：实际分配给进程使用的物理内存</li>
<li><code>TTY</code>：终端机号</li>
<li><code>STAT</code>：当前进程的运行状态（<code>S</code>代表睡眠，<code>s-</code>表示该进程是会话的先导进程，<code>N</code>代表进程拥有比普通优先级更低的优先级，<code>R</code>代表正在运行，<code>D</code>代表短期等待，<code>Z</code>代表僵死进程，<code>T</code>代表被跟踪或者被停止等等）</li>
<li><code>START</code>：进程开始时间</li>
<li><code>TIME</code>：此进程所消CPU时间</li>
<li><code>COMMAND</code>：启动进程所用的命令和参数，如果过长会被截取显示</li>
</ul>
<h3 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h3><p>例如：以全格式显示当前所有进程，查看进程的父进程。</p>
<ul>
<li><code>ps -ef</code>是以全格式显示当前所有的进程<ul>
<li><code>-e</code>显示所有进PS程</li>
<li><code>-f</code>全格式</li>
</ul>
</li>
<li><code>ps -ef | grep xxx</code>是BSD风格.例如：查看<code>sshd</code>的父进程：<code>pe -ef | grep sshd</code><ul>
<li><img src="/2021/07/22/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%9F%A5%E7%9C%8B%E7%88%B6%E8%BF%9B%E7%A8%8B.png"></li>
<li>它的父进程的PID为1</li>
</ul>
</li>
<li><code>PPID</code>：父进程ID</li>
</ul>
<h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>若是某个进程执行一半需要停止时，或是已经消耗很大的系统资源时，此时可以考虑停止该进程，使用<code>kill</code>命令来完成此行任务。</p>
<ul>
<li><p><code>kill [选项] 进程号</code>：通过进程号杀死进程</p>
<ul>
<li>选项：<code>-9</code>:表示强迫进程立即停止</li>
</ul>
</li>
<li><p><code>killall [选项] 进程名称</code>：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用，用<code>killall</code>杀掉一个进程，其所有的子进程也会被杀死</p>
<ul>
<li><p>-Z 只杀死拥有scontext 的进程</p>
</li>
<li><p>-e 要求匹配进程名称</p>
</li>
<li><p>-I 忽略小写</p>
</li>
<li><p>-g 杀死进程组而不是进程</p>
</li>
<li><p>-i 交互模式，杀死进程前先询问用户</p>
</li>
<li><p>-l 列出所有的已知信号名称</p>
</li>
<li><p>-q 不输出警告信息</p>
</li>
<li><p>-s 发送指定的信号</p>
</li>
<li><p>-v 报告信号是否成功发送</p>
</li>
<li><p>-w 等待进程死亡</p>
</li>
<li><p>-help 显示帮助信息</p>
</li>
<li><p>-version 显示版本显示</p>
</li>
</ul>
</li>
</ul>
<h3 id="查看进程树"><a href="#查看进程树" class="headerlink" title="查看进程树"></a>查看进程树</h3><p><code>pstree [选项]</code>：可以更加直观的来看进程信息</p>
<ul>
<li><code>-p</code>：显示进程的PID</li>
<li><code>-u</code>：显示是进程的所属用户</li>
</ul>
<h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>服务(service)本质就是进程，但是是运行在后台的，通常会监听某个端口，等待其他程序的请求，比如（mysql，sshd，防火墙等），因此我们又称为守护进程。</p>
<ul>
<li><p><code>service 服务名 [start|stop|restart|reload|status]</code></p>
</li>
<li><p>在CentOS7.0后 ，很多服务不再使用<code>service</code>，而是<code>systemctl</code></p>
</li>
<li><p><code>service</code>指令管理的服务在<code>/etc/init.d</code>查看</p>
</li>
<li><p><img src="/2021/07/22/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%8C%87%E4%BB%A4%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1.png"></p>
</li>
</ul>
<h4 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h4><p>方式一：使用<code>setup -&gt; 系统服务</code>，就可以看到<strong>全部</strong></p>
<p>方式二：<code>/etc/init.d</code>看到service指令管理的服务</p>
<h4 id="服务的运行级别（runlevel）"><a href="#服务的运行级别（runlevel）" class="headerlink" title="服务的运行级别（runlevel）"></a>服务的运行级别（runlevel）</h4><p>Linux系统有7种运行级别（runlevel）：常用的级别3和5</p>
<ul>
<li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li>
<li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li>
<li>运行级别2：多用户状态（没有NFS），不支持网络</li>
<li>运行级别3：完全的多用户状态（有NFS），登陆后进入控制台命令行模式</li>
<li>运行级别4：系统未使用，保留</li>
<li>运行级别5：X11控制台，登陆后进入图形GUI模式</li>
<li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li>
</ul>
<p><img src="/2021/07/22/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B.png"></p>
<p><strong>如何设置</strong>：在<code>/etc/initab</code>如下： </p>
<ul>
<li><code>multi-user.target: analogous to runlevel 3</code></li>
<li><code>graphical.target: analogous to runlevel 5</code></li>
</ul>
<p><code>systemctl get-default</code>：获取当前运行级别</p>
<p><code>systemctl set-default xxx.target</code>:设置运行级别</p>
<p><code>chkconfig</code>指令：</p>
<ul>
<li>通过<code>chkconfig</code>命令可以给服务的各个运行级别设置自 启动/关闭</li>
<li><code>chkconfig</code>指令管理的服务在<code>/etc/init.d</code>查看</li>
<li>注意：在CentOS7.0之后，很多服务使用<code>systemctl</code>管理</li>
</ul>
<p>基本语法：</p>
<ul>
<li><code>chkconfig --list [| grep xxx]</code>：查看服务</li>
<li><code>chkconfig 服务名 --list</code></li>
<li><code>chkconfig --level 5 服务名 on/off</code>（例如：对network服务进行各种操作，把network在3运行级别，关闭自启动，<code>chkconfig --level 3 network off/on</code>）</li>
</ul>
<p><code>systemctl</code>管理指令</p>
<ul>
<li><code>systemctl [start | stop | restart | status] 服务名</code></li>
<li><code>systemctl</code>指令管理的服务在<code>/usr/lib/systemd/system</code>查看</li>
</ul>
<p><code>systemctl</code>设置服务的自启动状态</p>
<ul>
<li><code>systemctl list-unit-files [ | grep 服务名]</code>：查看服务开机启动状态，grep可以进行过滤</li>
<li><code>systemctl enable 服务名</code>：设置服务开机启动</li>
<li><code>systemctl disable 服务名</code>：关闭服务开机启动</li>
<li><code>systemctl is-enabled 服务名</code>：查询某个服务是否自启动的</li>
</ul>
<p><code>firewall</code>指令</p>
<ul>
<li><code>firewall-cmd --permanent --add-port=端口号/协议</code>：打开端口</li>
<li><code>firewall-cmd --permanent --remove-port=端口号/协议</code>：关闭端口</li>
<li><code>firewall-cmd --reload</code>：重新载入，才能生效</li>
<li><code>firewall-cmd --query-port=端口/协议</code>：查询端口是否开放</li>
</ul>
<h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p>top和ps命令很相似，它们都用来显示正在执行的进程。top和ps最大的不同之处，在于top在执行一段时间可以更新正在运行的进程。</p>
<p><code>top [选项]</code></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-d 秒数</td>
<td>指定top命令每隔几秒更新，默认是3秒</td>
</tr>
<tr>
<td>-i</td>
<td>使top不显示任何闲置或者僵死进程</td>
</tr>
<tr>
<td>-p</td>
<td>通过指定监控进程ID来仅仅监控某个进程的状态</td>
</tr>
</tbody></table>
<p><img src="/2021/07/22/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/top%E6%8C%87%E4%BB%A4.png"></p>
<p>其默认每隔3秒刷新一次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top - 08:45:08 up 4 min,  2 users,  load average: 0.16, 0.37, 0.20</span><br><span class="line">Tasks: 172 total,   1 running, 171 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.2 us,  0.8 sy,  0.0 ni, 97.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1867048 total,   170308 free,   743660 used,   953080 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2097148 free,        0 used.   910692 avail Mem </span><br></pre></td></tr></table></figure>

<p><strong>交互操作说明</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>以CPU使用率排序，默认就是此项</td>
</tr>
<tr>
<td>M</td>
<td>以内存的使用率排序</td>
</tr>
<tr>
<td>N</td>
<td>以PID排序</td>
</tr>
<tr>
<td>q</td>
<td>退出top</td>
</tr>
</tbody></table>
<p><strong>监控指定用户</strong>：</p>
<ul>
<li><code>top</code>：输入此命令，按回车键，查看执行的进程</li>
<li><code>u</code>：然后输入“u”回车，再输入用户名</li>
</ul>
<p><strong>终止指定进程</strong></p>
<ul>
<li><code>top</code>:输入此命令，按回车键，查看执行的进程</li>
<li><code>k</code>：然后输入“k”回车，再输入要结束的进程ID号</li>
</ul>
<h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><p><code>netstat</code>：查看网络情况</p>
<ul>
<li><code>netstat [选项]</code></li>
</ul>
<p>选项：</p>
<ul>
<li><code>-an</code>：按一定顺序排列输出</li>
<li><code>-p</code>：显示哪个进程在调用</li>
</ul>
<p><strong>检测主机连接命令ping</strong>：一种网络检测工具，它主要是用检测远程主机是否正常，或是两部主机间的网线或网卡故障</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux远程登录，vi及vim使用说明</title>
    <url>/2021/07/08/Linux%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%EF%BC%8Cvi%E5%8F%8Avim%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="远程登录到Linux"><a href="#远程登录到Linux" class="headerlink" title="远程登录到Linux"></a>远程登录到Linux</h2><p>1、Linux服务器是共享的</p>
<p>2、程序员需要远程登录到Linux进行项目管理或开发</p>
<span id="more"></span>
<p>3、Linux一般搭建在公网</p>
<p>4、Xshell是目前最好的远程登录到Linux操作的软件，传输文件则使用Xftp</p>
<h3 id="下载、安装和配置"><a href="#下载、安装和配置" class="headerlink" title="下载、安装和配置"></a>下载、安装和配置</h3><p><a href="https://www.bilibili.com/video/BV1Sv411r7vd?p=15&amp;share_source=copy_web">https://www.bilibili.com/video/BV1Sv411r7vd?p=15&amp;share_source=copy_web</a> （P14、P15）</p>
<h2 id="vi和vim的基本介绍"><a href="#vi和vim的基本介绍" class="headerlink" title="vi和vim的基本介绍"></a>vi和vim的基本介绍</h2><p>Linux系统会内置vi文本编辑器</p>
<p>Vim具有程序编辑的能力，可以看做是vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计，代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用</p>
<h3 id="vi和vim常用的三种模式"><a href="#vi和vim常用的三种模式" class="headerlink" title="vi和vim常用的三种模式"></a>vi和vim常用的三种模式</h3><ol>
<li>正常模式（命令模式）</li>
<li>插入模式（输入模式）</li>
<li>命令行模式（底线命令模式）（输入<code>:</code>)(wq：表示写入和退出)</li>
</ol>
<p><img src="/2021/07/08/Linux%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%EF%BC%8Cvi%E5%8F%8Avim%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/vi%E5%92%8Cvim%E5%90%84%E4%B8%AA%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2.png" alt="vi和vim各个模式之间如何切换"></p>
<p><img src="/2021/07/08/Linux%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%EF%BC%8Cvi%E5%8F%8Avim%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/vi_and_vim%E9%94%AE%E7%9B%98%E5%9B%BEsch.png" alt="vi_and_vim键盘图"></p>
<h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><p>（默认）、<code>i</code>切换到输入模式，<code>x</code>删除当前光标所在处的字符，<code>:</code>切换到底线命令模式</p>
<h3 id="输入模式："><a href="#输入模式：" class="headerlink" title="输入模式："></a>输入模式：</h3><ol>
<li><code>字符按键以及shift组合</code>，输入字符</li>
<li><code>enter</code>，回车键，换行</li>
<li><code>back space</code>，退格键，删除光标前一个字符</li>
<li><code>del</code>，删除键，删除光标后一个字符</li>
<li><code>方向键</code>，在文本中移动光标</li>
<li><code>home/end</code>，移动光标到行首/行尾</li>
<li><code>page up/page down</code>，上下翻页</li>
<li><code>insert</code>，切换光标为输入/替换模式，光标将变为竖线/下划线</li>
<li><code>esc</code>，退出输入模式，切换到命令模式</li>
</ol>
<h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按下<code>:</code>，就进入了底线命令模式</p>
<p>基本命令：</p>
<ol>
<li><code>q</code>:退出程序</li>
<li><code>w</code>:保存文件</li>
</ol>
<h2 id="vi-vim使用实例（常用命令）"><a href="#vi-vim使用实例（常用命令）" class="headerlink" title="vi/vim使用实例（常用命令）"></a>vi/vim使用实例（常用命令）</h2><p>创建一个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim 文件名</span><br></pre></td></tr></table></figure>

<p>拷贝当前行 <code>yy</code>,拷贝当前行向下的n行，<code>nyy</code>,粘贴<code>p</code></p>
<p>删除当前行<code>dd</code>,删除当前行向下n行<code>ndd</code></p>
<p>在文件中查找某个单词，<code>命令行下/关键字，回车 查找，输入n就是查找下一个</code></p>
<p>设置文件的行号，取消文件的行号<code>命令行下  :set nu 和 :set nonu</code></p>
<p>撤销 <code>u</code></p>
<p>定位到最末行<code>G</code>，定位到首行<code>gg</code>，定位到固定的行号 <code>行号 shift+g</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Maven简介，POM及生命周期</title>
    <url>/2021/08/05/Maven%E7%AE%80%E4%BB%8B%EF%BC%8CPOM%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><p>Maven项目对象模型（POM），可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。</p>
<span id="more"></span>
<p>在构建一个项目时，需要用到大量的jar包，在以往的开发项目时，程序员往往需要花费大量精力在配置环境上，而且非常容易出错。而Maven就是帮助程序员构建项目的工具。</p>
<p><strong>核心思想</strong>：约定大于配置</p>
<h3 id="maven规定的目录结构"><a href="#maven规定的目录结构" class="headerlink" title="maven规定的目录结构"></a>maven规定的目录结构</h3><p><img src="/2021/08/05/Maven%E7%AE%80%E4%BB%8B%EF%BC%8CPOM%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/maven%E8%A7%84%E5%AE%9A%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png"></p>
<h3 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h3><p>在maven中，任何一个依赖，插件或者项目构建的输出，都可以称为构件。</p>
<p>Maven在某个统一的位置存储所有项目的共享的构件，这个统一的位置，称之为仓库（就是存储依赖和插件的地方）。</p>
<p><img src="/2021/08/05/Maven%E7%AE%80%E4%BB%8B%EF%BC%8CPOM%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/maven%E4%BB%93%E5%BA%93%E7%BB%93%E6%9E%84.png"></p>
<p><strong>本地仓库</strong>：Maven本地的jar包仓库</p>
<p><strong>远程仓库</strong>：Maven官方提供的远程仓库</p>
<p>当项目编译时，Maven首先从本地仓库中寻找项目所需的jar包，若本地仓库没有，再到Maven的中央仓库下载所需jar包。</p>
<h3 id="约定配置"><a href="#约定配置" class="headerlink" title="约定配置"></a>约定配置</h3><table>
<thead>
<tr>
<th align="left">目录</th>
<th align="left">目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">${basedir}</td>
<td align="left">存放pom.xml和所有的子目录</td>
</tr>
<tr>
<td align="left">${basedir}/src/main/java</td>
<td align="left">项目的java源代码</td>
</tr>
<tr>
<td align="left">${basedir}/src/main/resources</td>
<td align="left">项目的资源，比如说property文件，springmvc.xml</td>
</tr>
<tr>
<td align="left">${basedir}/src/test/java</td>
<td align="left">项目的测试类，比如说Junit代码</td>
</tr>
<tr>
<td align="left">${basedir}/src/test/resources</td>
<td align="left">测试用的资源</td>
</tr>
<tr>
<td align="left">${basedir}/src/main/webapp/WEB-INF</td>
<td align="left">web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面</td>
</tr>
<tr>
<td align="left">${basedir}/target</td>
<td align="left">打包输出目录</td>
</tr>
<tr>
<td align="left">${basedir}/target/classes</td>
<td align="left">编译输出目录</td>
</tr>
<tr>
<td align="left">${basedir}/target/test-classes</td>
<td align="left">测试编译输出目录</td>
</tr>
<tr>
<td align="left">Test.java</td>
<td align="left">Maven只会自动运行符合该命名规则的测试类</td>
</tr>
<tr>
<td align="left">~/.m2/repository</td>
<td align="left">Maven默认的本地仓库目录位置</td>
</tr>
</tbody></table>
<h2 id="Maven-POM"><a href="#Maven-POM" class="headerlink" title="Maven POM"></a>Maven POM</h2><p>POM（项目对象模型）是Maven工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p>
<p>执行任务或目标时，Maven会在当前目录查找POM，读取POM，获取所需的配置信息，然后执行目标，在POM中可以指定以下配置。</p>
<ul>
<li>项目依赖</li>
<li>插件</li>
<li>执行目标</li>
<li>项目构建</li>
<li>项目版本</li>
<li>项目开发者列表</li>
<li>相关邮件列表信息</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span> = <span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span> = <span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span> = <span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 公司或者组织的唯一标志，也是打包成jar包路径的依据 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 例如com.companyname.project-group，maven打包jar包的路径：/com/companyname/project-group --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--项目产生的构件类型，包括jar、war、ear、pom等 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>节点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>project</td>
<td>工程的根标签</td>
</tr>
<tr>
<td>modelVersion</td>
<td>模型版本需要设置为4.0</td>
</tr>
<tr>
<td>groupld</td>
<td>这是工程组的标识，它在一个组织或者项目中通常是唯一的</td>
</tr>
<tr>
<td>artifactId</td>
<td>这是工程的标识，它通常是工程的名称</td>
</tr>
<tr>
<td>version</td>
<td>这是工程的版本号。</td>
</tr>
<tr>
<td>packaging</td>
<td>这是项目产生的构件类型，即项目通过maven打包的输出文件的后缀名，包括jar，war，ear，pom等。</td>
</tr>
</tbody></table>
<h3 id="传递依赖和排除依赖"><a href="#传递依赖和排除依赖" class="headerlink" title="传递依赖和排除依赖"></a>传递依赖和排除依赖</h3><p><strong>传递依赖</strong>：如果引用了一个jar包，而这个jar包又引用了其他的jar包，那么在默认情况下，Maven会把直接引用或间接引用的jar包都下载到本地</p>
<p><strong>排除依赖</strong>：在引用jar包时，使用<code>&lt;exclusions&gt;</code>排除相关的jar包</p>
<p>单依赖过滤</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.94.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>     </span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        </span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>多依赖过滤</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.94.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">本项目--&gt;A.jar--&gt;B.jar--&gt;X.jar</span><br><span class="line">本项目--&gt;C.jar--&gt;X.jar</span><br></pre></td></tr></table></figure>

<p>若本项目引用了A.jar，A.jar又引用了B.jar。B.jar又引用了X.jar，并且C.jar也引用了X.jar。在此时，Maven只会引用引用路径最短的jar。如果引用路径相同，则谁先被声明，就使用谁。</p>
<p>直接依赖优先于传递依赖，如果传递依赖的jar包版本冲突了，那么可以自己声明一个指定版本的依赖jar，即可解决冲突。</p>
<h3 id="父项目和parent元素"><a href="#父项目和parent元素" class="headerlink" title="父项目和parent元素"></a>父项目和parent元素</h3><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>将多个项目同时运行就称为聚合</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-connection-pool<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-java-web<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在聚合多个项目时，如果这些聚合的项目中需要引入相同的jar，那么可以将这些jar写入父pom中，各个子项目继承该pom即可</p>
<p><strong>父pom配置</strong>：将需要继承的jar包的坐标放入标签即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>子pom配置</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>父pom所在项目的groupld<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>父pom所在项目的artifactld<span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>父pom所在项目的版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--父项目的坐标，坐标包括group ID，artifact ID和version。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--被继承的父项目的构件标识符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--被继承的父项目的全球唯一标识符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>base-project<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--被继承的父项目的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径,默认值是../pom.xml。 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 寻找父项目的pom：构建当前项目的地方--)relativePath指定的位置--)本地仓库--)远程仓库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><h3 id="概念与意义"><a href="#概念与意义" class="headerlink" title="概念与意义"></a>概念与意义</h3><p>Maven的生命周期就是对所有的构建过程进行抽象和统一，包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有的构建步骤。</p>
<p>Maven默认的生命周期包括预编译、编译、编译测试类、构建、部署这些阶段。这里的每一个阶段都只是提供了一个扩展点，只是抽象出来的，没有具体实现的。</p>
<h3 id="三套生命周期"><a href="#三套生命周期" class="headerlink" title="三套生命周期"></a>三套生命周期</h3><p>Maven有三套相互独立的生命周期，分别是clean，default和site</p>
<ul>
<li><p>clean：清理生命周期，用于清理项目</p>
<ul>
<li>pre-clean：执行清理前需要完成的工作</li>
<li>clean：清理行一次构建生成的文件</li>
<li>post-clean：执行清理后需要完成的工作</li>
</ul>
</li>
<li><p>default：默认生命周期，用于编译、打包、测试、部署等</p>
<table>
<thead>
<tr>
<th>alidate</th>
<th>验证项目结构是否正常，必要的配置文件是否存在</th>
</tr>
</thead>
<tbody><tr>
<td>initialize</td>
<td>做构建前的初始化操作，比如初始化参数、创建必要的目录等</td>
</tr>
<tr>
<td>generate-sources</td>
<td>产生在编译过程中需要的源代码</td>
</tr>
<tr>
<td>process-sources</td>
<td>处理源代码，比如过滤值</td>
</tr>
<tr>
<td><strong>generate-resources</strong></td>
<td>产生主代码中的资源在 classpath 中的包</td>
</tr>
<tr>
<td><strong>process-resources</strong></td>
<td>将资源文件复制到 classpath 的对应包中</td>
</tr>
<tr>
<td><strong>compile</strong></td>
<td>编译项目中的源代码</td>
</tr>
<tr>
<td>process-classes</td>
<td>产生编译过程中生成的文件</td>
</tr>
<tr>
<td>generate-test-sources</td>
<td>产生编译过程中测试相关的代码</td>
</tr>
<tr>
<td>process-test-sources</td>
<td>处理测试代码</td>
</tr>
<tr>
<td><strong>generate-test-resources</strong></td>
<td>产生测试中资源在 classpath 中的包</td>
</tr>
<tr>
<td><strong>process-test-resources</strong></td>
<td>将测试资源复制到 classpath 中</td>
</tr>
<tr>
<td><strong>test-compile</strong></td>
<td>编译测试代码</td>
</tr>
<tr>
<td>process-test-classes</td>
<td>产生编译测试代码过程的文件</td>
</tr>
<tr>
<td><strong>test</strong></td>
<td>运行测试案例</td>
</tr>
<tr>
<td>prepare-package</td>
<td>处理打包前需要初始化的准备工作</td>
</tr>
<tr>
<td>package</td>
<td>将编译后的 class 和资源打包成压缩文件，比如 rar</td>
</tr>
<tr>
<td>pre-integration-test</td>
<td>做好集成测试前的准备工作，比如集成环境的参数设置</td>
</tr>
<tr>
<td>integration-test</td>
<td>集成测试</td>
</tr>
<tr>
<td>post-integration-test</td>
<td>完成集成测试后的收尾工作，比如清理集成环境的值</td>
</tr>
<tr>
<td>verify</td>
<td>检测测试后的包是否完好</td>
</tr>
<tr>
<td><strong>install</strong></td>
<td>将打包的组件以构件的形式，安装到本地依赖仓库中，以便共享给本地的其他项目</td>
</tr>
<tr>
<td><strong>deploy</strong></td>
<td>运行集成和发布环境，将测试后的最终包以构件的方式发布到远程仓库中，方便所有程序员共享</td>
</tr>
</tbody></table>
</li>
<li><p>site：站点文档生成，用于构建站点文档。</p>
<ul>
<li>pre-site：生成项目站点之前需要完成的工作</li>
<li>site：生成项目站点文档</li>
<li>post-site：生成项目站点之后需要完成的工作</li>
<li>site-deploy：将项目站点发布到服务器</li>
</ul>
</li>
</ul>
<p>三大生命周期相互独立，一个生命周期的阶段前后依赖。</p>
<h3 id="调用生命周期阶段"><a href="#调用生命周期阶段" class="headerlink" title="调用生命周期阶段"></a>调用生命周期阶段</h3><p>有两种方式可以同 Maven 进行交互，一种是用 mvn 命令；另一种是在 M2Eclipse 中，使用对应的 Run As 菜单命令。</p>
<p><strong>1、mvn命令行指定执行周期阶段</strong></p>
<p>这种方式都是在cmd命令行窗口中执行的，前提条件时配置号安装的Maven环境变量（Path），并且将当前目录切换到Maven工程目录下。</p>
<p>例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mvn cleanmvn testmvn clean install</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>SQL概要，表的创建、删除、更新</title>
    <url>/2021/07/05/SQL%E6%A6%82%E8%A6%81/</url>
    <content><![CDATA[<h2 id="SQL概要"><a href="#SQL概要" class="headerlink" title="SQL概要"></a>SQL概要</h2><p>SQL用关键字、表明、列名等组合而成的一条语句来描述操作的内容。</p>
<span id="more"></span>
<p><strong>DDL(Data Definition Language，数据定义语言)</strong><br>            CREATE：创建数据库和表等对象<br>            DROP：删除数据库和表等对象<br>            ALTER：修改数据库和表等对象的结构</p>
<p><strong>DML(Data Manipulation Language，数据操作语言)</strong><br>             SELECT：查询表中的数据<br>             INSERT：向表中插入新的数据<br>             UPDATE：更新表中的数据<br>             DELETE：删除表中的数据</p>
<p><strong>DCL(Data Control Language，数据控制语言)</strong><br>            COMMIT：确认对数据库中的数据进行的变更<br>            ROLLBACK：取消对数据库中的数据进行的变更<br>            GRANT：赋予用户操作权限<br>            REVOKE：取消用户的操作权限</p>
<h3 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h3><p>1、SQL语句要以分号结尾</p>
<p>2、SQL语句不区分大小写</p>
<p>3、常数的书写方式是固定的</p>
<p>4、单词需要用半角空格或者换行来分隔</p>
<h2 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h2><h3 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h3><p><code>CREATE DATABASE &lt;数据库名称&gt;;</code></p>
<p>在创建表之前，一定要先创建用来存储表的数据库。</p>
<h3 id="表的创建-1"><a href="#表的创建-1" class="headerlink" title="表的创建"></a>表的创建</h3><p><code>CREATE TABLE &lt;表名&gt; (&lt;列名1&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;,&lt;列名2&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;,&lt;列名3&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;,……)</code></p>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>只能使用半角英文字母、数字、下划线作为数据库、表和列的名称。名称必须以半角英文字母作为开头。名称不能重复</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>INTEGER型：用来指定存储整数的列的数据类型（数字型），不能存储小数</p>
<p>CHAR型：为CHARACTER（字符）的缩写，用来指定存储字符串的列的数据类型（字符型）。可以用CHAR(10)或CHAR(10)指定该列可以存储的字符串的长度（最大长度）。字符串以<code>定长字符串</code>的形式存储在被指定的CHAR型的列中，所谓定长字符串，就是当列中存储的字符串长度达不到最大长度时，用半角空格补足。</p>
<p>VARCHAR型：同CHAR类型一样，其可以指定存储字符串的列的数据类型（字符串类型），也可以通过括号内的数字来指定字符串的长度（最大长度）。该类型的列时以<code>可变长字符串</code>的形式来保存字符串的。其存储的字符串未达到最大长度时，不会使用半角空格补足。</p>
<p>DATE型：用来指定存储日期（年月日）的列的数据类型（日期型）</p>
<h2 id="约束的设置"><a href="#约束的设置" class="headerlink" title="约束的设置"></a>约束的设置</h2><p><code>约束</code>是除了数据类型之外，对列中存储的数据进行限制或者追加条件的功能。</p>
<p>如<code>product_id CHAR(4) NOT NULL,product_name VARCHAR(100)</code>其中，数据类型右侧设置了NOT NULL约束。NULL是空白（无记录）的关键字。所以该列设置了不能输入空白，必须输入数据的约束。</p>
<p>如<code>PRIMARY KEY(product_id)</code>，其设置主键约束的，表示此列的数据必须唯一。</p>
<h2 id="表的删除和更新"><a href="#表的删除和更新" class="headerlink" title="表的删除和更新"></a>表的删除和更新</h2><h3 id="表的删除"><a href="#表的删除" class="headerlink" title="表的删除"></a>表的删除</h3><p><code>DROP TABLE &lt;表名&gt;;</code></p>
<p>注意：已经删除的表是无法恢复的！</p>
<h3 id="表定义的更新"><a href="#表定义的更新" class="headerlink" title="表定义的更新"></a>表定义的更新</h3><h4 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h4><p><code>ALTER TABLE &lt;表名&gt; ADD COLUMN &lt;列的定义&gt;;</code></p>
<h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><p><code>ALTER TBALE &lt;表名&gt; DROP COLUMN &lt;列名&gt;;</code></p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p><code>INSERT INTO &lt;表名&gt; VALUES (列1,列2,……);</code></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>构造方法、参数传递</title>
    <url>/2021/07/02/day-eigth/</url>
    <content><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><strong>1、创建对象</strong></p>
<p><strong>2、创建对象时，初始化实例变量的内存空间。（给实例变量赋值）</strong></p>
<span id="more"></span>

<p>按住Ctrl，鼠标移动到查看的元素上，则可以追踪。</p>
<p> Crtl+F12   快速查看，</p>
<p>注：成员变量之实例变量，属于对象级别的变量，必须先有对象才能有实例变量，实例变量没有手动赋值时，系统默认赋值，其内存空间是在构造方法执行过程当中完成开辟的，完成初始化，也是在这时候开始赋值。而在类加载时，实例对象并没有初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String actno;<span class="comment">//实例变量，必须先有对象才能有对应的实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参数构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化实例变量的内存空间</span></span><br><span class="line">        <span class="comment">//actno=null;</span></span><br><span class="line">        <span class="comment">//balance=0.0; </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        actno=s;</span><br><span class="line">        <span class="comment">//blance=0.0;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123;</span><br><span class="line">        balance=d;</span><br><span class="line">        <span class="comment">//actno=null;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        actno=a;</span><br><span class="line">        balance=b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getActno</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> actno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActno</span><span class="params">(String actno)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actno = actno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象1</span></span><br><span class="line">        Account act1=<span class="keyword">new</span> Account();</span><br><span class="line">        System.out.println(act1.getActno());</span><br><span class="line">        System.out.println(act1.getBalance());</span><br><span class="line">        <span class="comment">//创建对象2</span></span><br><span class="line">        Account act2=<span class="keyword">new</span> Account(<span class="string">&quot;110&quot;</span>);</span><br><span class="line">        System.out.println(act2.getActno());</span><br><span class="line">        System.out.println(act2.getBalance());</span><br><span class="line">        <span class="comment">//创建对象3</span></span><br><span class="line">        Account act3=<span class="keyword">new</span> Account(<span class="number">25.2</span>);</span><br><span class="line">        System.out.println(act3.getActno());</span><br><span class="line">        System.out.println(act3.getBalance());</span><br><span class="line">        <span class="comment">//创建对象4</span></span><br><span class="line">        Account act4=<span class="keyword">new</span> Account(<span class="string">&quot;act4-004&quot;</span>,<span class="number">2500.23</span>);</span><br><span class="line">        System.out.println(act4.getActno());</span><br><span class="line">        System.out.println(act4.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">110</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line">act4-<span class="number">004</span></span><br><span class="line"><span class="number">2500.23</span></span><br></pre></td></tr></table></figure>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">parameter01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">10</span>;<span class="comment">//为局部变量，传递时只传值</span></span><br><span class="line">        parameter01.add(i);</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">&quot;add--&gt;&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add--&gt;<span class="number">11</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>值传递：在调用的方法中重新开辟一块新的空间，这块空间中存放着调用的参数的值，但这个值无论发生什么变化，都不会涉及到调用他的方法中的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u=<span class="keyword">new</span> User(<span class="number">20</span>);</span><br><span class="line">        add(u);</span><br><span class="line">        System.out.println(<span class="string">&quot;main--&gt;&quot;</span>+u.age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User u)</span></span>&#123;</span><br><span class="line">        u.age++;</span><br><span class="line">        System.out.println(<span class="string">&quot;add--&gt;&quot;</span>+u.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">            age=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>

<p> 址传递：所调用的是一个存放着对象内存地址的变量，在所调用它的方法中，新开辟的空间的内存同样指向对象，他们所指向的对象是同一个对象，所以所做的任何修改，都会改变其值。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>1、this是一个关键字，翻译为“这个”</p>
<p>2、this是一个引用，this是一个变量，this变量中保存了内存地址指向自身，this存储在JVM堆内存java对象内部</p>
<p>3、创建多少个对象，则有多少个this对象。</p>
<p>注：<strong>当使用c1去访问对象的话，整个过程中出现的this就是c1</strong></p>
<pre><code>   **当使用c2去访问对象的话，整个过程中出现的this就是c2**
</code></pre>
<p>4、没有static关键字的方法被称为“实例方法”</p>
<pre><code>  没有static关键字的方法被称为“实例变量&quot;
</code></pre>
<p>5、当一个行为/动作执行的过程当中是需要对象参与的，那么这个方法一定要定义为“实例方法”，不要带static关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;在购物&quot;</span>);<span class="comment">//this代表当前这个正在执行动作的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Customer c1=<span class="keyword">new</span> Customer();</span><br><span class="line">        c1.name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        Customer c2=<span class="keyword">new</span> Customer();</span><br><span class="line">        c2.name=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        c1.shopping();</span><br><span class="line">        c2.shopping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、this在多数情况下都是省略不写的</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>javaEE环境配置</title>
    <url>/2021/07/26/javaEE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><span id="more"></span>
<p>1、mkdir /opt/jdk</p>
<p>2、通过xftp6上传到 /opt/jdk下</p>
<p>3、cd/opt/jdk</p>
<p>4、解压 tar -zxvf jdk-8u261-linux-x64.tar.gz </p>
<p>5、mkdir /usr/local/java</p>
<p>6、mv /opt/jdk/jdk1.8.0_261 /usr/local/java</p>
<p>7、配置环境变量的配置文件 vim /etc/profile</p>
<p>8、export JAVA_HOME=/usr/local/java/jdk1.8.0_261</p>
<p>9、export PATH=$JAVA_HOME/bin:$PATH</p>
<p>10、source /etc/profi:le [让文件生效]</p>
<h3 id="tomcat安装"><a href="#tomcat安装" class="headerlink" title="tomcat安装"></a>tomcat安装</h3><p>1、上传安装文件，并解压到/opt/tomcat</p>
<p>2、进入解压目录/bin，启动tomcat ./startup.sh</p>
<p>3、开放端口8080</p>
<p>4、测试是否安装</p>
<h3 id="idea安装"><a href="#idea安装" class="headerlink" title="idea安装"></a>idea安装</h3><p>1、上传安装文件，并解压到/opt/idea</p>
<p>2、进入解压目录/bin，启动./idea.sh</p>
<h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><p>1、上传mysql文件，并解压到/opt/mysql</p>
<p>2、运行rpm -e –nodeps mariadb-libs，卸载</p>
<p>3、运行</p>
<ul>
<li><code>rpm -ivh mysql-community-common-5.7.32-1.el7.x86_64.rpm </code></li>
<li><code>rpm -ivh mysql-community-libs-5.7.32-1.el7.x86_64.rpm</code></li>
<li><code>rpm -ivh mysql-community-client-5.7.32-1.el7.x86_64.rpm</code></li>
<li><code>rpm -ivh mysql-community-server-5.7.32-1.el7.x86_64.rpm</code></li>
</ul>
<p>4、运行<code>systemctl start mysqld.service</code></p>
<p><strong>设置root用户密码</strong></p>
<p>Mysql自动给root用户设置随机密码，运行<code>grep&quot;password&quot;/var/log/mysqld.log</code>可看到当前密码</p>
<p>运行mysql -u root -p，用root用户登录，提示输入密码用上述即可，可以成功登录进入mysql命令行，</p>
<p>设置root密码，对于个人开发环境，如果要设比较简单的密码，可以运行：</p>
<ul>
<li><p><code>validate_password_length </code> 固定密码的总长度；</p>
</li>
<li><p><code>validate_password_dictionary_file</code> 指定密码验证的文件路径；</p>
</li>
<li><p><code>validate_password_mixed_case_count</code>  整个密码中至少要包含大/小写字母的总个数；</p>
</li>
<li><p><code>validate_password_number_count </code> 整个密码中至少要包含阿拉伯数字的个数；</p>
</li>
<li><p><code>validate_password_policy</code> 指定密码的强度验证等级，默认为 MEDIUM；</p>
</li>
</ul>
<p>输入修改语句<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;密码&#39;;</code>即可，</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>rpm包的管理</title>
    <url>/2021/07/25/rpm%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="rpm包的管理"><a href="#rpm包的管理" class="headerlink" title="rpm包的管理"></a>rpm包的管理</h2><p>rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中，它生成具有<code>.RPM</code>扩展名的文件，RPM是RedHat Package Manage(RedHat软件包管理工具)的缩写，类似Windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。</p>
<span id="more"></span>
<p>Linux的分发版本都有采用（suse，redhat，centos等等），可以算是公认的行业标准了</p>
<ul>
<li><code>rpm -qa | grep xx</code>：查询已安装的rpm列表，</li>
</ul>
<p><strong>rpm包名基本格式</strong></p>
<p>例如：<code>firefox-52.2.0-2.el7.centos.x86_64</code></p>
<p><img src="/2021/07/25/rpm%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86/rpm%E7%AE%A1%E7%90%86%EF%BC%88firefox%EF%BC%89.png"></p>
<ul>
<li><p>名称：firefox</p>
</li>
<li><p>版本号：52.2.0-2</p>
</li>
<li><p>使用操作系统：el7.centos.x86_64</p>
</li>
<li><p>表示centos7.x的64位系统</p>
</li>
<li><p>如果是i686、i386表示32位系统，noarch表示通用</p>
</li>
<li><p><code>rpm -qa</code>：查询所安装的所有rpm软件包</p>
</li>
<li><p><code>rpm -qa | more</code></p>
</li>
<li><p><code>rpm -qa | grep XX</code></p>
</li>
<li><p><code>rpm -q 软件包名</code>：查询软件包是否安装</p>
</li>
<li><p><code>rpm -qi 软件包名</code>：查询软件包信息</p>
</li>
<li><p><code>rpm -ql 软件包名</code>：查询软件包中的文件</p>
</li>
<li><p><code>rpm -qf 文件全路径名</code>：查询文件所属的软件包</p>
</li>
</ul>
<p><strong>卸载rpm包</strong></p>
<p><code>rpm -e rpm包的名称</code></p>
<p>注意：如果其他软件包依赖于要卸载的软件包，卸载时则会产生错误信息。可以增加参数<code>--nodeps</code>强制删除，但依赖于该软件包的程序可能无法正常运行</p>
<p><strong>安装rpm包</strong></p>
<p><code>rpm -ivh rpm包全路径名称</code></p>
<p>参数说明：</p>
<ul>
<li><code>i</code>: install 安装</li>
<li><code>v</code>: verbose 提示</li>
<li><code>h</code>: hash进度条</li>
</ul>
<h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><p><code>yum</code>是一个Shell前端软件包管理器，基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p>
<p><code>yum list|grep xx</code>：查询yum服务器是否有需要安装的软件</p>
<p><code>yum install xxx</code>：下载安装</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>shell编程</title>
    <url>/2021/07/29/shell%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><p>1、Linux运维工程师在进行服务器集群管理时，需要编写shell程序进行服务器管理。</p>
<span id="more"></span>
<p>2、对于javaEE和Python程序员来说，有时也会需要用shell脚本进行一些工作。</p>
<p>3、对于大数据程序员来说，需要编写shell程序来管理集群。</p>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动，挂起，停止甚至是编写一些程序。</p>
<h3 id="格式要求"><a href="#格式要求" class="headerlink" title="格式要求"></a>格式要求</h3><p>1、脚本以<code>#!/bin/bash</code>开头</p>
<p>2、脚本需要有可执行权限</p>
<h4 id="常用执行方式"><a href="#常用执行方式" class="headerlink" title="常用执行方式"></a>常用执行方式</h4><p>1、输入脚本的绝对路径或相对路径（首先要赋予脚本的+x权限）</p>
<p>2、sh+脚本（不用赋予+x权限，直接执行即可）</p>
<p>例如：</p>
<p><img src="/2021/07/29/shell%E7%BC%96%E7%A8%8B/hello_world.png"></p>
<p>执行命令：</p>
<p><img src="/2021/07/29/shell%E7%BC%96%E7%A8%8B/%E6%89%A7%E8%A1%8C.png"></p>
<p>可以是相对路径也可以是绝对路径</p>
<h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>1、Linux shell中的变量分为：系统变量和用户自定义变量</p>
<p>2、系统变量：$HOME,$PWD,$SHELL,#USER等等，</p>
<p>3、显示当前shell中所有变量：set</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>1、定义变量：变量=值</p>
<p>2、撤销变量：unset 变量</p>
<p>3、声明静态变量：readonly 变量，注意：不能unset</p>
<p>4、输出变量，前要加<code>$</code></p>
<p>5、单行注释：<code>#</code></p>
<p>6、多行注释：<code>:&lt;&lt;!</code></p>
<p><strong>例如</strong>：</p>
<p>1、定义变量A</p>
<p>2、撤销变量A</p>
<p>3、声明静态的变量B=2，不能unset</p>
<p><img src="/2021/07/29/shell%E7%BC%96%E7%A8%8B/%E5%8F%98%E9%87%8F%E7%BB%83%E4%B9%A0.png"></p>
<p>执行：</p>
<p><img src="/2021/07/29/shell%E7%BC%96%E7%A8%8B/%E5%8F%98%E9%87%8F%E7%BB%83%E4%B9%A0%E6%89%A7%E8%A1%8C.png"></p>
<h3 id="变量的定义规则"><a href="#变量的定义规则" class="headerlink" title="变量的定义规则"></a>变量的定义规则</h3><p>1、变量名称可以由字母、数字和下划线组成，但不能以数字开头</p>
<p>2、等号两侧不能有空格</p>
<p>3、变量名称一般习惯为大写</p>
<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><ul>
<li><code>export 变量名=变量值</code>：将shell变量输出为环境变量</li>
<li><code>source 配置文件</code>：让修改后的配置信息立即生效</li>
<li><code>echo $变量名</code>：查询环境变量的值</li>
</ul>
<h2 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h2><p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量。</p>
<p>例如：<code>./myshell.sh 100 200</code>这个就是也给执行shell的命令行，可以在myshell脚本中获取到参数信息</p>
<p>基本语法：</p>
<ul>
<li><code>$n</code>：n为数字，$0代表命令本身，$1~$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包括，如${10}</li>
<li><code>$*</code>：这个变量代表命令行中所有的参数，$*把所有参数看成一个整体</li>
<li><code>$@</code>：这个变量也代表命令行中所有参数，不过$@把每个参数区分对待</li>
<li><code>$#</code>：这个变量代表命令行在所有参数的个数</li>
</ul>
<p>例如：</p>
<p><img src="/2021/07/29/shell%E7%BC%96%E7%A8%8B/%E5%8F%82%E6%95%B0%E6%9F%A5%E7%9C%8B.png"></p>
<p><img src="/2021/07/29/shell%E7%BC%96%E7%A8%8B/%E5%8F%82%E6%95%B0%E6%9F%A5%E7%9C%8B%E7%BB%83%E4%B9%A0.png"></p>
<h2 id="预变量定义"><a href="#预变量定义" class="headerlink" title="预变量定义"></a>预变量定义</h2><p>为shell设计者事先已经定义好的变量，可以直接在shell脚本中使用</p>
<p><strong>基本语法</strong>：</p>
<ul>
<li><code>$$</code>：当前进程的进程号（PID）</li>
<li><code>$!</code>：后台运行的最后一个进程的进程号(PID)</li>
<li><code>$?</code>：最后一次执行的命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行，如果这个变量的值为非0，则证明上一个命令执行不正确。</li>
</ul>
<p><img src="/2021/07/29/shell%E7%BC%96%E7%A8%8B/%E9%A2%84%E5%AE%9A%E4%B9%89%E7%BB%83%E4%B9%A00.png"></p>
<p><img src="/2021/07/29/shell%E7%BC%96%E7%A8%8B/%E9%A2%84%E5%AE%9A%E4%B9%89%E7%BB%83%E4%B9%A01.png"></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><code>&quot;$((运算式))&quot;</code>或<code>&quot;$[运算式]&quot;</code>或者<code>expr m + n</code></li>
<li>注意expr运算符间要有空格，如果希望expr的结果付给某个变量，使用``</li>
<li><code>expr m - n</code></li>
<li><code>expr \* / % 乘 除 取余 </code></li>
</ul>
<p><img src="/2021/07/29/shell%E7%BC%96%E7%A8%8B/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%83%E4%B9%A01.png"></p>
<p><img src="/2021/07/29/shell%E7%BC%96%E7%A8%8B/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%AD%94%E6%A1%88.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>var介绍</title>
    <url>/2021/08/01/var/</url>
    <content><![CDATA[<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p>var是Java10 版本新出的特性，用来定义局部变量</p>
<span id="more"></span>
<ul>
<li>var 变量名 =  初始值;</li>
</ul>
<p>java是强类型语言，每个变量都有固定的变量类型，var不是关键字，它相当于一种动态类型。</p>
<p>var动态类型是编译器根据变量所赋的值来推断类型，var只是一种简便的写法。</p>
<p>在定义局部变量时，任意什么类型都可以用var定义变量的类型，其会根据所赋的值来判断类型。</p>
<p>注意事项：</p>
<ul>
<li>var只能在方法内定义变量，不允许定义类的成员变量</li>
<li>var定义变量必须赋初始值</li>
<li>var每次只能定义一个变量，不能符合声明变量。</li>
</ul>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>函数，谓词，CASE表达式</title>
    <url>/2021/07/07/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p>算数函数</p>
</li>
<li><p>字符串函数</p>
<span id="more"></span></li>
<li><p>日期函数</p>
</li>
<li><p>转换函数</p>
</li>
<li><p>聚合函数</p>
</li>
</ul>
<h3 id="算数函数"><a href="#算数函数" class="headerlink" title="算数函数"></a>算数函数</h3><p><strong>ABS——绝对值</strong></p>
<p><code>ABS(数值)</code></p>
<p>当参数为NULL时，返回值也是NULL，其实当绝大多数函数的参数为NULL时，结果也是NULL。</p>
<p><strong>MOD——求余</strong></p>
<p><code>MOD(被除数,除数)</code></p>
<p><strong>ROUND——四舍五入</strong></p>
<p><code>ROUND(对象数值，保留小数的位数)</code></p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p><strong>CONCAT——拼接</strong></p>
<p><code>CONCAT(str1,str2,str3……)</code></p>
<p>当其中一个为NULL时，结果也是NULL。</p>
<p><strong>LENGTH——字符串长度</strong></p>
<p><code>LENGTH(字符串)</code></p>
<p>注意：与半角英文占用1字节不同，汉字这样的全角字符会占用2个以上的字节（称为多字节字符）。因此，使用MySQL中的LENGTH这样的以字节为单位的函数进行计算时，“LENGTH(函数)”的返回结果是4，同样的LENGTH函数，不同DBMS的执行结果也不尽相同。</p>
<p><strong>LOWER——小写转换</strong></p>
<p><code>LOWER(字符串)</code></p>
<p><strong>REPLACE——字符串的替换</strong></p>
<p><code>REPLACE(对象字符串,替换前的字符串,替换后的字符串)</code></p>
<p>例如：REPLACE(abcdefabc,abc,ABC)结果为：ABCdefABC</p>
<p><strong>SUBSTRING——字符串的截取</strong></p>
<p><code>SUBSTRING(对象字符串 FROM 截取的起始位置 FOR 截取的字符数)</code></p>
<p><strong>UPPER——大写转换</strong></p>
<p><code>UPPER(字符串)</code></p>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p><strong>CURRENT_DATE——当前日期</strong></p>
<p><code>CURRENT_DATE</code></p>
<p>其返回SQL执行的日期，也就是该函数执行时的日期，由于没有参数，因此无需使用括号。</p>
<p>** CURRENT_TIME**</p>
<p><code>CURRENT_TIME</code></p>
<p>获取SQL执行的时间，也就是该函数执行时的时间，因为没有参数，所以无需括号。</p>
<p><strong>CURRENT_TIMESTAMP——当前日期和时间</strong></p>
<p><code>CURRENT_TIMESTAMP</code></p>
<p>其具有CURRENT_DATE+CURRENT_TIME的功能，该函数可以同时获取当前的日期和时间。</p>
<p><strong>EXTRACT——截取日期元素</strong></p>
<p><code>EXTRACT(日期元素 FROM 日期)</code></p>
<p>例如：<code>SELECT CURRENT_TIMESTAMP,EXTRACT(YEAR FROM CURRENT_TIMESTAMP) AS year,EXTRACT(MONTH FROM CURRENT_TIMESTAMP) AS MONTH,EXTRACT(DAT FROM CURRENT_TIMESTAMP) AS DAY,EXTRACT(HOUR FROM CURRENT_TIMESTAMP) AS HOUR,EXTRACT(MINUTE FROM CURRENT_TIMESTAMP) AS MINTUE,EXTRACT(SECOND FROM CURRENT_TIMESTAMP) AS SECOND; </code></p>
<h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p><strong>CAST函数</strong></p>
<p><code>CAST(转换前的值 AS 想要转换的数据类型)</code></p>
<p><strong>COALESCE——将NULL转换为其他值</strong></p>
<p><code>COALESCE(数据1,数据2,数据3……)</code></p>
<p>该函数会返回可变参数中左侧开始第一个不是NULL的值。</p>
<h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>谓词是需要满足特定条件的函数，该条件就是返回值是真值。对通常函数而言，返回值可能是数字，字符串等类型，但谓词的返回值全都是真值（TRUE/FALSE）。</p>
<ul>
<li>LIKE</li>
<li>BETWEEN</li>
<li>IS NULL,  IS NOT NULL</li>
<li>IN</li>
<li>EXISTS</li>
</ul>
<p><strong>LIKE谓词——字符串的部分一致查询</strong></p>
<p>LIKE谓词查询更加模糊一些，当需要进行字符串的部分一致查询时才需要使用它。</p>
<p>1、前方一致</p>
<p>2、中间一致</p>
<p>3、后方一致</p>
<p><code>%</code>代表“0个字符以上的任意字符串”</p>
<p><code>_</code>代表“任意一个字符”</p>
<p><strong>BETWEEN谓词——范围查询</strong></p>
<p><code>BETWEEN 100 AND 1000;</code>等于<code>&gt;=100 and &lt;=1000</code></p>
<p><strong>IS NULL,IS NOT NULL——判断是否为NULL</strong></p>
<p><strong>IN谓词——OR的简便用法</strong></p>
<p><code>IN(值，值，……)</code>只要其值等于括号内的任意一个值，就返回真。</p>
<p><code> NOT IN (值，值，……)</code>只要其值不等于括号内的任意一个值，就返回真。</p>
<p>在使用IN 或 NOT IN时是无法选取出NULL数据的。</p>
<p><strong>EXISTS谓词</strong></p>
<p>EXISTS为“存在”，<code>EXISTS()</code>括号里通常是一个子查询，EXISTS只关心记录是否存在，只有在子查询查询出满足其条件的记录时，EXISTS会返回真，NOT EXISTS于其相反，只有不存在时才会返回真。</p>
<h4 id="使用子查询作为IN谓词的参数"><a href="#使用子查询作为IN谓词的参数" class="headerlink" title="使用子查询作为IN谓词的参数"></a>使用子查询作为IN谓词的参数</h4><p>IN或NOT IN其后括号的值可以用SELECT语句来代替</p>
<h3 id="CASE表达式"><a href="#CASE表达式" class="headerlink" title="CASE表达式"></a>CASE表达式</h3><p>CASE在编程中通常称为（条件）分支。</p>
<p>CASE表达式的语法分为简单CASE表达式和搜索CASE表达式两种。由于搜索CASE表达式包含了简单CASE表达式的全部功能，所以在此只介绍搜索CASE表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE WHEN&lt;求值表达式&gt; THEN &lt;表达式&gt;</span><br><span class="line">     WHEN&lt;求值表达式&gt; THEN &lt;表达式&gt;</span><br><span class="line">     WHEN&lt;求值表达式&gt; THEN &lt;表达式&gt;</span><br><span class="line">     ……</span><br><span class="line">     ELSE &lt;表达式&gt;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>WHEN子句中&lt;求值表达式&gt;就是列斯“列=值”这样，返回值为真值的表达式。如果WHEN子句中的表达式返回值为真值，则执行THEN后的表达式，如果不为真，就跳到下一个CASE语句，如果所有WHEN子句中表达式都不为真，则执行ELSE子句中的表达式。</p>
<p>ELSE子句可以省略，END不能省略。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>单元测试，Maven快照</title>
    <url>/2021/08/06/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8CMaven%E5%BF%AB%E7%85%A7/</url>
    <content><![CDATA[<h2 id="单元测试junit"><a href="#单元测试junit" class="headerlink" title="单元测试junit"></a>单元测试junit</h2><p>junit是一个测试的框架（工具）。junit测试的内容为类中的方法，每一个方法都是独立测试的。方法是测试的基本单位。</p>
<span id="more"></span>
<p>maven借助单元测试，批量的测试编写的类中的方法是否符合预期。</p>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><p>首先要在pom.xml中加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>推荐写法：</p>
<ul>
<li>测试类的名称为：Test+”需要测试的类名”</li>
<li>测试方法名称为：Test+”方法名称”</li>
</ul>
<p>**测试方法(注意)**：</p>
<ul>
<li>方法是public修饰</li>
<li>方法没有返回值</li>
<li>方法名称为自定义</li>
<li>方法上写上 @Test</li>
</ul>
<p>当前目录结构：</p>
<p><img src="/2021/08/06/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8CMaven%E5%BF%AB%E7%85%A7/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84junit.png"></p>
<p>在java的com.ffyzsl.junitTest下编写Caculate类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffyzsl.junitTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caculate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在test的java中编写测试类TestCaculate类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ffyzsl.junitTest.Caculate;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCaculate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Testpuls</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Caculate caculate = <span class="keyword">new</span> Caculate();</span><br><span class="line">        <span class="keyword">int</span> result =caculate.plus(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//assertEquals（期望值，实际值）</span></span><br><span class="line">        <span class="comment">//如果两个值相同，则正确，如果不相等，就抛异常</span></span><br><span class="line">        Assert.assertEquals(<span class="number">5</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Testminus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Caculate caculate = <span class="keyword">new</span> Caculate();</span><br><span class="line">        <span class="keyword">int</span> result =caculate.minus(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">4</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后进入当前项目存在pom的目录。进入cmd命令行窗口，输入<code>mvn test</code></p>
<h1 id="Maven快照"><a href="#Maven快照" class="headerlink" title="Maven快照"></a>Maven快照</h1><p>（转自：<a href="https://www.cnblogs.com/EasonJim/p/6852840.html%EF%BC%89">https://www.cnblogs.com/EasonJim/p/6852840.html）</a></p>
<h2 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h2><p>一个大型的软件应用通常包含多个模块，并且通常的场景是多个团队开发同一应用的不同模块。举个例子，设想一个团队开发应用的前端，项目为<strong>app-ui（app-ui.jar:1.0）</strong>，而另一个团队开发应用的后台，使用的项目是<strong>data-service（data-service.jar:1.0）</strong>。</p>
<p>现在可能出现的情况是开发<strong>data-service</strong>的团队正在进行快节奏的bug修复或者项目改进，并且他们几乎每隔一天就要发布库到远程仓库。</p>
<p>现在如果<strong>data-service</strong>团队每隔一天上传一个新版本，那么将会出现下面的问题：</p>
<ul>
<li><strong>data-service</strong>团队每次发布更新的代码时都要告知<strong>app-ui</strong>团队。</li>
<li><strong>app-ui</strong>团队需要经常地更新他们<strong>pom.xml</strong>文件到最新版本。</li>
</ul>
<p>为了解决这种情况， <strong>快照（SNAPSHOT）</strong>的概念派上了用场。</p>
<h2 id="二、什么是快照（SNAPSHOT）"><a href="#二、什么是快照（SNAPSHOT）" class="headerlink" title="二、什么是快照（SNAPSHOT）?"></a>二、什么是快照（SNAPSHOT）?</h2><p>**快照**（SNAPSHOT）*<em><strong>是一种特殊的版本，</strong></em>*指定了某个当前的开发进度的副本*<em><strong>。不同于常规的版本，</strong>Maven每次构建都会在远程仓库中检查新的快照。</em>*</p>
<p>现在<strong>data-service</strong>团队会每次发布更新代码的快照到仓库中，比如说<strong>data-service:1.0-SNAPSHOT</strong>来替代旧的快照jar包。</p>
<p>注意：每次更新jar包时，版本号不变，且后缀必须带上-SNAPSHOT。</p>
<h2 id="三、项目快照（SNAPSHOT）VS-版本（Version）"><a href="#三、项目快照（SNAPSHOT）VS-版本（Version）" class="headerlink" title="三、项目快照（SNAPSHOT）VS 版本（Version）"></a>三、项目快照（SNAPSHOT）VS 版本（Version）</h2><p><strong>版本（Version）</strong>的情况下，如果Maven以前下载过指定的版本文件，比如说<strong>data-service:1.0</strong>，Maven将不会再从仓库下载新的可用的1.0文件。若要下载更新的代码，data-service的版本需要升到1.1。</p>
<p><strong>快照（Snapshot）</strong>的情况下，每次<strong>app-ui</strong>团队构建他们的项目时，<strong>Maven</strong>将自动获取最新的快照(<strong>data-service:1.0-SNAPSHOT</strong>)。</p>
<p>备注：<strong>版本（Version）</strong>存放在Release发布仓库。<strong>快照（Snapshot）</strong>存放在Snapshot快照仓库。</p>
<p>注意：<strong>版本（Version）</strong>的概念，只要不带有**-SNAPSHOT<strong>的关键字时，都会认为这是一个在</strong>Release发布仓库<strong>的jar包。其中在</strong>Release发布仓库**的jar包命名除了具体的版本号之后还可以带上比如：1.0-Release、1.0-rc1等等的字样。</p>
<h2 id="四、原理详解"><a href="#四、原理详解" class="headerlink" title="四、原理详解"></a>四、原理详解</h2><p><strong>Maven</strong>中的仓库分为两种，<strong>Snapshot快照仓库</strong>和<strong>Release发布仓库</strong>。<strong>Snapshot快照仓库</strong>用于保存开发过程中的不稳定版本，<strong>Release正式仓库</strong>则是用来保存稳定的发行版本。定义一个组件/模块为<strong>快照版本</strong>，只需要在<strong>pom.xml</strong>文件中在该模块的版本号后加上**-SNAPSHOT**即可（注意这里必须是大写），如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jsoft.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testcommon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Maven</strong>会根据模块的版本号（<strong>pom.xml</strong>文件中的<strong>version）</strong>中是否带有**-SNAPSHOT<strong>来判断是</strong>快照版本<strong>还是</strong>正式版本<strong>。如果是</strong>快照版本<strong>，那么在</strong>mvn deploy<strong>时会自动发布到</strong>快照版本库<strong>中，而使用</strong>快照版本<strong>的模块，在</strong>不更改版本号<strong>的情况下，直接编译打包时，</strong>Maven<strong>会</strong>自动从镜像服务器上下载最新的快照版本<strong>。如果是</strong>正式发布版本<strong>，那么在</strong>mvn deploy<strong>时会自动发布到</strong>正式版本库<strong>中，而使用</strong>正式版本<strong>的模块，在</strong>不更改版本号<strong>的情况下，编译打包时如果本地已经存在该版本的模块则</strong>不会主动去镜像服务器上下载**。</p>
<p>所以，我们在开发阶段，可以将公用库的版本设置为快照版本，而被依赖组件则引用快照版本进行开发，在公用库的快照版本更新后，我们也不需要修改<strong>pom.xml</strong>文件提示版本号来下载新的版本，直接<strong>Maven</strong>执行相关编译、打包命令即可重新下载最新的快照库了，从而也方便了我们进行开发。</p>
<p>虽然，<strong>快照</strong>的情况下，<strong>Maven</strong>在日常工作中会自动获取最新的快照，你也可以在任何<strong>Maven</strong>命令中使用**-U参数<strong>强制</strong>Maven**下载最新的快照构建。命令如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mvn clean package -U</span><br></pre></td></tr></table></figure>

<h2 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h2><p>如果在pom.xml文件中，声明了${project.version} ，代表的就是当前pom 的版本。</p>
<p><strong>也即：maven中的${project.groupId} 和 ${project.version} 表示当前项目的groupId和版本。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.damai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>park<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>park-guard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.damai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>park-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如，上面的<version>${project.version}</version> 表示的就是 0.0.2-SNAPSHOT</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2021/08/04/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射库提供了一个丰富而精巧的工具集，用来编写能够动态操纵java代码的程序。能够分析类能力的程序称为反射。其可以用来：</p>
<span id="more"></span>
<ul>
<li>在运行时分析类的能力</li>
<li>在运行时检查对象，例如：编写一个适用于所有类的toString方法</li>
<li>实现泛型数组操作代码</li>
<li>利用Method对象</li>
</ul>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>在程序运行期间，java始终为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类，虚拟机利用运行时类型信息选择要执行的正确的方法。</p>
<p>使用一个特殊的java类可以访问这些信息，保存这个信息的类名为Class，Object类中的getClass()方法将会返回一个Class类型的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflectionTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 =<span class="string">&quot;123&quot;</span>;</span><br><span class="line">        Class c1 = str1.getClass();</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c1.getName());</span><br><span class="line">        String className =<span class="string">&quot;java.lang.String&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Class.forName(className));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class"><span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br></pre></td></tr></table></figure>

<p>在使用静态方法forName时，如果类名保存在一个字符串中，这个字符串会在运行时变化，就可以使用这个方法。如果className是一个类名或接口名，这个方法可以正常执行，否则，forName方法将抛出一个检查型异常。</p>
<p>Class已经重写了toString方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (isInterface() ? <span class="string">&quot;interface &quot;</span> : (isPrimitive() ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;class &quot;</span>))</span><br><span class="line">            + getName();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h3><p>在java.lang.reflect包中有三个类：Field，Method和Constructor分别用于描述类的字段，方法和构造器。这三个类都有一个叫做getName的方法，用来返回字段，方法或构造器的名称。</p>
<p>Field类有一个getType()方法，用来返回描述字段类型的一个Class对象。这三个类都有一个getModifiers的方法，它将返回一个整数，用不同的0/1位描述所使用的修饰符。另外，利用java.lang.reflect包中Modifier类的静态方法分析getModifiers返回的这个整数。</p>
<h3 id="通过反射创建类对象"><a href="#通过反射创建类对象" class="headerlink" title="通过反射创建类对象"></a>通过反射创建类对象</h3><p>第一种方式：通过Class对象的newInstance()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1 = Apple.class;</span><br><span class="line">Apple apple = (Apple)c1.newInstance();</span><br></pre></td></tr></table></figure>

<p>第二种方式：通过Constructor对象的newInstance()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1 = Apple.class;</span><br><span class="line">Constructor constructor = c1.getConstructor();</span><br><span class="line">Apple apple = (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Constructor constructor = clz.getConstructor(String.class, int.class);</span><br><span class="line">Apple apple = (Apple)constructor.newInstance(&quot;红富士&quot;, 15);</span><br></pre></td></tr></table></figure>

<h3 id="通过反射获取类属性，方法，构造器"><a href="#通过反射获取类属性，方法，构造器" class="headerlink" title="通过反射获取类属性，方法，构造器"></a>通过反射获取类属性，方法，构造器</h3><p>我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Field[] fields = clz.getFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">price</span><br></pre></td></tr></table></figure>

<p>而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Field[] fields = clz.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name</span><br><span class="line">price</span><br></pre></td></tr></table></figure>

<p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>视图</title>
    <url>/2021/07/08/%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>在创建表时，并把数据插入到表中，这些数据实际上会被保存在计算机的存储设备上，当我们通过SELECT语句进行查询时，实际上就是从存储设备中读取数据，在通过各种计算之后，再将结果返回给用户。但使用视图时并不会将数据保存在存储设备中，而且也不会将数据保存到其他任何地方。</p>
<span id="more"></span>
<p>视图的优点：1、视图无需保存数据，因此可以节省存储设备的容量。</p>
<p>​                      2、可以将频繁使用的SELECT语句保存成视图，这样就不同每次都重新书写了。</p>
<h3 id="创建视图的方法"><a href="#创建视图的方法" class="headerlink" title="创建视图的方法"></a>创建视图的方法</h3><p><code>CREATE VIEW 视图名称(&lt;视图列名1&gt;,&lt;视图列名2&gt;,……) AS &lt;SELECT语句&gt;</code></p>
<p>例如：<code>CREATE VIEW productSum(product_type,cnt_product) AS SELECT product_type,COUNT(*) FROM product GROUP BY product_type;</code></p>
<p>使用视图：</p>
<p><code>SELECT product_type,cnt_product FROM prouctSum;</code>(把FROM后面的表名替换为视图名)</p>
<p>可以通过视图为基础创建视图，称为多重视图，多重试图会降低SQL的性能，应该避免在视图的基础上创建视图。</p>
<p>注意：定义视图时不能使用ORDER BY子句<br>###　视图的更新</p>
<p>对视图的更新有着严格的限制，但某些时候也可以对视图进行更新。</p>
<p>１、SELECT子句中未使用DISTINCT</p>
<p>２、FROM子句中只有一张表</p>
<p>３、未使用GROUP BY子句</p>
<p>４、未使用HAVING 子句</p>
<p>视图和表需要同时进行更新，因此通过汇总得到的视图无法更新。</p>
<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>　<code>DROP VIEW 视图名称(&lt;视图列名1&gt;,&lt;视图列名2&gt;，……)</code></p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询就是将用来定义视图的SELECT语句直接用于FROM子句当中。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>对表进行聚合查询</title>
    <url>/2021/07/06/%E5%AF%B9%E8%A1%A8%E8%BF%9B%E8%A1%8C%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="对表进行聚合查询"><a href="#对表进行聚合查询" class="headerlink" title="对表进行聚合查询"></a>对表进行聚合查询</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul>
<li>COUNT：计算表中的记录数（行数）</li>
<li>SUM：计算表中数值列中的数据的合计值</li>
<li>AVG：计算表中数值列中的数据的平均值</li>
<li>MAX：求出表中任意列中数据的最大值</li>
<li>MIN：求出表中任意列中数据的最小值<span id="more"></span>
以上的函数称为聚合函数或者聚集函数。</li>
</ul>
<p>例如：<code>SELECT COUNT(&lt;列名&gt;/*) FRPM 表名;</code></p>
<p>COUNT函数的结果根据参数的不同而不同，COUNT(*)会得到包含NULL的数据行数，而COUNT(&lt;列名&gt;)会得到NULL之外的数据行数。</p>
<p>一般来说，除了COUNT函数，其他聚合函数会把NULL排除在外。</p>
<h4 id="使用聚合函数删除重复值"><a href="#使用聚合函数删除重复值" class="headerlink" title="使用聚合函数删除重复值"></a>使用聚合函数删除重复值</h4><p>例如：<code>SELECT COUNT(DISTINCT product_type) FROM product;</code>会得到一共有多少种商品类型</p>
<p>一般来说，想要计算值的种类时，可以在COUNT函数的参数中使用DISTINCT。同时，在聚合函数的参数中使用DISTINCT，可以删除重复数据</p>
<h3 id="对表进行分组"><a href="#对表进行分组" class="headerlink" title="对表进行分组"></a>对表进行分组</h3><p>使用<code>GROUP BY</code>子句</p>
<p><code>SELECT &lt;列名1&gt;,&lt;列名2&gt; FROM &lt;表名&gt; GROUP BY &lt;列名1&gt;,&lt;列名2&gt;;</code></p>
<p>在GROUP BY子句后使用的列名称为聚合键或者分组列，在查询过程中，首先会根据分组列分成不同的组，然后再查询每一组的数据。简单来说，GROUP BY 就像切分表的一把刀。</p>
<p>使用WHERE子句进行汇总处理时，会先根据WHERE子句指定的条件进行过滤，然后再进行汇总处理</p>
<p>注意：</p>
<p>1、GROUP BY子句一定要写在FROM语句之后。</p>
<p>2、GROUP BY后分列组的顺序不同，查询的结果也可能不同。</p>
<p>3、聚合键中包含NULL时，在结果中会以“不确定”行（空行）的形式表现出来。</p>
<p>4、在使用GROUP BY子句后，所要查询的列（SELECT子句后的列名）必须包含在GROUP BY中（不过MySQL认同这种写法，不会发生错误，但在其他DBMS中，并不支持这样的写法）</p>
<p>5、在GROUP BY子句中不能写列的别名（PostgreSQL和MySQL不会发生错误，但并不是通常的使用方法）</p>
<p>6、GROUP BY子句结果的显示是无序的</p>
<p>7、只有SELECT 子句和HAVING 子句（以及ORDER BY 子句）中能够使用聚合函数</p>
<h3 id="为聚合结果指定条件"><a href="#为聚合结果指定条件" class="headerlink" title="为聚合结果指定条件"></a>为聚合结果指定条件</h3><p><code>HAVING</code>子句</p>
<p>WHERE子句只能指定记录（行）的条件，并不能用来指定组的条件，如果想要对集合指定条件就需要使用HAVING子句。</p>
<p>HAVING子句必须写在GROUP BY 子句之后</p>
<p><code>SELECT &lt;列名1&gt;,&lt;列名2&gt;,&lt;列名3&gt; FROM &lt;表名&gt; WHERE &lt;条件表达式&gt; GROUP BY &lt;列名1&gt;,&lt;列名2&gt;,&lt;列名3&gt; HAVING &lt;分组结果对应条件&gt;;</code></p>
<p>例如：<code>SELECT product_type,COUNT(*) FROM Product GROUP BY product_type HAVING COUNT(*) =2;</code>查询出记录等于二的商品种类和个数。</p>
<p>HAVING子句的构成要素：常数、聚合函数、GROUP BY子句中指定的列</p>
<p>注意：有些条件相对于HAVING子句，更适合写在WHERE子句中。</p>
<p>WHERE子句：指定行所对应的条件</p>
<p>HAVING子句：指定组所对应的条件</p>
<h3 id="对查询结果进行排序"><a href="#对查询结果进行排序" class="headerlink" title="对查询结果进行排序"></a>对查询结果进行排序</h3><p> <code>SELECT &lt;列名1&gt;,&lt;列名2&gt;,&lt;列名3&gt; FROM &lt;表名&gt; ORDER BY &lt;排序基准列1&gt;,&lt;排序基准列2&gt;;</code></p>
<p>ORDER BY 子句中书写的列名称为排序键，其通常写在SELECT子句的末尾。</p>
<h4 id="指定升序或降序"><a href="#指定升序或降序" class="headerlink" title="指定升序或降序"></a>指定升序或降序</h4><p>降序排序时，在列名后面使用<code>DESC</code>关键字。升序使用<code>ASC</code>关键字。</p>
<p>未指定ORDER BY子句中排列顺序会默认使用升序进行排序。</p>
<p>可以指定多个排序键。</p>
<p>排序键中包含NULL时，会在开头或末尾进行汇总。</p>
<p>在ORDER BY子句中可以使用SELECT子句中定义的别名。</p>
<p>在ORDER BY子句中可以使用SELECT子句中未使用的列和聚合函数。</p>
<p>注意：在ORDER BY子句中可以使用SELECT子句中列所对应的编号，但不建议这样使用</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>定时备份数据库</title>
    <url>/2021/07/29/%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="定时备份数据库"><a href="#定时备份数据库" class="headerlink" title="定时备份数据库"></a>定时备份数据库</h2><span id="more"></span>
<p>需求：</p>
<p>1、每天凌晨 2:30 备份数据库 ffyzsl到/data/backup/db</p>
<p>2、备份开始和备份结束能够给出相应的提示信息</p>
<p>3、备份后的文件要求以备份时间为文件名，并打包成<code>.tar.gz</code>的形式，比如<code>2021-7-21-23234.tar.gz</code></p>
<p>4、在备份的同时，检查是否有10天前备份的数据库文件，如果有就将其删除。</p>
<p>创建一个数据库名为<code>ffyzsl（create database ffyzsl）</code></p>
<p>然后创建一个shop表，<code>use ffyzsl;create table shop(product_id CHAR(4) NOT NULL,product_name VARCHAR(100) NOT NULL,product_type VARCHAR(32) NOT NULL,sale_price INTEGER ,PRIMARY KEY(product_id));</code></p>
<p>使用INSERT，在表中插入记录。</p>
<p><code>SELECT * FROM shop;</code></p>
<p><img src="/2021/07/29/%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/shop%E8%A1%A8.png"></p>
<p>编写一个脚本，用来完成需求。此脚本名为<code>mysql_db_backup.sh</code>放在<code>/usr/sbin/</code>下</p>
<p><strong>备份数据库指令</strong>：</p>
<ul>
<li><code>mysqldump [选项] 数据库名 [表名] &gt; 脚本名</code></li>
<li><code>mysqldump [选项] --数据库名 [选项 表名] &gt; 脚本名</code></li>
<li><code>mysqldump [选项] --all-databases [选项] &gt; 脚本</code></li>
</ul>
<p><em><strong>选项说明</strong></em></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>缩写</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>–host</td>
<td>-h</td>
<td>服务器IP地址</td>
</tr>
<tr>
<td>–port</td>
<td>-P</td>
<td>服务器端口号</td>
</tr>
<tr>
<td>–user</td>
<td>-u</td>
<td>MySQL 用户名</td>
</tr>
<tr>
<td>–pasword</td>
<td>-p</td>
<td>MySQL 密码</td>
</tr>
<tr>
<td>–databases</td>
<td></td>
<td>指定要备份的数据库</td>
</tr>
<tr>
<td>–all-databases</td>
<td></td>
<td>备份mysql服务器上的所有数据库</td>
</tr>
<tr>
<td>–compact</td>
<td></td>
<td>压缩模式，产生更少的输出</td>
</tr>
<tr>
<td>–comments</td>
<td></td>
<td>添加注释信息</td>
</tr>
<tr>
<td>–complete-insert</td>
<td></td>
<td>输出完成的插入语句</td>
</tr>
<tr>
<td>–lock-tables</td>
<td></td>
<td>备份前，锁定所有数据库表</td>
</tr>
<tr>
<td>–no-create-db/–no-create-info</td>
<td></td>
<td>禁止生成创建数据库语句</td>
</tr>
<tr>
<td>–force</td>
<td></td>
<td>当出现错误时仍然继续备份操作</td>
</tr>
<tr>
<td>–default-character-set</td>
<td></td>
<td>指定默认字符集</td>
</tr>
<tr>
<td>–add-locks</td>
<td></td>
<td>备份数据库表时锁定数据库表</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">备份目录</span></span><br><span class="line">BACAUP=/data/backup/db</span><br><span class="line"><span class="meta">#</span><span class="bash">当前时间</span></span><br><span class="line">DATETIME=$(date + %Y-%M-%d_%H%M%S)</span><br><span class="line"><span class="meta">#</span><span class="bash">数据库的地址</span></span><br><span class="line">HOST=localhost</span><br><span class="line"><span class="meta">#</span><span class="bash">数据库用户名</span></span><br><span class="line">DB_USER=root</span><br><span class="line"><span class="meta">#</span><span class="bash">数据库密码</span></span><br><span class="line">DB_PW=ffyzsl</span><br><span class="line"><span class="meta">#</span><span class="bash">要备份的数据库</span></span><br><span class="line">DATABASE=ffyzsl</span><br><span class="line"><span class="meta">#</span><span class="bash">创建备份目录，不存在就创建</span></span><br><span class="line">[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">备份数据库</span></span><br><span class="line">mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PW&#125; --host=$&#123;HOST&#125; -q -R --databases $&#123;DATABASE&#125; | gzip &gt;	$&#123;BACKUP&#125;/$&#123;DATETIME&#125;/$DATETIME.sql.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">将文件处理成tar.gz</span></span><br><span class="line">cd $&#123;BACKUP&#125;</span><br><span class="line">tar -zcvf $DATETIME.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">删除对应的备份目录</span></span><br><span class="line">rm -rf $&#123;BACKUP&#125;/$&#123;DATETIME&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">删除10天前备份的文件</span></span><br><span class="line">find $&#123;BACKUP&#125; -atime +10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;</span><br><span class="line">echo &quot;备份数据库$&#123;DATABASE&#125;完成&quot;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>数据更新</title>
    <url>/2021/07/06/%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="数据的插入"><a href="#数据的插入" class="headerlink" title="数据的插入"></a>数据的插入</h3><p><code>INSERT INTO &lt;表名&gt; (列1,列2,列3,……) VALUES (值1,值2,值3,……);</code></p>
<span id="more"></span>
<p>表名后面的列清单和VALUES子句中的值清单的列数必须保持一致，否则无法插入数据。</p>
<p>原则上，执行一次INSERT语句会插入一行数据。</p>
<p>对表进行全列INSERT时，可以省略表名后的列清单，这时VALUES子句的值会默认按照从左到右的顺序赋给每一列。</p>
<p>想给某一列赋NULL时，可以直接在VALUES子句的清单中写入NULL。（想插入NULL的列一定不能设置NOT NULL约束）</p>
<h4 id="插入默认值"><a href="#插入默认值" class="headerlink" title="插入默认值"></a>插入默认值</h4><p>在CREATE TBALE语句中设置DEFAULT约束来设置默认值。</p>
<h5 id="显示方式"><a href="#显示方式" class="headerlink" title="显示方式"></a>显示方式</h5><p>例如：<code>INSERT INTO Product(product_id,product_name,prouduct_type,sale_price) VALUES (&#39;007&#39;, &#39;A&#39;,&#39;B&#39;,DEFAULT);</code></p>
<h5 id="隐式方式"><a href="#隐式方式" class="headerlink" title="隐式方式"></a>隐式方式</h5><p>例如：<code>INSERT INTO Product(product_id,product_name,prouduct_type,sale_price) VALUES (&#39;007&#39;, &#39;A&#39;,&#39;B&#39;);</code></p>
<p>注意：省略INSERT语句中的列名，就会自动设定为该列的默认值（没有默认值会设定为NULL）</p>
<h4 id="从其他表中复制数据"><a href="#从其他表中复制数据" class="headerlink" title="从其他表中复制数据"></a>从其他表中复制数据</h4><p>例如：创建一个原表：<code>CREATE TABLE product(product_id CHAR(4) NOT NULL,product_name VARCHAR(100) NOT NULL,product_type VARCHAR(100) NOT NULL,sale_price) INTEGER,PRIMARY KEY(product_Id));</code></p>
<p>在创建一个复制表：<code>CREATE TABLE productCopy(product_id CHAR(4) NOT NULL,product_name VARCHAR(100) NOT NULL,product_type VARCHAR(100) NOT NULL,sale_price) INTEGER,PRIMARY KEY(product_Id));</code></p>
<p>执行：<code>INSERT INTO productCopy(product_id,product_name,product_type,sale_price) SELECT product_id,product_name,product_type,sale_price FROM product;</code></p>
<p>执行INSERT……SELECT语句，也可以使用WHERE子句或者GROUP BY子句等。</p>
<h3 id="数据的删除"><a href="#数据的删除" class="headerlink" title="数据的删除"></a>数据的删除</h3><p>使用DROP TABLE语句会将表完全删除，使用DELETE语句只会删除数据，留下表。</p>
<p><code>DELETE FROM &lt;表名&gt; WHERE &lt;条件&gt;;</code></p>
<h3 id="数据的更新"><a href="#数据的更新" class="headerlink" title="数据的更新"></a>数据的更新</h3><p>`UPDATE &lt;表名&gt; SET &lt;列名&gt;=&lt;表达式&gt; WHERE &lt;条件&gt;;</p>
<p>使用UPDATE也可以将列更新为NULL（此更新俗称为NULL清空）（只限于未设置NOT NULL约束的列）</p>
<h4 id="多列更新"><a href="#多列更新" class="headerlink" title="多列更新"></a>多列更新</h4><p>例如：<code>UPDATE Product SET sale_price=sale_price*2,purchase_price=purchase_price/2 WHERE product_type=&#39;B&#39;;</code></p>
<p><code>UPDATE Product SET (sale_price,purchase_price)=(sale_price*2,purchase_price/2) WHERE product_type=&#39;B&#39;;</code></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事物就是<strong>需要在同一个处理单元中执行的一系列更新处理的集合</strong></p>
<h4 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务开始语句;</span><br><span class="line">    DML语句1;</span><br><span class="line">    DML语句2;</span><br><span class="line">    DML语句3;</span><br><span class="line">    ……</span><br><span class="line">事务结束语句（COMMIT或者ROLLBACK);</span><br></pre></td></tr></table></figure>

<p>使用事务开始语句和事务结束语句，将一系列DML语句（INSERT/UPDATE/DELETE）括起来，就实现了一个事务处理。</p>
<p>在标准SQL中并没有定义事务的开始语句，而是由各个DBMS自己来定义的</p>
<p>MySQL:<code>START TRANSACTION</code></p>
<p>COMMIT：提交处理，一旦提交，就无法恢复到事务开始前的状态了。虽然我们可以不清楚事务开始的时间点，但是在事务结束时一定要仔细进行确认。</p>
<p>ROLLBACK：取消处理，取消事务包含的全部更新处理的结束指令，相当于文件处理中的放弃保存，一旦回滚，数据库就会恢复到事务开始之前的状态</p>
<h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3><ul>
<li>原子性（Atomicity）</li>
<li>一致性（Consistency）</li>
<li>隔离性（Isolation）</li>
<li>持久性（Durability）</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>异常处理的补充</title>
    <url>/2021/08/01/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h3 id="异常继承结构"><a href="#异常继承结构" class="headerlink" title="异常继承结构"></a>异常继承结构</h3><span id="more"></span>
<p><img src="/2021/08/01/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E8%A1%A5%E5%85%85/%E5%BC%82%E5%B8%B8%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png"></p>
<p>所有异常都是由Throwable继承而来。</p>
<p>要重点关注Exception层次结构，这个层次结构又分解为两个分支：一个分支派生于RuntimeException；另一个分支包含其他异常，一般规则是：由编程错误导致的异常属于RuntimeException；如果程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。</p>
<p>派生于RuntimeException的异常包括以下问题：</p>
<ul>
<li>错误的强制类型转换</li>
<li>数组访问越界</li>
<li>访问null指针</li>
</ul>
<p>不是派生于RuntimeException的异常包括：</p>
<ul>
<li>试图超越文件末尾继续读取数据</li>
<li>试图打开一个不存在的文件</li>
<li>试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在</li>
</ul>
<p>如果出现“RuntimeException异常，那么就一定是你的问题”，这个规则很有道理</p>
<p>java语言规范将派生于Error类或RuntimeException类的所有异常称为<code>非检查型异常</code>，所有其他的异常称为<code>检查型异常</code>。</p>
<p>一个方法必须声明所有可能抛出的<strong>检查型异常</strong>，而非检查型异常要么在你的控制之外，要么是由从一开始就应该避免的情况所导致的。如果你的方法没有抛出所有有可能出现的检查型异常，那么编译器会发出一个错误信息。</p>
<p>注意：如果子类覆盖了超类的一个方法，子类方法中声明的检查型异常不能比超类方法中声明的异常更通用，如果超类方法没有抛出任何检查型异常，子类也不能抛出任何检查型异常。而一个方法声明中抛出一个异常，而这个异常是某个特定类的实例，那么这个方法抛出的异常可能属于这个类，也可能属于这个类的任意一个子类。</p>
<h3 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h3><p>当你的代码遇到任何标准异常类都无法描述清楚的问题。这时创建自己的异常类就是一件顺理成章的事情了，我们需要做的只是定义一个派生于Exception的类，或者派生于Exception的某个子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileFormatException</span> <span class="keyword">extends</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">(String gripe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(gripe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//定义自己的异常类，然后就可以抛出</span></span><br><span class="line"><span class="function">String <span class="title">readData</span><span class="params">(BufferedReader in )</span> <span class="keyword">throws</span> FileFormatException</span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">while</span>(……)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileFormatException();</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.<span class="function">Throwable</span></span><br><span class="line"><span class="function">    <span class="title">Throwable</span><span class="params">()</span>：构造一个新的Throwable对象，但没有详细的描述信息</span></span><br><span class="line"><span class="function">    <span class="title">Throwable</span><span class="params">()</span>：构造一个新的Throwable对象，带有指定的详细描述信息</span></span><br><span class="line"><span class="function">    String <span class="title">getMessage</span><span class="params">()</span>：获得Throwable对象的详细描述信息</span></span><br></pre></td></tr></table></figure>

<h3 id="关于捕获异常的一些补充"><a href="#关于捕获异常的一些补充" class="headerlink" title="关于捕获异常的一些补充"></a>关于捕获异常的一些补充</h3><p>如果编写一个方法覆盖超类的方法，而这个超类方法没有抛出异常，你就必须捕获你的方法代码中出现的每一个检查型异常，不允许在子类的throws说明符中出现超类方法未列出的异常类。</p>
<h3 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h3><p>可以在catch子句中抛出一个异常。通常，希望改变异常的类型时会这么做，如果开发了一个供其他程序员使用的子系统，可以使用一个指示子系统故障的异常类型，这很有道理，ServeltException就是这样一个异常类型的例子，执行一个servlet的代码可能不想知道发生的错误的细节原因，但希望明确地知道servlet是否出现问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    acces the database</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">&quot;database error:&quot;</span>+e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，构造ServletException时提供了异常的消息文本</p>
<p>不过，可以有一种更好的处理方法，可以把原始异常设置新异常的“原因”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    access the database</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException original)&#123;</span><br><span class="line">    <span class="keyword">var</span> e = <span class="keyword">new</span> ServletException(<span class="string">&quot;database error&quot;</span>);</span><br><span class="line">    e.initCause(original);</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initCause()</code>这个方法就是对异常来进行包装，目的就是为了出了问题的时候能够追根究底，因为一个项目，越靠近底层，可能抛出的异常就越多，这时，在上层处理这些异常会非常麻烦，但如果对底层抛出的异常捕获后，抛出一个新的统一的异常，但这样会使原始的异常信息丢失，所以使用<code>initCause()</code>方法对异常进行包装，在未来的开发中可以使用<code>getCause()</code>方法获得原始的异常信息。</p>
<p>有时你可能只想记录一个异常，再将它重新抛出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    access the database</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    logger.log(level,message,e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java 7之前，这种方法存在一个问题，假设这个代码在以下方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updataRecord</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span></span><br></pre></td></tr></table></figure>

<p>编译器会跟踪到e来自try块，假设这个try块中仅有的检查型异常时SQLException实例，另外，假设e在catch块中未改变，将外围方法声明为throws SQLException就是合法的。</p>
<h3 id="try-with-Resources"><a href="#try-with-Resources" class="headerlink" title="try-with-Resources"></a>try-with-Resources</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">open the resource</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    work with the resource</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    close the resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开发中，一些打开的网络链接或者文件资源都需要程序员去手动调用close方法关闭，而忘记关闭可能会造成一些性能问题。</p>
<p>而如果打开了多个文件，则需要在finally子句中写入多个close方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ExceptionTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BufferedInputStream bin = <span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream bout = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">            bout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;out.txt&quot;</span>)));</span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bout.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>( bin != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bin.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bout != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bout.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>try-with-resources</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">要使用<span class="keyword">try</span>-with-resource的资源，必须先实现AutoCloseable接口，其中包含了单个返回<span class="keyword">void</span>的close方法，Java类库与第三方类库中的许多类和接口，现在都实现或扩展了AutoCloseable接口，因此我们现在不必实现了。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryWithResource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">       BufferedOutputStream bout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">      <span class="keyword">int</span> b;</span><br><span class="line">      <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个块正常退出时，或者存在一个异常时，都会调用close方法，就好像使用了finally块一样。</p>
<h3 id="使用异常的技巧"><a href="#使用异常的技巧" class="headerlink" title="使用异常的技巧"></a>使用异常的技巧</h3><ul>
<li>异常处理不能代替简单的测试</li>
<li>不要过分地细化异常</li>
<li>充分利用异常层次结构（不要只抛出RuntimeException异常，应该寻找一个适合的子类或创建自己的异常类。不要只捕获Throwable异常，否则，这会使你的代码更难读，更难维护）</li>
<li>不要压制异常</li>
<li>在检测错误时，“苛刻”要比放任更好</li>
<li>不要羞于传递异常</li>
</ul>
<p>（早抛出，晚捕获）</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>条件判断，循环语句以及函数</title>
    <url>/2021/07/29/%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%EF%BC%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul>
<li><p>[condition]（注意condition前后要有空格）非空返回true，可使用<code>$?</code>验证（0为true，&gt;1为false）</p>
<span id="more"></span>
<h3 id="常用判断条件"><a href="#常用判断条件" class="headerlink" title="常用判断条件"></a>常用判断条件</h3></li>
<li><p><code>=</code>：字符串比较</p>
</li>
</ul>
<p><strong>整数比较</strong></p>
<ul>
<li><code>-lt</code>：小于</li>
<li><code>-le</code>：小于等于</li>
<li><code>-eq</code>：等于</li>
<li><code>-gt</code>：大于</li>
<li><code>-ge</code>：大于等于</li>
<li><code>-ne</code>：不等于</li>
</ul>
<p><strong>文件权限判断</strong></p>
<ul>
<li><code>-r</code>：有读的权限</li>
<li><code>-w</code>：有写的权限</li>
<li><code>-x</code>：有执行的权限</li>
</ul>
<p><strong>按照文件类型进行判断</strong></p>
<p><code>-f</code>：文件存在并且是一个常规的文件</p>
<p><code>-e</code>：文件存在</p>
<p><code>-d</code>：文件存在并是一个目录</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>1、”ok”是否等于”ok”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [&quot;ok&quot; = &quot;ok&quot;]</span><br><span class="line">then</span><br><span class="line">		echo &quot;equal&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>2、23是否大于等于32</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [23 -ge 32]</span><br><span class="line">then</span><br><span class="line">		echo &quot;yes&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>3、<code>/root/shcode/aaa.txt</code>目录中的文件是否存在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [-f /root/shcode/aaa.txt]</span><br><span class="line">then</span><br><span class="line">		echo &quot;yes&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">代码</span><br><span class="line">elif [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>注意：[ 条件判断式 ]，中括号和条件判断式之间必须有空格</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $变量名 in </span><br><span class="line">&quot;值1&quot;)</span><br><span class="line">程序1</span><br><span class="line">;;</span><br><span class="line">&quot;值2&quot;)</span><br><span class="line">程序2</span><br><span class="line">;;</span><br><span class="line">……其他程序语句……</span><br><span class="line">*)</span><br><span class="line">程序</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3…</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>案例1：打印命令行输入的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">		echo &quot;num is $*&quot;</span><br><span class="line"><span class="meta">		#</span><span class="bash">$*会把参数当成一个整体，所以只输出一次</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bashfor i <span class="keyword">in</span> <span class="string">&quot;$*&quot;</span><span class="keyword">do</span>		<span class="built_in">echo</span> <span class="string">&quot;num is <span class="variable">$@</span>&quot;</span>		<span class="comment">#有几个参数就输出几次done</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((初始值;循环控制条件;变量变化))do程序done</span><br></pre></td></tr></table></figure>

<p>案例1：从一加到一百的值输出显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bashSUM=0;<span class="keyword">for</span> (( i=1;i&lt;=100;i++ ))<span class="keyword">do</span>		<span class="variable">$SUM</span>=$[<span class="variable">$SUM</span>+<span class="variable">$i</span>]doneecho <span class="string">&quot;<span class="variable">$SUM</span>&quot;</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]do程序done</span><br></pre></td></tr></table></figure>

<p>案例1：从命令行输入一个数n，统计从1+…+n的值是多少</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bashSUM=0i=0while [ <span class="variable">$i</span> -le <span class="variable">$1</span>]<span class="keyword">do</span>			SUM=$[<span class="variable">$SUM</span>+<span class="variable">$i</span>]			i=$[<span class="variable">$i</span>+1]doneecho <span class="string">&quot;<span class="variable">$SUM</span>&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h2><p><code>read (选项)(参数)</code></p>
<p><strong>选项</strong></p>
<ul>
<li><code>-p</code>：指定读取值时的提示符</li>
<li><code>-t</code>：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了</li>
</ul>
<p><strong>参数</strong></p>
<ul>
<li>变量：指定读取值的变量名</li>
</ul>
<p>案例1：读取控制台输入一个num值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bashread -p <span class="string">&quot;输入一个num值=&quot;</span> NUMecho <span class="string">&quot;NUM=<span class="variable">$NUM</span>&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>案例2：读取控制台输入一个num值，在10秒内输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bashread -t 10 -p <span class="string">&quot;输入一个num值=&quot;</span>   NUMecho <span class="string">&quot;NUM=<span class="variable">$NUM</span>&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><p>shell编程和其他编程语言一样，有系统函数，也可以自定义函数。</p>
<p><strong>basename：返回完整路径最后 / 的部分，常用于获取文件名</strong></p>
<ul>
<li><code>basename [pathname] [suffix]</code></li>
<li><code>basename [string] [suffix]</code>：basename命令会删掉所有的前缀包括最后一个（“  /  ”）字符，然后将字符串显示出来</li>
</ul>
<p><strong>选项</strong></p>
<ul>
<li><code>suffix</code>：如果被指定了，basename会将pathname或string中的suffix去掉</li>
</ul>
<p>案例1：返回<code>/home/aaa/test.txt</code>的“test.txt”部分</p>
<p><img src="/2021/07/29/%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%EF%BC%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0basename.png"></p>
<p><strong>dirname：返回完整路径最后 / 的前面的部分，常用于返回路径部分</strong></p>
<ul>
<li><code>dirname 文件绝对路径</code>：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））</li>
</ul>
<p>案例：返回<code>/home/aaa/test.txt</code>的<code>/home/aaa</code></p>
<p><img src="/2021/07/29/%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%EF%BC%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0dirname.png"></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[function] funname[()]&#123;	Action;	[return int;]&#125;</span><br></pre></td></tr></table></figure>

<p>调用直接写函数名：funname[值]</p>
<p>案例：计算输入两个参数的和，getSum</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bashfunction <span class="function"><span class="title">getSum</span></span>()&#123;		SUM=$[<span class="variable">$1</span>+<span class="variable">$2</span>]		<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SUM</span>&quot;</span>&#125;<span class="built_in">read</span> -p <span class="string">&quot;first=&quot;</span> n1read -p <span class="string">&quot;second=&quot;</span> n2getSum(<span class="variable">$n1</span>,<span class="variable">$n2</span>)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>查询基础</title>
    <url>/2021/07/05/%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="查询基础"><a href="#查询基础" class="headerlink" title="查询基础"></a>查询基础</h2><p>通过SELECT语句查询并选取出必要数据的过程称为匹配查询或查询。</p>
<p><code>SELECT &lt;列名&gt; FROM &lt;表名&gt;;</code></p>
<span id="more"></span>

<p>查询结果中列的顺序和SELECT子句中的顺序相同，如果想要查询出全部列，可以用星号（<code>*</code>）代替<code>列名</code>,</p>
<p>可以使用<code>&lt;列名&gt; as 别名</code>，在查询结果中，别名会代替列名（别名可以使用中文，使用中文时需要用双引号<code>&quot;&quot;</code>括起来）</p>
<h3 id="常数查询"><a href="#常数查询" class="headerlink" title="常数查询"></a>常数查询</h3><p>例如：<code>SELECT &#39;商品&#39; AS string, 38 AS number,&#39;2009-02-24&#39; AS date, product_id,product_name FROM Product</code>。这句SQL语句中，第一列商品为字符串常数，第二列38为数字常数，第三列为日期常数。</p>
<h3 id="结果删除重复行"><a href="#结果删除重复行" class="headerlink" title="结果删除重复行"></a>结果删除重复行</h3><p>使用<code>DISTINCT</code>来实现。如果一个表中的某个列拥有重复的数据，那么在查询语句中的列名前使用DISTINCT可以使查询结果只显示一个。</p>
<p><code>SELECT DISTINCT product_type FROM Product;</code></p>
<p>注意：</p>
<p>1、在使用DISTINCT时，NULL也被看作一类数据。如果NULL存在于多行，也会被合并成一条NULL数据。</p>
<p>2、DISTINCT关键字只能用在第一个列名之前</p>
<h3 id="选择记录"><a href="#选择记录" class="headerlink" title="选择记录"></a>选择记录</h3><p>使用<code>WHERE</code>可以指定查询数据的条件。</p>
<p><code>SELECT &lt;列名&gt; FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;;</code></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>1、<code>--</code>同一行</p>
<p>2、<code>/*   */</code>多行</p>
<h3 id="算术运算符和比较运算符"><a href="#算术运算符和比较运算符" class="headerlink" title="算术运算符和比较运算符"></a>算术运算符和比较运算符</h3><table>
<thead>
<tr>
<th>含义</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>加法运算</td>
<td>+</td>
</tr>
<tr>
<td>减法运算</td>
<td>-</td>
</tr>
<tr>
<td>乘法运算</td>
<td>*</td>
</tr>
<tr>
<td>除法运算</td>
<td>/</td>
</tr>
</tbody></table>
<p>算术运算符可以运用在WHERE后的条件表达式中，也可以运用在&lt;列名&gt;上。</p>
<p>注意：如果算术运算中包含NULL,那么结果肯定是NULL。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>和~~不相等</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
</tbody></table>
<p>在WHERE子句中通过比较运算符可以组合出各种各样的条件表达式</p>
<p>不能对NULL使用比较运算符</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th align="left">运算符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">not</td>
<td>非</td>
</tr>
<tr>
<td align="left">and</td>
<td>与</td>
</tr>
<tr>
<td align="left">or</td>
<td>或</td>
</tr>
</tbody></table>
<p>可以通过使用括号来增强逻辑表述</p>
<p>比较运算符不能使用NULL，而逻辑运算符也需要对NULL特殊对待</p>
<p>这时除了真假外第三种值——<strong>不确定（UNKNOWN）</strong>，与通常的逻辑运算被称为<strong>二值逻辑</strong>相对，只有SQL中的逻辑运算被称为<strong>三值逻辑</strong></p>
<table>
<thead>
<tr>
<th>AND</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>Q</td>
<td>P  AND  Q</td>
</tr>
<tr>
<td>真</td>
<td>真</td>
<td>真</td>
</tr>
<tr>
<td>真</td>
<td>假</td>
<td>假</td>
</tr>
<tr>
<td>真</td>
<td>不确定</td>
<td>不确定</td>
</tr>
<tr>
<td>假</td>
<td>真</td>
<td>假</td>
</tr>
<tr>
<td>假</td>
<td>假</td>
<td>假</td>
</tr>
<tr>
<td>假</td>
<td>不确定</td>
<td>假</td>
</tr>
<tr>
<td>不确定</td>
<td>真</td>
<td>不确定</td>
</tr>
<tr>
<td>不确定</td>
<td>假</td>
<td>假</td>
</tr>
<tr>
<td>不确定</td>
<td>不确定</td>
<td>不确定</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>OR</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>Q</td>
<td>P  OR  Q</td>
</tr>
<tr>
<td>真</td>
<td>真</td>
<td>真</td>
</tr>
<tr>
<td>真</td>
<td>假</td>
<td>真</td>
</tr>
<tr>
<td>真</td>
<td>不确定</td>
<td>真</td>
</tr>
<tr>
<td>假</td>
<td>真</td>
<td>真</td>
</tr>
<tr>
<td>假</td>
<td>假</td>
<td>假</td>
</tr>
<tr>
<td>假</td>
<td>不确定</td>
<td>不确定</td>
</tr>
<tr>
<td>不确定</td>
<td>真</td>
<td>真</td>
</tr>
<tr>
<td>不确定</td>
<td>假</td>
<td>不确定</td>
</tr>
<tr>
<td>不确定</td>
<td>不确定</td>
<td>不确定</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>线性表以及顺序存储结构</title>
    <url>/2021/07/22/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%BB%A5%E5%8F%8A%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>同一个问题可以有不同的表示（存储）方法</p>
<span id="more"></span>
<p><img src="/2021/07/22/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%BB%A5%E5%8F%8A%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8.png"></p>
<p>线性表(List)：具有相同特征的数据元素的一个有限序列。</p>
<ul>
<li>表中的元素个数称为线性表的长度</li>
<li>线性表没有元素时，称为空表</li>
<li>表的起始位置称为表头，表结束位置称为表尾</li>
</ul>
<p><img src="/2021/07/22/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%BB%A5%E5%8F%8A%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%80%BB%E8%BE%91%E9%A1%BA%E5%BA%8F.png"></p>
<p>线性表的抽象数据类型：</p>
<p>基本操作如下：</p>
<p><code>InitList(&amp;L)</code>：初始化线性表，构造一个空的线性表L。</p>
<p><code>DestroyList(&amp;L)</code>：销毁线性表，释放其占用的空间。</p>
<p><code>ListEmpty(L)</code>：判断线性表L是否为空表。</p>
<p><code>ListLength(L)</code>：返回线性表长度，等于线性表中元素的个数。</p>
<p><code>DispList(L)</code>：输出线性表，当线性表L不为空时顺序显示L中各节点的值域。</p>
<p><code>GetElem(L,i,&amp;e)</code>：求线性表中某个数据元素值，用e返回L中第i个元素的值。</p>
<p><code>LocatElem(L,e)</code>：按元素值查找，返回L中第一个值域与e相等的元素的序号，若这个元素不存在，则返回0。</p>
<p><code>ListInsert(&amp;L,i,e)</code>：插入数据元素，在L的第i个位置插入一个新的元素e，L的长度增加一。</p>
<p><code>ListDelete(&amp;L,i,&amp;e)</code>：删除数据元素，删除L的第i个元素，并用e返回其值，L的长度减一。</p>
<h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>线性表的顺序存储结构简称为顺序表。</p>
<p>利用数组的连续存储空间顺序存放线性表的各元素。</p>
<p><img src="/2021/07/22/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%BB%A5%E5%8F%8A%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E5%AD%98%E6%94%BE%E7%BA%BF%E6%80%A7%E8%A1%A8.png"></p>
<p>数组大小MaxSize一般定义为一个整型常量。注意：顺序表的表长在刚开始确定后就无法更改。</p>
<p>静态分配：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50;<span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];<span class="comment">//用静态的“数组”存放数据元素</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    L=(SqList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MaxSize));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">        L-&gt;date[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//赋默认值可以省略，但分配的空间内可能残留着其他数据</span></span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListEmpty</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L-&gt;length==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListLength</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispList</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L-&gt;length;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,L-&gt;data[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按位查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetElem</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>按值查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList *L,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;L-&gt;length &amp;&amp; L-&gt;data[i] != e)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=L-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList *&amp; L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span> || L-&gt;length == MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">for</span>(j=L-&gt;length;j&gt;i;j--)&#123;</span><br><span class="line">        L-&gt;data[j]=L-&gt;data[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i]=e;</span><br><span class="line">    L-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList *&amp;L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    i--;</span><br><span class="line">    e=L-&gt;data[i];</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;L-&gt;length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        L-&gt;data[j]=L-&gt;data[j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态分配以及扩展线性表的长度：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> InitSize 10<span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;<span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;<span class="comment">//顺序表的类型定义（动态分配方式）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> *data;</span><br><span class="line">	<span class="keyword">int</span> MaxSize;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span></span>&#123;</span><br><span class="line">	L.data=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseSize</span><span class="params">(SeqList &amp;L，<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *p=L.data;</span><br><span class="line">	L.data=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(L.MaxSize + len)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">		L.data[i]=p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	L.MaxSize=L.MaxSize+len;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SeqList L;</span><br><span class="line">	InitList(L);</span><br><span class="line">	IncreaseSize(L,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>绪论</title>
    <url>/2021/07/20/%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<p>数据结构通常包括以下几个方面：</p>
<ul>
<li>数据的逻辑运算：有数据元素之间的逻辑关系构成</li>
<li>数据的存储结构：数据元素以及关系在计算机存储器中的存储表示，也称为数据的物理结构</li>
<li>数据的运算：施加在该数据上的操作<span id="more"></span>
例如：写一个函数PrintN，使得传入一个正整数为N的参数后，能顺序打印从1到N的全部正整数。</li>
</ul>
<p>循环实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintN</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintN</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(N)&#123;</span><br><span class="line">		PrintN(N<span class="number">-1</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当N足够大时，循环可以实现，但递归可能出错。</p>
<p>c语言中有专门的计时函数：<code>clock()</code>：捕捉从程序开始运行到<code>clock()</code>被调用时所耗费的时间，这个时间单位时<code>clock tick</code>即“时钟打点”</p>
<p>常数<code>CLK_TCK</code>：机器时钟每秒所走的时钟打点数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">clock_t</span> start,stop;<span class="comment">//clock_t时clock()函数返回的变量类型</span></span><br><span class="line"><span class="keyword">double</span> duration;<span class="comment">//记录被测函数运行时间，以秒为单位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    start=clock();<span class="comment">//开始计时</span></span><br><span class="line">    MyFunction();<span class="comment">//测试函数</span></span><br><span class="line">    stop=clock();</span><br><span class="line">    duration=((<span class="keyword">double</span>)(stop-start))/CLK_TCK;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>抽象数据类型指的是用户进行软件系统设计时从问题的数学模型中抽象出来的逻辑数据结构和逻辑数据结构上的运算，从不考虑计算机的具体存储结构和运算的具体实现算法。</p>
<p>抽象数据类型的基本描述格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型</span><br><span class="line">&#123;  数据对象：数据对象的声明</span><br><span class="line">   数据关系：数据关系的声明</span><br><span class="line">   基本运算：基本运算的声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，基本运算的声明格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本运算名（参数表）：运算功能描述</span><br></pre></td></tr></table></figure>

<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><code>程序=数据结构+算法</code>：数据结构是要处理的细信息，算法是处理信息的步骤。</p>
<ul>
<li>有穷性：一个算法必须总是（对任何合法的输入值）在执行有穷步之后结束，且每一步都可在有穷时间内完成。注意：算法必须是有穷的，而程序可以是无穷的。</li>
<li>确定性：算法中每条指令必须有确切的含义，对于相同是输入只能得出相同是输出。</li>
<li>可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</li>
<li>输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合</li>
<li>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</li>
</ul>
<h4 id="算法设计的目标"><a href="#算法设计的目标" class="headerlink" title="算法设计的目标"></a>算法设计的目标</h4><ul>
<li>可读性：算法应具有良好的可读性，以帮助人们理解</li>
<li>健壮性：算法具有良好的容错性，即提供异常处理。</li>
<li>正确性：算法能正确的执行预先规定的功能和性能要求</li>
<li>可使用性：能够方便地使用</li>
<li>高效率与低存储量需求：通常算法的效率主要指算法的执行时间，对于同一个问题，如果有多种算法可以求解，执行时间短的算法效率高，算法存储量指的是算法执行过程中所需的最大存储空间，效率和存储量都与问题的规模有关。</li>
</ul>
<h4 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h4><p>事后统计法：编写算法后运行，统计其运行时间，限制较大且有大量外部因素影响。</p>
<p>事前估算法：撇开计算机硬件，软件，使用的语言等有关因素，仅考虑算法本身的效率高低，可以认定算法的时间开销<code>T(n)</code>与问题规模<code>n</code>有关系。</p>
<p>例如:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintN</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;<span class="comment">//执行一次</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;<span class="comment">//执行3001次</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d次\n&quot;</span>,i);<span class="comment">//循环语句内执行3000次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超过%d\n&quot;</span>,n);<span class="comment">//执行一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	PrintN(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以T(200)=1+3001+2*3000+1,时间开销与问题规模n的关系为：T(n)=3n+3</p>
<p>有三个关系：<code>T(n)=3n+3</code>,<code>T(n)=n^2+3n+1000</code>,<code>T(n)=n^3+n^2+999999</code>,当n足够大的时候，可以忽略关系中的常数和低阶，只保留高阶的部分。即为<code>T(n)=3n=O(n)</code>,<code>T(n)=n^2=O(n^2)</code>,<code>T(n)=n^3=O(n^3)</code>。</p>
<p><strong>加法规则</strong></p>
<p><code>T(n)=T(n)+T(n)=O(f(n)+O(g(n))=O(max(f(n),g(n)))</code>即多项相加，只保留最高阶的项，且系数变为1。</p>
<p><strong>乘法规则</strong></p>
<p><code>T(n)=T(n)*T(n)=O(f(n))*O(g(n))=O(f(n)*g(n))</code>即多项相乘，都保留</p>
<p><strong>阶数相比</strong>：（常对幂指阶）</p>
<p><img src="/2021/07/20/%E7%BB%AA%E8%AE%BA/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png"></p>
<p>如果代码过多，顺序执行的代码只会影响常数项，可以忽略。只需挑循环中的一个基本操作分析它的执行次数与n的关系即可。如果有多层嵌套循环，只需关注最深层循环循环了几次。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintN</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;<span class="comment">//执行一次</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;<span class="comment">//执行3001次</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d次\n&quot;</span>,i);<span class="comment">//循环语句内执行3000次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;内循环执行&quot;</span>);<span class="comment">//内层循环执行n^2次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超过%d\n&quot;</span>,n);<span class="comment">//执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时：<code>T(n)=O(n)+O(n^2)=O(n^2)</code></p>
<p><strong>搜索数字型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">locate</span><span class="params">(<span class="keyword">int</span> flag[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aaaaa&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i]==n)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;第%d个&quot;</span>,n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算上述算法的时间复杂度T(n)</p>
<ul>
<li>最好情况：元素n在第一个位置（<code>T(n)=O(1)</code>)</li>
<li>最坏情况：元素n在最后一个位置（<code>T(n)=O(n)</code>）</li>
<li>平均情况：假设元素n在任意一个位置的概率相同为1/n（<code>T(n)=O(n)</code>）</li>
</ul>
<p>最坏时间复杂度：最坏情况下算法的时间复杂度</p>
<p>平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间</p>
<p>注意：算法的性能问题只有在n很大时才会暴露出来</p>
<h4 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h4><p>一个算法的存储量包括输入数据所占的空间、程序本身所占的空间和临时变量所占的空间。</p>
<p>算法空间复杂度是对一个算法在运行过程中临时占用的存储空间大小的量度。<code>S(n)=O(g(n))</code></p>
<p>若所需临时空间相对于问题规模来说是常数，则称算法为原地工作算法或就地工作算法。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2021/07/02/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20013%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89/</url>
    <content><![CDATA[<p>1、类和类之间叫做继承，类和接口之间叫做实现。继承使用extends关键字完成，实现使用implements关键字完成</p>
<p>2、当一个非抽象的类实现接口的话，必须将接口中所有的抽象方法全部实现（覆盖/重写）</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> PI=<span class="number">3.1415926</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个抽象类中可以有抽象方法</span></span><br><span class="line"><span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">MyMathImpl01</span> <span class="keyword">implements</span>  <span class="title">MyMath</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个普通的类，则需要实现（重写/覆盖)接口里的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMathImpl</span> <span class="keyword">implements</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、接口中的方法都是public，所以实现（重写/覆盖）时必须加public</p>
<p>4、可以使用多态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyMath mm=<span class="keyword">new</span> MyMathImpl();</span><br><span class="line">        <span class="keyword">int</span> result_sum=mm.sum(<span class="number">20</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> result_sub=mm.sub(<span class="number">20</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum &quot;</span>+result_sum+<span class="string">&quot;   sub &quot;</span>+result_sub);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、一个类可以实现多个接口,但必须重写接口中所有抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">B2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">C2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D3</span> <span class="keyword">implements</span> <span class="title">A2</span>,<span class="title">B2</span>,<span class="title">C2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    B2 b1=(B2) a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、接口和接口之间在进行强制类型转换的时候，没有继承关系，也可以强转，（但运行时可能会出现ClassCastException异常）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        M m=<span class="keyword">new</span> E();</span><br><span class="line">        <span class="keyword">if</span>(m <span class="keyword">instanceof</span> K)&#123;</span><br><span class="line">            K k=(K) m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">K</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">M</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> <span class="keyword">implements</span> <span class="title">M</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：接口之间没有继承关系也可以强转</strong></p>
<p>7、继承和实现同时存在，extends关键字在前，implements在后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Flyable f=<span class="keyword">new</span> Cat01();</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal01</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat01</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口在开发中的作用"><a href="#接口在开发中的作用" class="headerlink" title="接口在开发中的作用"></a>接口在开发中的作用</h4><p>接口在开发中的作用类似于多态在开发中的作用。</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>final关键字、抽象类和接口的区别</title>
    <url>/2021/07/02/%E8%BF%9B%E9%98%B6%E7%AF%87%20%20Day%20012%EF%BC%88final%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%BB%A5%E5%8F%8A%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E6%8E%A5%E5%8F%A3%EF%BC%89/</url>
    <content><![CDATA[<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>1、final是java语言中第一个关键字，<br>       2、final表示最终的，不可变的<br>       3、final可以修饰变量以及方法，还有类等<br>       4、fianl修饰的类，则该类无法继承。（绝育）</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">//B类继承A类，相当于对A类的功能进行扩展，如果你不希望别人对A类进行拓展，可以给A类加final关键字，如果给A类添加final关键字，则没有类可以继承A类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上编译出错</span><br></pre></td></tr></table></figure>

<p>5、final修饰的方法，无法被覆盖，被重写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C.doSome&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D.doSome&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上编译出错</span><br></pre></td></tr></table></figure>

<p>6、final修饰的变量，一旦赋值（定义后允许第一次赋值）则不能重新赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i =<span class="number">100</span>;</span><br><span class="line">        i=<span class="number">200</span>;<span class="comment">//出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、final修饰引用，该引用只能指向一个对象，并且不能更改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest02</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p1=<span class="keyword">new</span> Person(<span class="number">20</span>);</span><br><span class="line">        System.out.println(p1.age);</span><br><span class="line">        <span class="keyword">final</span> Person p2=<span class="keyword">new</span> Person(<span class="number">30</span>);</span><br><span class="line">        p=<span class="keyword">new</span> Person(<span class="number">30</span>);<span class="comment">//出错，p只能赋值一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、final修饰实例变量，系统不管赋默认值，要求程序员必须手动赋值，在定义变量时可以，也能在构造方法中赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest03</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age=<span class="number">10</span>;<span class="comment">//final修饰的变量只能赋值一次，如果不在此处赋值，那么在主程序调用的话，系统就赋默认值，且不能修改。所以必须在此处手动赋值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight=<span class="number">80</span>;<span class="comment">//不会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fianl修饰的实例变量一般添加static修饰</p>
<p><strong>static final联合修饰的变量称为“常量”</strong>，变量名建议大写</p>
<h2 id="抽象类和接口以及两者的区别"><a href="#抽象类和接口以及两者的区别" class="headerlink" title="抽象类和接口以及两者的区别"></a>抽象类和接口以及两者的区别</h2><h3 id="抽象类和接口之间的区别"><a href="#抽象类和接口之间的区别" class="headerlink" title="抽象类和接口之间的区别"></a>抽象类和接口之间的区别</h3><p>1、抽象类是半抽象的    接口是完全抽象的</p>
<p>2、抽象类中有构造方法   接口中没有构造方法</p>
<p>3、接口和接口之间支持多继承    类和类之间只能单继承</p>
<p>4、一个类可以同时实现多个接口    一个抽象类只能继承一个类</p>
<p>5、接口中只允许出现常量和抽象方法</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>1、抽象类是类和类之间有共同特征，将这些具有共同特征的类再进一步抽象形成了抽象类，由于基本类本身是不存在的，所以抽象类无法创建对象。</p>
<p>2、抽象类和抽象类实际上可能还会有共同特征，还可以进一步再抽象</p>
<p>3、抽象类也属于引用数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    类体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、抽象类是无法实例化，无法创建对象，<strong>所以抽象类是用来被子类继承的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account01 act01=<span class="keyword">new</span> Account01();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Account01</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Error:(<span class="number">3</span>, <span class="number">25</span>) java: Account01是抽象的; 无法实例化</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CreditAccount01 act01=<span class="keyword">new</span> CreditAccount01();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Account01</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类继承抽象类，子类可以实例化对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditAccount01</span> <span class="keyword">extends</span> <span class="title">Account01</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：abstract和final是非法的修饰符组合</strong></p>
<p>5、抽象类的子类也可以是抽象类</p>
<p>6、抽象类虽然无法实例化，但抽象类有构造方法，这个构造方法是让子类使用的</p>
<p>7、抽象类关联到一个概念：抽象方法</p>
<p>抽象方法表示没有实现的方法，没有方法体的方法。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>特点：没有方法体，以分号结尾，前修饰符列表中有abstract</p>
<p>8、抽象类中不一定有抽象方法。但抽象方法一定在抽象类中。</p>
<h4 id="非抽象类继承抽象类"><a href="#非抽象类继承抽象类" class="headerlink" title="非抽象类继承抽象类"></a><strong>非抽象类继承抽象类</strong></h4><p>当非抽象类子类继承抽象父类的抽象方法时，需要将抽象方法进行覆盖/重写（一个非抽象类的继承抽象类，要求将抽象类中的抽象方法覆盖/重写。如果一个抽象类继承了一个抽象类，则抽象方法不用覆盖/重写）</p>
<p>1、父类型引用指向子类型对象，向上转型，使用多态</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p> 1、接口也是一种引用数据类型</p>
<p>2、接口是完全抽象的。（抽象类是半抽象）</p>
<p>3、语法结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>4、接口支持多继承，一个接口可以继承多个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个接口可以继承多个接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C1</span> <span class="keyword">extends</span> <span class="title">A1</span>,<span class="title">B1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、接口中有常量和抽象方法，当定义抽象方法时，在编写代码时， public abstract 可以省略。接口中的抽象方法同样不能带有方法体。</p>
<p>6、接口中定义一个变量，则认定为是常量</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>package和import机制，Scanner，访问控制权限</title>
    <url>/2021/07/02/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20014%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81package%E5%92%8Cimport%E6%9C%BA%E5%88%B6%E3%80%81%E8%A7%A3%E9%87%8AScanner%E3%80%81%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%EF%BC%89/</url>
    <content><![CDATA[<h2 id="package和import机制"><a href="#package和import机制" class="headerlink" title="package和import机制"></a>package和import机制</h2><p>1、package是java语言中的包机制，包机制的作用是为了方便程序管理。不同功能的类分别存放在不同的包下，不同的软件包具有不同的功能</p>
<span id="more"></span>

<p>2、package是一个关键字，后面加包名，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.javase.chapter17;</span><br></pre></td></tr></table></figure>

<p>注意：package语句只允许出现在java源代码的第一行</p>
<p>3、包名命名规范：一般采用公司域名倒叙的方式</p>
<p>​              公司域名倒叙+项目名+模块名+功能名</p>
<p>4、对于带有package的java程序</p>
<p>​      在idea中：src   new  package</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffypower.javaSE.Test03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffypower.javaSE.Test03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        com.ffypower.javaSE.Test03.HelloWorld t1=<span class="keyword">new</span> com.ffypower.javaSE.Test03.HelloWorld();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>import 包名，可以导入对应的包，创建包内对象时可以不用写包名</p>
<h3 id="总结：package和import"><a href="#总结：package和import" class="headerlink" title="总结：package和import"></a>总结：package和import</h3><p>package</p>
<p>1、package出现在java源文件第一行</p>
<p>2、带有包名编译：javac -d . xxx.java</p>
<p>3、运行：java 完整类名</p>
<p>import</p>
<p>1、java.lang不需要，同包下不需要，其他都需要</p>
<p>2、import 完整类名;   /    import 包名.*;</p>
<h3 id="解释Scanner"><a href="#解释Scanner" class="headerlink" title="解释Scanner"></a>解释Scanner</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffypower.javaSE.Test03;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        java.util.Scanner s=<span class="keyword">new</span> java.util.Scanner(System.in);</span><br><span class="line">        String str=s.next();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Test03类和Scanner类不在同一个包中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffypower.javaSE.Test03;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner x=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str1=x.next();</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问控制权限"><a href="#访问控制权限" class="headerlink" title="访问控制权限"></a>访问控制权限</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//受保护的</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//公开的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="comment">//默认的</span></span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、private表示私有的，只能在本类中访问</p>
<p>2、public表示公开的，在任何位置都可以访问</p>
<p>3、protected表示只能在本类，同包，子类中访问</p>
<p>4、“默认”表示只能在本类，以及同包下访问</p>
<p><img src="/2021/07/02/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20014%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81package%E5%92%8Cimport%E6%9C%BA%E5%88%B6%E3%80%81%E8%A7%A3%E9%87%8AScanner%E3%80%81%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%EF%BC%89/Users\樊飞扬\AppData\Roaming\Typora\typora-user-images\image-20210121165710891.png" alt="image-20210121165710891"></p>
<p>属性（都可以）   方法（都可以）  类（public和默认）接口（public和默认）</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>JDK类库的根类:Object以及常用方法</title>
    <url>/2021/07/02/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20015%EF%BC%88JDK%E7%B1%BB%E5%BA%93%E7%9A%84%E6%A0%B9%E7%B1%BB%EF%BC%9AObject%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="源码及API文档概述"><a href="#源码及API文档概述" class="headerlink" title="源码及API文档概述"></a>源码及API文档概述</h2><h3 id="JDK类库的根类：Object"><a href="#JDK类库的根类：Object" class="headerlink" title="JDK类库的根类：Object"></a>JDK类库的根类：Object</h3><p>1、这些方法都是所有子类通用的，任何一个类默认继承Objcet，就算没有继承，也会间接继承。</p>
<span id="more"></span>
<p>API：应用程序编程接口（Application Program Interface)，整个JDK的类库就是一个javaSE的API。每一个API都会配置一套API帮助文档</p>
<p><strong>protected Object clone() //负责对象克隆的</strong></p>
<p><strong>int  hashCode()  //获取对象哈希码的一个方法</strong></p>
<p><strong>boolean equals (Object obj) //判断两个对象是否相等</strong></p>
<p><strong>String toString()  //将对象转换成字符串</strong></p>
<h3 id="关于Object类中的toString方法"><a href="#关于Object类中的toString方法" class="headerlink" title="关于Object类中的toString方法"></a>关于Object类中的toString方法</h3><p>1、源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName()+<span class="string">&quot;@&quot;</span>+Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类名+@+对象的内存地址转换为十六进制的形式</p>
<p>2、SUN公司实际toString()方法的目的：通过调用toString()方法可以将一个”java对象“转换成字符串表示形式。建议其所有子类都去重写toString()方法。toString()方法应该有一个简洁，可读性强的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> About_toString_tech;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">toStringTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date day1=<span class="keyword">new</span> Date(<span class="number">2021</span>,<span class="number">1</span>,<span class="number">22</span>);</span><br><span class="line">        System.out.println(day1);<span class="comment">//System.out.println(day1.toString)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.year=year;</span><br><span class="line">        <span class="keyword">this</span>.month=month;</span><br><span class="line">        <span class="keyword">this</span>.day=day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.year+<span class="string">&quot;年&quot;</span>+<span class="keyword">this</span>.month+<span class="string">&quot;月&quot;</span>+<span class="keyword">this</span>.day+<span class="string">&quot;日&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2021</span>年<span class="number">1</span>月<span class="number">22</span>日</span><br></pre></td></tr></table></figure>

<p>注意：输出引用时，将自动调用该引用的toString()方法，（toString方法都要重写）</p>
<h3 id="关于Object类中的equals方法"><a href="#关于Object类中的equals方法" class="headerlink" title="关于Object类中的equals方法"></a>关于Object类中的equals方法</h3><p>1、源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="keyword">this</span>==obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、以后的编程中，通过equals方法来判断<strong>两个对象</strong>是否相等，</p>
<p>3、在Object类中的equals方法当中，默认采用的是”==“判断两个Java对象是否相等，而”==“判断的是两个对象的内存地址，而我们需要判断的是对象的内容，所以equals方法不够用，<strong>需要在子类中重写equals</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> About_equals_tech;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date01 day2=<span class="keyword">new</span> Date01(<span class="number">2021</span>,<span class="number">1</span>,<span class="number">22</span>);</span><br><span class="line">        Date01 day3=<span class="keyword">new</span> Date01(<span class="number">2021</span>,<span class="number">1</span>,<span class="number">22</span>);</span><br><span class="line">        System.out.println(day2.equals(day3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date01</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date01</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.year=year;</span><br><span class="line">        <span class="keyword">this</span>.month=month;</span><br><span class="line">        <span class="keyword">this</span>.day=day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> year1=<span class="keyword">this</span>.year;</span><br><span class="line">        <span class="keyword">int</span> month1=<span class="keyword">this</span>.month;</span><br><span class="line">        <span class="keyword">int</span> day1=<span class="keyword">this</span>.day;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Date01)&#123;</span><br><span class="line">            Date01 date01=(Date01)obj;</span><br><span class="line">            <span class="keyword">int</span> year2=date01.year;</span><br><span class="line">            <span class="keyword">int</span> month2=date01.month;</span><br><span class="line">            <span class="keyword">int</span> day2=date01.day;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (year1==year2 &amp;&amp; month1==month2 &amp;&amp; day1==day2)&#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>注意：如果两个对象的一个对象为null，不出错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Dateo1))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断完以上条件，就可以直接向下转型，不用判断</span></span><br><span class="line">    Date01 date01=(Date01)obj;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.year==date01.year &amp;&amp; <span class="keyword">this</span>.month==date01.month &amp;&amp; <span class="keyword">this</span>.day==date01.day)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用IDEA生成equals方法</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>重写toString和equals(String类和Object类)</title>
    <url>/2021/07/02/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20016%EF%BC%88String%E7%B1%BB%E9%87%8D%E5%86%99%E4%BA%86toString%E5%92%8Cequals%E3%80%81%E9%87%8D%E5%86%99Object%E7%B1%BB%E4%B8%AD%E7%9A%84equals%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="String类重写了toString和equals"><a href="#String类重写了toString和equals" class="headerlink" title="String类重写了toString和equals"></a>String类重写了toString和equals</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str1=<span class="string">&quot;123&quot;</span>;<span class="comment">//String str1 =new String(&quot;123&quot;);</span></span><br><span class="line">        String str2=<span class="string">&quot;234&quot;</span>;</span><br><span class="line">        <span class="comment">//String是一个类，属于引用数据类型</span></span><br><span class="line">        <span class="keyword">boolean</span> flag=str1.equals(str2);</span><br><span class="line">        System.out.println(flag)</span><br><span class="line">        System.out.println(str1.toString())<span class="comment">//System.out.println(str1) 自动调用toString()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>比较两个字符串，不可以使用“==”，必须调用equals方法</p>
<p><strong>注意：</strong></p>
<p>1、String类已经重写了equals方法，所以比较字符串是否相等时，可以直接使用equals方法</p>
<p>2、String类已经重写了toString方法，所以可以直接输出</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>基本数据类型使用”==“判断是否相等，而引用数据类型需要使用equals方法</p>
<h2 id="重写Object类中的equals方法"><a href="#重写Object类中的equals方法" class="headerlink" title="重写Object类中的equals方法"></a>重写Object类中的equals方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">School_Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student a1=<span class="keyword">new</span> Student(<span class="number">001</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        Student a2=<span class="keyword">new</span> Student(<span class="number">001</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(a1.equasl(a2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String school;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id,String school)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">        <span class="keyword">this</span>.school=school;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span> <span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj==<span class="keyword">null</span> &amp;&amp; !(obj <span class="keyword">instanceof</span> Student))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>==obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Student s1=(Student)obj;</span><br><span class="line">        <span class="keyword">if</span> (s1.id==<span class="keyword">this</span>.id &amp;&amp; <span class="keyword">this</span>.school.equals(s1.school))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>equals方法、Object类中的hashCode方法、匿名内部类</title>
    <url>/2021/07/02/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20017%EF%BC%88equals%E6%96%B9%E6%B3%95%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%90%86%E8%A7%A3%E3%80%81Object%E7%B1%BB%E4%B8%AD%E7%9A%84hashCode%E6%96%B9%E6%B3%95%E3%80%81%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/</url>
    <content><![CDATA[<h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equals_Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User a1=<span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="keyword">new</span> Address(<span class="string">&quot;邯郸&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;001&quot;</span>));</span><br><span class="line">        User a2=<span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="keyword">new</span> Address(<span class="string">&quot;邯郸&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;001&quot;</span>));</span><br><span class="line">        System.out.println(a1.equals(a2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address addr;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name,Address addr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.addr=addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj==<span class="keyword">null</span> || !(obj <span class="keyword">instanceof</span> User)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        User u=(User)obj;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name.equals(u.name) &amp;&amp; <span class="keyword">this</span>.addr.equals(u.addr))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>&#123;</span><br><span class="line">    String city;</span><br><span class="line">    String stree;</span><br><span class="line">    String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String city,String stree,String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city=city;</span><br><span class="line">        <span class="keyword">this</span>.stree=stree;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj==<span class="keyword">null</span> || !(obj <span class="keyword">instanceof</span> Address)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Address a=(Address)obj;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.city.equals(a.city) &amp;&amp; <span class="keyword">this</span>.stree.equals(a.stree) &amp;&amp; <span class="keyword">this</span>.id.equals(a.id))&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="Object类中的hashCode方法"><a href="#Object类中的hashCode方法" class="headerlink" title="Object类中的hashCode方法"></a>Object类中的hashCode方法</h2><p>1、源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>带有native关键字，底层调用C++程序。</p>
<p>2、返回的是哈希码，实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值，可以等同看作一个java对象的内存地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashCode_Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTime m1=<span class="keyword">new</span> MyTime();</span><br><span class="line">        <span class="keyword">int</span> a=m1.hashCode();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTime</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">460141958</span></span><br></pre></td></tr></table></figure>

<h2 id="内部类概述"><a href="#内部类概述" class="headerlink" title="内部类概述"></a>内部类概述</h2><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>1、内部类：在的类的内部又定义了一个新的类，称为内部类</p>
<p>2、分为：静态内部类（类似于静态变量）</p>
<p>​                 实例内部类（类似于实例变量）</p>
<p>​                 局部内部类（类似于局部变量）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test01</span></span>&#123;</span><br><span class="line">    <span class="comment">//类在类的内部，称为内部类</span></span><br><span class="line">    <span class="comment">//因为前又修饰符static，称为“静态内部类”</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有static称为实例内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner02</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner3</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用内部类编写的代码可读性较差，能不用尽量不要用</p>
<p>4、匿名内部类是局部内部类的一种，因为这个类没有名。</p>
<p>5、匿名内部类只能使用一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mySum</span><span class="params">(Computer c,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> retValue=c.sum(x,y);</span><br><span class="line">        System.out.println(retValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyMath mm=<span class="keyword">new</span> MyMath();</span><br><span class="line">        mm.mySum(<span class="keyword">new</span> Computer()&#123;<span class="comment">//alt+回车，纠正错误</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a+b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">300</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>一维数组</title>
    <url>/2021/07/02/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20018%EF%BC%88%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一维数组概述"><a href="#一维数组概述" class="headerlink" title="一维数组概述"></a>一维数组概述</h2><p>1、java语言中的数组是一种<strong>引用数据类型</strong>，数组的父类是Object。</p>
<p>2、因为数组是引用类型，所以数组对象是堆内存当中。</p>
<p>3、数组当中如果存储的为“对象”时，实际上存储的为对象的“引用”（内存地址）</p>
<span id="more"></span>

<p>4、数组一旦创建，长度不可变</p>
<p>5、数组分为：一维数组，二维数组，多维数组……</p>
<p>6、所有的数组对象都哟length属性，用来获取数组中元素的个数</p>
<p>7、java的数组要求数组中元素的类型统一</p>
<p>8、数组在内存方面存储的时候，数组中的元素内存地址时连续的</p>
<p>9、数组都是拿第一个元素的内存地址作为整个数组的内存地址</p>
<p>10、下标从0开始，最后一个元素的下标是“length-1”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1;</span><br><span class="line"><span class="keyword">double</span>[] array2;</span><br><span class="line"><span class="keyword">boolean</span>[] array3;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>11、初始化一个一维数组，包括两种方式：静态初始化一维数组，动态初始化一维数组</p>
<p>静态初始化语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,&#125;;</span><br></pre></td></tr></table></figure>

<p>动态初始化语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//5表示数组的元素个数</span></span><br></pre></td></tr></table></figure>

<h3 id="对数组内元素的访问"><a href="#对数组内元素的访问" class="headerlink" title="对数组内元素的访问"></a>对数组内元素的访问</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array01=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(array01.length);</span><br><span class="line">        System.out.println(array01[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(array01[array01.length-<span class="number">1</span>]);</span><br><span class="line">        array01[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        System.out.println(array01[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>方法的参数是数组</title>
    <url>/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20019%EF%BC%88%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%89/</url>
    <content><![CDATA[<h2 id="方法的参数是数组"><a href="#方法的参数是数组" class="headerlink" title="方法的参数是数组"></a>方法的参数是数组</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array01=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        printArray(array01);</span><br><span class="line">        <span class="keyword">int</span>[] array02=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        printArray(array02);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]);</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>main方法中的String数组，数组的扩容、拷贝以及二维数组</title>
    <url>/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20020%EF%BC%88main%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84String%E6%95%B0%E7%BB%84%E3%80%81%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9%E3%80%81%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%89/</url>
    <content><![CDATA[<p>1、JVM调用main方法，会自动传一个String数组过来，长度为args.length。 默认长度为0</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">System01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(args.length==<span class="number">2</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String username=args[<span class="number">0</span>];</span><br><span class="line">    String passwork=args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (username.equals(<span class="string">&quot;zhangsan&quot;</span>) &amp;&amp; passwork.equals(<span class="string">&quot;123&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组中存储引用数据类型"><a href="#数组中存储引用数据类型" class="headerlink" title="数组中存储引用数据类型"></a>数组中存储引用数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal a1=<span class="keyword">new</span> Animal();</span><br><span class="line">        Animal a2=<span class="keyword">new</span> Animal();</span><br><span class="line">        Animal[] animals=&#123;a1,a2&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;animals.length;i++)&#123;</span><br><span class="line">            animal[i].move;</span><br><span class="line">            &#125;</span><br><span class="line">        Animal ans=<span class="keyword">new</span> Animal[<span class="number">4</span>];</span><br><span class="line">        ans[<span class="number">0</span>]=<span class="keyword">new</span> Animal();</span><br><span class="line">        abs[<span class="number">1</span>]=<span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal move!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat move&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h3><p>1、对数组的扩容：先新建一个大容量的数组，将小容量数组一个一个拷贝到数组当中，（在开发中应尽量减少数组的扩容次数）</p>
<h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest01</span></span>&#123;</span><br><span class="line">    <span class="comment">//拷贝源</span></span><br><span class="line">    <span class="keyword">int</span>[] src=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//拷贝目标</span></span><br><span class="line">    <span class="keyword">int</span>[] dest=<span class="keyword">new</span> dest[<span class="number">20</span>];</span><br><span class="line">    System.arraycopy(src,<span class="number">1</span>,dest,<span class="number">3</span>,<span class="number">2</span>);<span class="comment">//(源数组，开始拷贝的位置，目标数组，拷贝多少个)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dest.length;i++)&#123;</span><br><span class="line">        System.out.println(dest[i])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>1、二维数组就是一个特殊的一维数组，因为在这个特殊的一维数组中的每个元素都是一个一维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] a=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(array[<span class="number">0</span>].length);</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="二维数组元素访问"><a href="#二维数组元素访问" class="headerlink" title="二维数组元素访问"></a>二维数组元素访问</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="keyword">int</span> a=array[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String[][] array=&#123;&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;,&#123;<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>&#125;,&#123;<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            String[] a1=array[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a1.length;j++)&#123;</span><br><span class="line">                System.out.println(al[j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String[][] array=&#123;&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;,&#123;<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>&#125;,&#123;<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;array[i].length;j++)&#123;</span><br><span class="line">                System.out.println(array[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的参数是一个二维数组"><a href="#方法的参数是一个二维数组" class="headerlink" title="方法的参数是一个二维数组"></a>方法的参数是一个二维数组</h3><p>动态初始化二维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">4</span>];<span class="comment">//三个一维数组，每个一维数组有四个元素</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">        arrayPrint(array);<span class="comment">//arrayPrint(new int[][]&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrayPrint</span><span class="params">(<span class="keyword">int</span>[][] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;array[i].length;j++)&#123;</span><br><span class="line">                System.out.print(array[i][j]+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  </span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  </span><br><span class="line"><span class="number">2</span>  <span class="number">35</span>  <span class="number">5</span>  <span class="number">3</span>  </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print()<span class="comment">//不换行</span></span><br><span class="line">System.out.println()<span class="comment">//换行</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>两个练习</title>
    <url>/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20021%EF%BC%88%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88%E3%80%81%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h2><span id="more"></span>

<p>1、这个栈中可以存储引用数据类型</p>
<p>2、在栈中提供push方法模拟压栈</p>
<p>3、在栈中提供pop方法模拟弹栈</p>
<p>4、编写测试程序，new栈对象，调用push pop方法来模拟压栈弹栈的动作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//向栈中存储元素，因为Object类可以存储任何引用类型的数据</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elements=<span class="keyword">new</span> Object[<span class="number">10</span>];<span class="comment">//默认初始化数组容量为10</span></span><br><span class="line">        <span class="keyword">this</span>.index=-<span class="number">1</span>;<span class="comment">//栈帧</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.index&gt;=<span class="keyword">this</span>.elements.length-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;压栈失败,栈已满！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.index++;</span><br><span class="line">        <span class="keyword">this</span>.elements[index]=obj;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前为&quot;</span>+<span class="keyword">this</span>.elements[index]+<span class="string">&quot;栈帧为&quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;弹栈失败，栈已空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;弹出的为&quot;</span>+<span class="keyword">this</span>.elements[index]+<span class="string">&quot;栈帧为&quot;</span>+index--);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] getElements() &#123;</span><br><span class="line">        <span class="keyword">return</span> elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElements</span><span class="params">(Object[] elements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elements = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyStack a1=<span class="keyword">new</span> MyStack();</span><br><span class="line">        a1.push(<span class="keyword">new</span> Object());</span><br><span class="line">        a1.push(<span class="keyword">new</span> Object());</span><br><span class="line">        a1.push(<span class="keyword">new</span> Object());</span><br><span class="line">        a1.push(<span class="keyword">new</span> Object());</span><br><span class="line">        a1.push(<span class="keyword">new</span> Object());</span><br><span class="line">        a1.push(<span class="keyword">new</span> Object());</span><br><span class="line">        a1.push(<span class="keyword">new</span> Object());</span><br><span class="line">        a1.push(<span class="keyword">new</span> Object());</span><br><span class="line">        a1.push(<span class="keyword">new</span> Object());</span><br><span class="line">        a1.push(<span class="keyword">new</span> Object());</span><br><span class="line">        a1.push(<span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line">        a1.pop();</span><br><span class="line">        a1.pop();</span><br><span class="line">        a1.pop();</span><br><span class="line">        a1.pop();</span><br><span class="line">        a1.pop();</span><br><span class="line">        a1.pop();</span><br><span class="line">        a1.pop();</span><br><span class="line">        a1.pop();</span><br><span class="line">        a1.pop();</span><br><span class="line">        a1.pop();</span><br><span class="line">        a1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当前为java.lang.Object@1b6d3586栈帧为<span class="number">0</span></span><br><span class="line">当前为java.lang.Object@4554617c栈帧为<span class="number">1</span></span><br><span class="line">当前为java.lang.Object@74a14482栈帧为<span class="number">2</span></span><br><span class="line">当前为java.lang.Object@<span class="number">1540e19d</span>栈帧为<span class="number">3</span></span><br><span class="line">当前为java.lang.Object@677327b6栈帧为<span class="number">4</span></span><br><span class="line">当前为java.lang.Object@14ae5a5栈帧为<span class="number">5</span></span><br><span class="line">当前为java.lang.Object@7f31245a栈帧为<span class="number">6</span></span><br><span class="line">当前为java.lang.Object@6d6f6e28栈帧为<span class="number">7</span></span><br><span class="line">当前为java.lang.Object@135fbaa4栈帧为<span class="number">8</span></span><br><span class="line">当前为java.lang.Object@45ee12a7栈帧为<span class="number">9</span></span><br><span class="line">压栈失败,栈已满！</span><br><span class="line">弹出的为java.lang.Object@45ee12a7栈帧为<span class="number">9</span></span><br><span class="line">弹出的为java.lang.Object@135fbaa4栈帧为<span class="number">8</span></span><br><span class="line">弹出的为java.lang.Object@6d6f6e28栈帧为<span class="number">7</span></span><br><span class="line">弹出的为java.lang.Object@7f31245a栈帧为<span class="number">6</span></span><br><span class="line">弹出的为java.lang.Object@14ae5a5栈帧为<span class="number">5</span></span><br><span class="line">弹出的为java.lang.Object@677327b6栈帧为<span class="number">4</span></span><br><span class="line">弹出的为java.lang.Object@<span class="number">1540e19d</span>栈帧为<span class="number">3</span></span><br><span class="line">弹出的为java.lang.Object@74a14482栈帧为<span class="number">2</span></span><br><span class="line">弹出的为java.lang.Object@4554617c栈帧为<span class="number">1</span></span><br><span class="line">弹出的为java.lang.Object@1b6d3586栈帧为<span class="number">0</span></span><br><span class="line">弹栈失败，栈已空！</span><br></pre></td></tr></table></figure>



<h2 id="酒店管理系统"><a href="#酒店管理系统" class="headerlink" title="酒店管理系统"></a>酒店管理系统</h2><p>模拟订房，退房，打印所有房间状态等功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelMgySystem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hotel hotel=<span class="keyword">new</span> Hotel();</span><br><span class="line">        System.out.println(<span class="string">&quot;[1]表示查看房间列表，[2]表示订房，[3]表示退房，[0]表示退出系统&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">int</span> i = s.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                hotel.printArray();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入房间编号：&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> roomNo = s.nextInt();</span><br><span class="line">                hotel.order(roomNo);</span><br><span class="line">                System.out.println(roomNo + <span class="string">&quot;已订房！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入房间编号：&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> roomNo = s.nextInt();</span><br><span class="line">                hotel.exit(roomNo);</span><br><span class="line">                System.out.println(roomNo + <span class="string">&quot;已退房！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;指令不对，请重新输入！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Room</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Room</span><span class="params">(<span class="keyword">int</span> no,String type,<span class="keyword">boolean</span> status)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no=no;</span><br><span class="line">        <span class="keyword">this</span>.type=type;</span><br><span class="line">        <span class="keyword">this</span>.status=status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;酒店编号：&quot;</span>+no+<span class="string">&quot;    类型为：&quot;</span>+type+<span class="string">&quot;   状态为：&quot;</span>+status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj==<span class="keyword">null</span> || !(obj <span class="keyword">instanceof</span> Room)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>==obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Room room=(Room) obj;</span><br><span class="line">        <span class="keyword">if</span> (room.status=<span class="keyword">this</span>.status &amp;&amp; room.no==<span class="keyword">this</span>.no &amp;&amp; room.type.equals(<span class="keyword">this</span>.type)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(<span class="keyword">boolean</span> status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hotel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Room[][] rooms;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hotel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rooms=<span class="keyword">new</span> Room[<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        房间编号:    101 102 103……</span></span><br><span class="line"><span class="comment">                     201 202 203……</span></span><br><span class="line"><span class="comment">                     301 302 303……</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rooms.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;rooms[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>)&#123;</span><br><span class="line">                    rooms[i][j]=<span class="keyword">new</span> Room((j+<span class="number">1</span>)+(i+<span class="number">1</span>)*<span class="number">100</span>,<span class="string">&quot;单人间&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">                    rooms[i][j]=<span class="keyword">new</span> Room((j+<span class="number">1</span>)+(i+<span class="number">1</span>)*<span class="number">100</span>,<span class="string">&quot;双人间&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">2</span>)&#123;</span><br><span class="line">                    rooms[i][j]=<span class="keyword">new</span> Room((j+<span class="number">1</span>)+(i+<span class="number">1</span>)*<span class="number">100</span>,<span class="string">&quot;多人间&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rooms.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;rooms[i].length;j++)&#123;</span><br><span class="line">                System.out.print(rooms[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订房间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">(<span class="keyword">int</span> roomNo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=roomNo/<span class="number">100</span>-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=roomNo%<span class="number">100</span>-<span class="number">1</span>;</span><br><span class="line">        rooms[i][j].setStatus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//推房间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> roomNo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=roomNo/<span class="number">100</span>-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=roomNo%<span class="number">100</span>-<span class="number">1</span>;</span><br><span class="line">        rooms[i][j].setStatus(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>Arrays工具类，String字符串的存储原理，String类的常用构造方法</title>
    <url>/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20023%EF%BC%88Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81String%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86%E3%80%81String%E7%B1%BB%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Arrays工具类的使用"><a href="#Arrays工具类的使用" class="headerlink" title="Arrays工具类的使用"></a>Arrays工具类的使用</h2><p>SUN公司已经写好了一个数组工具类</p>
<span id="more"></span>

<p>1、Java.util.Arrays工具类，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(数组名) <span class="comment">//排序（从小到大）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.binarySearch(数组名，查找数值)<span class="comment">//二分法查找（建立在排序基础上）</span></span><br></pre></td></tr></table></figure>

<h2 id="String字符串的存储原理"><a href="#String字符串的存储原理" class="headerlink" title="String字符串的存储原理"></a>String字符串的存储原理</h2><p>关于JDK中内置的一个类:java.lang.String</p>
<p>1、双引号括起来的字符串，是不可变的。</p>
<p>2、在JDK当中双引号括起来的字符串，都是直接存储在“方法区”的“字符串常量池“当中的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1=<span class="string">&quot;123&quot;</span>;<span class="comment">//在方法区的字符串常量池中，而s1在栈的方法中</span></span><br><span class="line">String s2=<span class="string">&quot;123&quot;</span>;<span class="comment">//s2保存的为堆内存中String的对象，而这个对象保存的为方法区内字符串常量池中的地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">        System.out.println(s1==s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>垃圾回收器不会释放常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s2=<span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="String类中常用的构造方法"><a href="#String类中常用的构造方法" class="headerlink" title="String类中常用的构造方法"></a>String类中常用的构造方法</h2><ul>
<li><ul>
<li><ul>
<li>```<br>public String(byte[] bytes)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      通过使用平台的默认字符集解码指定的字节数组来构造新的`String` 。新的`String`的长度是字符集的函数，因此可能不等于字节数组的长度。</span><br><span class="line"></span><br><span class="line">      指定字节在默认字符集中无效时，此构造函数的行为是未指定的。 当需要对解码过程进行更多的控制时，应使用[`CharsetDecoder`](../../java/nio/charset/CharsetDecoder.html)类。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `bytes` - 要解码为字符的字节 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte[] bytes=&#123;97,98,99&#125;;</span><br><span class="line">        String s1=new String(bytes);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abc</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因为String类已经重写了toString方法</p>
<ul>
<li><ul>
<li><ul>
<li>```<br>public String(byte[] bytes,<pre><code>          int offset,
          int length)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      通过使用平台的默认字符集解码指定的字节子阵列来构造新的`String` 。新的`String`的长度是字符集的函数，因此可能不等于子数组的长度。</span><br><span class="line"></span><br><span class="line">      指定字节在默认字符集中无效时，此构造函数的行为是未指定的。 当需要更多的解码过程控制时，应使用[`CharsetDecoder`](../../java/nio/charset/CharsetDecoder.html)类。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `bytes` - 要解码为字符的字节 </span><br><span class="line"></span><br><span class="line">        `offset` - 要解码的第一个字节的索引 </span><br><span class="line"></span><br><span class="line">        `length` - 要解码的字节数 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `IndexOutOfBoundsException`  - 如果 `offset`和 `length`参数的索引字符在 `bytes`数组的边界之外 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">String s2=new String(bytes,1,2);//(字节数组，数组元素下标的起始位置，长度)</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">bc</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] chars=&#123;<span class="string">&quot;i&quot;</span>,<span class="string">&quot;am&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;Chinese&quot;</span>&#125;;</span><br><span class="line">String s4=<span class="keyword">new</span> String(chars);</span><br><span class="line">System.out.print(s4)</span><br><span class="line">String s5=<span class="keyword">new</span> String(chars,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">System.out.print(s5);</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3><ul>
<li><ul>
<li><ul>
<li>```<br>public char charAt(int index)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回`char`指定索引处的值。指数范围为`0`至`length() - 1` 。该序列的第一个`char`值在索引`0` ，下一个索引为`1`  ，依此类推，与数组索引一样。</span><br><span class="line"></span><br><span class="line">      如果`char`由索引指定的值是[surrogate](Character.html#unicode) ，则返回所述替代值。 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class StringAtTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1=&quot;123&quot;;</span><br><span class="line">        char c=s1.charAt(1);//char c=&quot;123&quot;.charAt(1)</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ul>
<li>```<br>public int compareTo(String anotherString)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      按字典顺序比较两个字符串。比较是基于字符串中每个字符的Unicode值。由该`String`对象表示的字符序列按字典顺序与由参数字符串表示的字符序列进行比较。如果`String`对象按字典顺序排列在参数字符串之前，结果为负整数。结果是一个正整数，如果`String`对象按字典顺序跟随参数字符串。如果字符串相等，结果为零;`compareTo`返回`0` ，当[`equals(Object)`](../../java/lang/String.html#equals-java.lang.Object-)方法将返回`true`  。</span><br><span class="line"></span><br><span class="line">      这是字典排序的定义。  如果两个字符串不同，则它们在某些索引处具有不同的字符，这两个字符串是两个字符串的有效索引，或者它们的长度不同，或两者都是不同的。  如果它们在一个或多个索引位置具有不同的字符，则令*k*为最小的索引;  那么在位置*k*处的字符具有较小值的字符串，如通过使用&lt;运算符确定的，以字典顺序位于另一个字符串之前。  在这种情况下，  `compareTo`返回两个字符串中位置`k`处的两个字符值的差值，即值： </span><br><span class="line"></span><br><span class="line">      &gt; ` this.charAt(k)-anotherString.charAt(k) `</span><br><span class="line"></span><br><span class="line">      如果没有它们不同的索引位置，则较短的字符串按字典顺序位于较长的字符串之前。在这种情况下， `compareTo`返回字符串长度的差异 - 即值：</span><br><span class="line"></span><br><span class="line">      &gt; ` this.length()-anotherString.length() `</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1=&quot;123&quot;;</span><br><span class="line">        int result=&quot;123&quot;.compareTo(s1);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        int result1=&quot;abce&quot;.compareTo(&quot;abcd&quot;);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">        int result2=&quot;abcd&quot;.compareTo(&quot;abce&quot;);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">0   //表示前后一致</span><br><span class="line">1   //前大后小</span><br><span class="line">-1  //前小后大</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>public boolean contains(CharSequence s)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      当且仅当此字符串包含指定的char值序列时才返回true。 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">System.out.print(&quot;12345&quot;.contains(&quot;345&quot;));</span><br><span class="line">true</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>public boolean endsWith(String suffix)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      测试此字符串是否以指定的后缀结尾。 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">System.out.print(&quot;test.txt&quot;.endsWith(&quot;.txt&quot;));</span><br><span class="line">    true</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>```<br>public boolean equals(Object anObject)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      将此字符串与指定对象进行比较。  其结果是`true`当且仅当该参数不是`null`并且是`String`对象，表示相同的字符序列作为该对象。 </span><br><span class="line"></span><br><span class="line">注意：比较字符串必须要用equals方法</span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public boolean equalsIgnoreCase(String anotherString)</span><br></pre></td></tr></table></figure>

<p>将此<code>String</code>与其他<code>String</code>比较，忽略案例注意事项。如果两个字符串的长度相同，并且两个字符串中的相应字符等于忽略大小写，则两个字符串被认为是相等的。</p>
<p>如果以下至少一个为真，则两个字符<code>c1</code>和<code>c2</code>被认为是相同的忽略情况： </p>
<ul>
<li>两个字符相同（与<code>==</code>操作符相比） </li>
<li>将方法<a href="../../java/lang/Character.html#toUpperCase-char-"><code>Character.toUpperCase(char)</code></a>应用于每个字符产生相同的结果 </li>
<li>将方法<a href="../../java/lang/Character.html#toLowerCase-char-"><code>Character.toLowerCase(char)</code></a>应用于每个字符产生相同的结果 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;ABC&quot;</span>equalsIgnoreCase(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><ul>
<li>```<br>public byte[] getBytes()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      使用平台的默认字符集将此`String`编码为字节序列，将结果存储到新的字节数组中。</span><br><span class="line"></span><br><span class="line">      当该字符串不能在默认字符集中编码时，此方法的行为是未指定的。 当需要对编码过程进行更多控制时，应使用[`CharsetEncoder`](../../java/nio/charset/CharsetEncoder.html)类。 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">byte[] bytes=&quot;abcdef&quot;.getBytes();</span><br><span class="line">for(int i=0;i&lt;bytes.length;i++)&#123;</span><br><span class="line">    System.out.print(bytes[i]+&quot;  &quot;)</span><br><span class="line">&#125;</span><br><span class="line">97 98 99 100 101 102 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>```<br>public boolean isEmpty()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      退货 `true`如果，只有 [`length()`](../../java/lang/String.html#length--)是  `0` 。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        `true`如果 [`length()`](../../java/lang/String.html#length--)是  `0` ，否则 `false` </span><br><span class="line"></span><br><span class="line">判断字符串是否为空</span><br><span class="line"></span><br><span class="line">注意：判断数组长度是length属性，判断字符串长度是length方法。</span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public int lastIndexOf(String str)</span><br></pre></td></tr></table></figure>

<p>返回指定子字符串最后一次出现的字符串中的索引。空字符串“”的最后一次出现被认为发生在索引值<code>this.length()</code> 。</p>
<p>返回的索引是其中的最大值<em>k</em> ： </p>
<blockquote>
<p><code>this.startsWith(str, *k*)</code></p>
</blockquote>
<p>如果没有<em>k的</em>值存在，则返回<code>-1</code> 。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1234567890ffyzsl&quot;</span>.lastIndexOf(<span class="string">&quot;ffy&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><ul>
<li><p>```<br>public String replace(char oldChar,</p>
<pre><code>                  char newChar)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回从替换所有出现的导致一个字符串`oldChar`在此字符串`newChar`  。</span><br><span class="line"></span><br><span class="line">      如果在String `oldChar`表示的字符序列中没有发生`String`  ，则返回对该`String`对象的引用。 否则，  `String`被返回对象，它表示一个字符序列与由本表示的字符序列`String`除了的每次出现对象，  `oldChar`通过的发生替换`newChar` 。 </span><br><span class="line"></span><br><span class="line">      例子： </span><br><span class="line"></span><br><span class="line">      &gt; ` &quot;mesquite in your cellar&quot;.replace(&#x27;e&#x27;, &#x27;o&#x27;)         returns &quot;mosquito in your collar&quot; &quot;the war of baronets&quot;.replace(&#x27;r&#x27;, &#x27;y&#x27;)         returns &quot;the way of bayonets&quot; &quot;sparring with a purple porpoise&quot;.replace(&#x27;p&#x27;, &#x27;t&#x27;)         returns &quot;starring with a turtle tortoise&quot; &quot;JonL&quot;.replace(&#x27;q&#x27;, &#x27;x&#x27;) returns &quot;JonL&quot; (no change) `</span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public String replace(CharSequence target,</span><br><span class="line">                            CharSequence replacement)</span><br></pre></td></tr></table></figure>

<p>将与字面目标序列匹配的字符串的每个子字符串替换为指定的字面替换序列。  替换从字符串开始到结束，例如，在字符串“aaa”中用“b”替换“aa”将导致“ba”而不是“ab”。 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>String的父接口就是：CharSequence</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> System.out.println(<span class="string">&quot;112211223344&quot;</span>.replace(<span class="string">&quot;11&quot;</span>,<span class="string">&quot;22&quot;</span>));</span><br><span class="line"><span class="number">222222223344</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><ul>
<li><p>```<br>public String[] split(String regex,</p>
<pre><code>                  int limit)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      将此字符串拆分为给定的[regular expression的](../util/regex/Pattern.html#sum)匹配。</span><br><span class="line"></span><br><span class="line">      此方法返回的数组包含此字符串的每个子字符串，该字符串由与给定表达式匹配的另一个子字符串终止，或由字符串结尾终止。  数组中的子字符串按照它们在此字符串中的顺序排列。  如果表达式与输入的任何部分不匹配，则生成的数组只有一个元素，即这个字符串。 </span><br><span class="line"></span><br><span class="line">      当在此字符串的开始处存在正宽度匹配时，在结果数组的开始处包含空的前导子字符串。  开始时的零宽度匹配不会产生这样的空的前导子串。 </span><br><span class="line"></span><br><span class="line">      `limit`参数控制应用模式的次数，因此影响生成的数组的长度。  如果极限*n*大于0，则模式最多应用*n* -1次，数组的长度不大于*n*  ，数组的最后一个条目将包含超出最后一个匹配分隔符的所有输入。  如果*n*是非正的，那么模式将被应用到尽可能多的次数，并且数组可以有任何长度。  如果*n*为0，则模式将被应用尽可能多次，数组可以有任何长度，并且尾随的空字符串将被丢弃。 </span><br><span class="line"></span><br><span class="line">      例如，字符串`&quot;boo:and:foo&quot;`使用以下参数产生以下结果： </span><br><span class="line"></span><br><span class="line">      &gt; Regex Limit Result : 2 `&#123; &quot;boo&quot;, &quot;and:foo&quot; &#125;` : 5 `&#123; &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; &#125;` : -2 `&#123; &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; &#125;` o 5 `&#123; &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; &#125;` o -2 `&#123; &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; &#125;` o 0 `&#123; &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;  &#125;`</span><br><span class="line"></span><br><span class="line">      调用此方法的形式*str。* `split(` *正则表达式*  `,` *n* `)`产生与*表达式*相同的结果 </span><br><span class="line"></span><br><span class="line">      &gt; `Pattern.compile(*regex*).split(*str*, *n*)  `</span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public boolean startsWith(String prefix)</span><br></pre></td></tr></table></figure>

<p>测试此字符串是否以指定的前缀开头。 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;12345&quot;</span>.startWith(<span class="string">&quot;123&quot;</span>));</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><ul>
<li><p>```<br>public String substring(int beginIndex)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回一个字符串，该字符串是此字符串的子字符串。子字符串以指定索引处的字符开头，并扩展到该字符串的末尾。</span><br><span class="line"></span><br><span class="line">      例子： </span><br><span class="line"></span><br><span class="line">      &gt; ` &quot;unhappy&quot;.substring(2) returns &quot;happy&quot; &quot;Harbison&quot;.substring(3) returns &quot;bison&quot; &quot;emptiness&quot;.substring(9) returns &quot;&quot; (an empty string) `</span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public String substring(int beginIndex,</span><br><span class="line">                              int endIndex)</span><br></pre></td></tr></table></figure>

<p>返回一个字符串，该字符串是此字符串的子字符串。子串开始于指定<code>beginIndex</code>并延伸到字符索引<code>endIndex - 1</code> 。因此，子串的长度为<code>endIndex-beginIndex</code> 。</p>
<p>例子： </p>
<blockquote>
<p><code>&quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot; &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>```<br>public char[] toCharArray()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      将此字符串转换为新的字符数组。 </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public String toUpperCase(Locale locale)</span><br></pre></td></tr></table></figure>

<p>将所有在此字符<code>String</code>使用给定的规则，大写<code>Locale</code>  。案例映射基于<a href="../../java/lang/Character.html"><code>Character</code></a>类指定的Unicode标准版本。由于案例映射并不总是1：1的字符映射，所以<code>String</code>可能与原始的<code>String</code> 。</p>
<p>区域设置敏感和1：M情况映射的示例如下表所示。 </p>
<p>Language Code of Locale Lower  Case Upper Case Description tr (Turkish) \u0069 \u0130 small letter i -&gt;  capital letter I with dot above tr (Turkish) \u0131 \u0049 small letter dotless  i -&gt; capital letter I (all) \u00df \u0053 \u0053 small letter sharp s -&gt;  two letters: SS (all) Fahrvergnügen FAHRVERGNÜGEN </p>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>```<br>public String toLowerCase()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      将所有在此字符`String`使用默认语言环境的规则，以小写。这相当于打电话`toLowerCase(Locale.getDefault())` 。</span><br><span class="line"></span><br><span class="line">      **注意：**此方法是区域设置敏感的，如果用于单独解释区域设置的字符串，可能会产生意外的结果。  示例是编程语言标识符，协议密钥和HTML标签。 例如，  `&quot;TITLE&quot;.toLowerCase()`在土耳其语言环境返回`&quot;t\u0131tle&quot;` ，其中“\  u0131”是拉丁小写字母无点我的性格。  要获取区域设置不敏感字符串的正确结果，请使用`toLowerCase(Locale.ROOT)` 。 </span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public String trim()</span><br></pre></td></tr></table></figure>

<p>返回一个字符串，其值为此字符串，并删除任何前导和尾随空格。</p>
<p>如果此<code>String</code>对象表示一个空字符序列，或由该代表字符序列的第一个和最后一个字符<code>String</code>对象都具有代码大于<code>&#39;\u0020&#39;</code>  （空格字符），则此参考<code>String</code>被返回对象。 </p>
<p>否则，如果字符串中没有字符大于<code>&#39;\u0020&#39;</code>的字符，则返回一个表示空字符串的<code>String</code>对象。 </p>
<p>否则，令<em>k</em>为代码大于’\u0020’的字符串中第一个字符的<code>&#39;\u0020&#39;</code>  ，并且<em>m</em>为代码大于<code>&#39;\u0020&#39;</code>的字符串中最后一个字符的<code>&#39;\u0020&#39;</code> 。  将返回一个<code>String</code>对象，表示该字符串的子字符串，以索引<em>k</em>处的字符开头，以索引<em>m</em>为止的字符结束，结果为<code>this.substring(k,  m + 1)</code> 。 </p>
<p>此方法可用于从字符串的开始和结尾修剪空格（如上定义）。 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意：去除字符串前后空格</p>
<ul>
<li><ul>
<li><ul>
<li>```<br>public static String valueOf(Object obj)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回 `Object`参数的字符串 `Object`形式。 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">String s1=String.valueOf(true);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        String s2=String.valueOf(25);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        String s3=String.valueOf(25.5);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">true</span><br><span class="line">25</span><br><span class="line">25.5//非字符串转换为字符串</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s4=String.valueOf(<span class="keyword">new</span> Sum());</span><br><span class="line">        System.out.println(s4);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">StringTest.Sum@1b6d3586<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>java中的数组排序，冒泡排序</title>
    <url>/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20022%EF%BC%88%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>1、算法实际上在java中不需要精通，因为java中已经封装好了，需要排序的话直接调用就可以，例如：java中提供的一个数组工具类</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.Arrays</span><br></pre></td></tr></table></figure>

<p>Arrays是一个工具类，其中有一个sort()方法，可以直接采用类名调用。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sufa;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            System.out.print(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;array.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i]&gt;array[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=array[i];</span><br><span class="line">                    array[i]=array[j];</span><br><span class="line">                    array[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            System.out.print(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>:j&lt;<span class="number">6</span>;j++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>StringBuffer,包装类</title>
    <url>/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20025%EF%BC%88String%E7%B1%BB%E4%B8%AD%E7%9A%84StringBufffer%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E3%80%81StringBuilder%E5%92%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89%E3%80%81%E5%85%AB%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%89/</url>
    <content><![CDATA[<h2 id="String类中的StringBufffer进行字符串连接"><a href="#String类中的StringBufffer进行字符串连接" class="headerlink" title="String类中的StringBufffer进行字符串连接"></a>String类中的StringBufffer进行字符串连接</h2><span id="more"></span>

<p>1、如果用加号来拼接，因为java中字符串是不可变的，所以每一次拼接都会产生新字符串。会占用大量内存，造成内存空间的浪费</p>
<p>2、StringBuffer是一个类</p>
<p>3、底层是一个byte[ ] 数组</p>
<ul>
<li><ul>
<li><ul>
<li>```<br>public StringBuffer()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      构造一个没有字符的字符串缓冲区，初始容量为16个字符。 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StringBuffer StringBuffer01=new StringBuffer(&quot;123&quot;);</span><br><span class="line">        StringBuffer01.append(24);</span><br><span class="line">        StringBuffer01.append(&quot;ffzsl&quot;);</span><br><span class="line">        StringBuffer01.append(true);</span><br><span class="line">        System.out.println(StringBuffer01);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">12324ffzsltrue</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">        StringBuffer s2=<span class="keyword">new</span> StringBuffer(s1);</span><br><span class="line">        s2.append(<span class="string">&quot;ffyzsl&quot;</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br><span class="line">123ffyzsl</span><br></pre></td></tr></table></figure>

<h2 id="StringBuilder和StringBuffer的区别"><a href="#StringBuilder和StringBuffer的区别" class="headerlink" title="StringBuilder和StringBuffer的区别"></a>StringBuilder和StringBuffer的区别</h2><ul>
<li><ul>
<li><ul>
<li>```<br>public StringBuilder()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      构造一个没有字符的字符串构建器，初始容量为16个字符。 </span><br><span class="line"></span><br><span class="line">StringBuffer中的方法都有：synchronized关键字修饰，表示StringBuffer在多线程环境下运行是安全的</span><br><span class="line"></span><br><span class="line">## 包装类存在的意义</span><br><span class="line"></span><br><span class="line">1、java为8中基本数据类型准备了8中包装类型，8中包装类属于引用数据类型，父类是Object。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    MyInt a=new MyInt(123);</span><br><span class="line">   doSome(a);//因为调用doSome方法时需要传一个数字进去，但数字属于基本数据类型，而doSome()方法参数的类型时Object。所以doSome()方法无法接受基本数据类型，可以传一个数字对应的包装类进去</span><br><span class="line">&#125;</span><br><span class="line">public static void doSome(Object obj)&#123;</span><br><span class="line">    System.out.print(obj);</span><br><span class="line">&#125;</span><br><span class="line">123</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInt</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInt</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInt</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value=value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八种包装类"><a href="#八种包装类" class="headerlink" title="八种包装类"></a>八种包装类</h2><p>基本数据类型              包装类型</p>
<p>byte                              java.Lang.Byte （父类Number）         </p>
<p>short                            java.Lang.Short（父类Number）</p>
<p>int                                 java.Lang.Integer（父类Number）</p>
<p>Long                             java.Lang.Long（父类Number）</p>
<p>float                              java.Lang.Float（父类Number）</p>
<p>double                         java.Lang.Double（父类Number）</p>
<p>boolean                       java.Lang.Boolean（父类Object）</p>
<p>char                              java.Lang.Character（父类Object）</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>装箱、拆箱，Integer的构造方法，自动装箱和自动拆箱</title>
    <url>/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20026%EF%BC%88%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81Integer%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%EF%BC%89/</url>
    <content><![CDATA[<h2 id="装箱和拆箱的概念"><a href="#装箱和拆箱的概念" class="headerlink" title="装箱和拆箱的概念"></a>装箱和拆箱的概念</h2><p>八种包装类中其中6个都是数字对应的包装类，他们的父类都是Number，为抽象类，无法实例化</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i=<span class="keyword">new</span> Integer(<span class="number">123</span>);<span class="comment">//123这个基本数据类型，进行构造方法的包装达到了：基本数据类型向引用数据类型的转换。（装箱）</span></span><br><span class="line"><span class="keyword">float</span> f=i.floatValue();<span class="comment">//将引用数据类型转换成基本数据类型（拆箱）</span></span><br><span class="line">System.out.print(f);</span><br><span class="line"><span class="number">123.00</span></span><br></pre></td></tr></table></figure>

<p>Number类中有方法：（负责拆箱）</p>
<ul>
<li><ul>
<li><table>
<thead>
<tr>
<th></th>
<th align="left"><code>byteValue()</code>  返回指定号码作为值 <code>byte</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td align="left"><code>doubleValue()</code>  返回指定数字的值为 <code>double</code> 。</td>
</tr>
<tr>
<td></td>
<td align="left"><code>floatValue()</code>  返回指定数字的值为 <code>float</code></td>
</tr>
<tr>
<td></td>
<td align="left"><code>intValue()</code>  返回指定号码作为值 <code>int</code> 。</td>
</tr>
<tr>
<td></td>
<td align="left"><code>longValue()</code>  返回指定数字的值为 <code>long</code> 。</td>
</tr>
<tr>
<td></td>
<td align="left"><code>shortValue()</code>  返回指定号码作为值 <code>short</code>。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<p>注意：这些方法所有的数字包装类的子类都有，这些方法是负责拆箱的</p>
<h2 id="Integer的构造方法"><a href="#Integer的构造方法" class="headerlink" title="Integer的构造方法"></a>Integer的构造方法</h2><ul>
<li><ul>
<li><ul>
<li><p>```<br>public Integer(int value)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      构造新分配的 `Integer`对象，该对象表示指定的 `int`值。 </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public Integer(String s)</span><br><span class="line">              throws NumberFormatException</span><br></pre></td></tr></table></figure>

<p>构造一个新分配<code>Integer</code>对象，表示<code>int</code>由指示值<code>String</code>参数。  字符串将转换为<code>int</code>值，正好与基数为<code>parseInt</code>方法一样。 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i=<span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">        Integer i2=<span class="keyword">new</span> Integer(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">12</span>    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double i=<span class="keyword">new</span> Double(<span class="number">123.12</span>);</span><br><span class="line">        Doubler i2=<span class="keyword">new</span> Double(<span class="string">&quot;12.2&quot;</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123.12</span></span><br><span class="line"><span class="number">12.2</span>    </span><br></pre></td></tr></table></figure>

<h3 id="通过常量获取最大值和最小值"><a href="#通过常量获取最大值和最小值" class="headerlink" title="通过常量获取最大值和最小值"></a>通过常量获取最大值和最小值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问包装类的常量</span></span><br><span class="line">    System.out.println(Integer.MAX_VALUE);</span><br><span class="line">    System.out.println(Integer.MIN_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2147483647</span></span><br><span class="line">-<span class="number">2147483648</span></span><br></pre></td></tr></table></figure>

<h3 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   Integer x=<span class="number">100</span>;<span class="comment">//自动装箱（int类型自动转换为Integer类型）</span></span><br><span class="line">   <span class="keyword">int</span> y=x;<span class="comment">//自动拆箱</span></span><br><span class="line">    Integer z=<span class="number">200</span>;<span class="comment">//=Integer z=new Integer(200)</span></span><br><span class="line">    System.out.print(z+<span class="number">1</span>);<span class="comment">//自动拆箱，不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer y=<span class="number">200</span>;</span><br><span class="line">Integer x=<span class="number">200</span>;</span><br><span class="line">System.out.print(y==x);<span class="comment">//== 不会触发自动拆箱机制，只有+ - * / 等运算时才会触发</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x=<span class="number">127</span>;</span><br><span class="line">Integer y=<span class="number">127</span>;</span><br><span class="line">System.out.print(y==x);</span><br><span class="line"><span class="keyword">true</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x=<span class="number">128</span>;</span><br><span class="line">Integer y=<span class="number">128</span>;</span><br><span class="line">System.out.print(y==x);</span><br><span class="line"><span class="keyword">false</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>java中为了提高程序的执行效率，将-128至127之间所有的包装对象提前创建好，放到了一个方法区的“整数型常量池”中，目的是只要使用这个区间内的数据不需要再new了，直接从整数型常量池中取出来</p>
<p>“==”永远判断的都是对象的内存地址</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>随机数练习，异常概述</title>
    <url>/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20028%EF%BC%88%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97%E7%BB%83%E4%B9%A0%E3%80%81%E5%BC%82%E5%B8%B8%E6%A6%82%E8%BF%B0%E3%80%81java%E5%AF%B9%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
    <content><![CDATA[<p>生成5个不重复的随机数字</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random random=<span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            arr[i]=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; arr.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> num= random.nextInt(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span> (!contants(arr,num))&#123;</span><br><span class="line">                arr[index++]=num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; arr.length;i++)&#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">contants</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == key)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h2><p>程序执行过程中发生了不正常的情况，而这种不正常的情况叫做：异常</p>
<p>当程序执行过程中出现异常时，java把该异常信息打印到控制台，供程序员参考</p>
<p>这个信息被称为异常信息，为jdk打印的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过“异常类”实例化“异常对象”</span></span><br><span class="line">        NumberFormatException nfe= <span class="keyword">new</span> NumberFormatException(<span class="string">&quot;数字格式化异常&quot;</span>);</span><br><span class="line">        System.out.println(nfe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">java.lang.NumberFormatException: 数字格式化异常</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1、可以通过异常来创建异常对象，说明异常在java中以类的形式存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> c=a/b;<span class="comment">//实际上jvm在执行到此处时，会new异常对象：new ArithmeticException(&quot;/by zero&quot;);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、异常对应日常生活中：火灾(异常类)：2020年1月4日，小明家着火(异常对象)，2020年1月5日，小红家着火(异常对象)</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>两种异常的区别以及处理方式</title>
    <url>/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20029%EF%BC%88%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="编译时异常和运行时异常的区别"><a href="#编译时异常和运行时异常的区别" class="headerlink" title="编译时异常和运行时异常的区别"></a>编译时异常和运行时异常的区别</h2><p>1、编译时异常和运行时异常，都是发生在运行阶段，编译阶段是不会发生的。因为编译时异常必须在编译阶段预先处理，如果不处理编译器报错，因此得名。所有异常都是在运行阶段发生的，因为只有程序运行阶段才可以new对象。因为异常的发生就是new异常对象</p>
<span id="more"></span>

<p>2、编译时异常一般发生的概率比较高，运行时异常一般发生的概率比较低。（编译时异常是可以预料到的，需要在运行前对其进行预处理，运行时异常是不可预料的）</p>
<h2 id="异常的两种处理方式"><a href="#异常的两种处理方式" class="headerlink" title="异常的两种处理方式"></a>异常的两种处理方式</h2><p>第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级</p>
<p>第二种方式：使用try. .catch语句进行异常的捕捉</p>
<p>注意：异常发生之后，选择上抛，抛给了调用者，调用者需要对这个异常进行处理，调用者处理这个异常同样有两种处理方式。</p>
<p>注意：java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续上抛，抛给了JVM，JVM如果知道这个异常，只有一个结构：终止java程序的执行</p>
<h3 id="方法声明位置上使用throws"><a href="#方法声明位置上使用throws" class="headerlink" title="方法声明位置上使用throws"></a>方法声明位置上使用throws</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        doSome(); <span class="comment">//主方法中调用doSome()方法时必须对异常进行预先处理，否则编译器报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*doSome方法在方法声明上使用了：throws ClassNotFoundException</span></span><br><span class="line"><span class="comment">    这个代码表示doSome()方法在执行过程中，有可能会出现ClassNotFoundException异常，这个</span></span><br><span class="line"><span class="comment">    异常的父类为Exception，属于编译时异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理方法：</p>
<p>第一种处理方式：在方法声明处继续使用throws，来完成异常的继续上抛，抛给调用者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;<span class="comment">//抛给上一级</span></span><br><span class="line">        doSome();<span class="comment">//alt+enter</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种处理方式：try..catch进行捕捉，捕捉等于把异常拦下来，异常真正的解决了（调用者是不知道的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doSome();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常捕捉和上报的联合使用"><a href="#异常捕捉和上报的联合使用" class="headerlink" title="异常捕捉和上报的联合使用"></a>异常捕捉和上报的联合使用</h2><p>注意：一般不建议在main方法上使用throws，因为这个异常如果真正的发生了，一定会抛给JVM，JVM只有终止</p>
<p>异常处理机制的作用就是增强程序的健壮性，异常发生了也不影响程序的执行，所以main方法中的异常建议使用try..catch进行捕捉</p>
<p>处理异常的第一种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line">        m1();</span><br><span class="line">        System.out.println(<span class="string">&quot;main over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 begin&quot;</span>);</span><br><span class="line">        m2();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 begin&quot;</span>);</span><br><span class="line">        m3();</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用SUN jdk中某个类的构造方法</span></span><br><span class="line"><span class="comment">        编译报错的原因：这里调用了一个构造方法，这个构造方法上有throws FileNotFoundException</span></span><br><span class="line"><span class="comment">        FileNotFoundException的父类为IOException，IOEexception的父类为Exception</span></span><br><span class="line"><span class="comment">        所以：FileNotException是编译时异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\game 盗版\\文明.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//如果采用第一种处理方法，上抛，m2方法中调用m3会出现异常，m2上抛后m1会出现异常……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理异常的第二种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//try 尝试</span></span><br><span class="line">            m1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;<span class="comment">//catch为捕捉异常之后走的分支，e为变量名</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 begin&quot;</span>);</span><br><span class="line">        m2();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 begin&quot;</span>);</span><br><span class="line">        m3();</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span>  <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用SUN jdk中某个类的构造方法</span></span><br><span class="line"><span class="comment">        编译报错的原因：这里调用了一个构造方法，这个构造方法上有throws FileNotFoundException</span></span><br><span class="line"><span class="comment">        FileNotFoundException的父类为IOException，IOEexception的父类为Exception</span></span><br><span class="line"><span class="comment">        所以：FileNotException是编译时异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\game 盗版\\文明.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>Integer常用方法及类型互换，java对日期的处理，System类相关的属性方法，数字格式化</title>
    <url>/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20027%EF%BC%88Integer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%81String%20%20int%20Integer%E7%B1%BB%E5%9E%8B%E4%BA%92%E8%BD%AC%E3%80%81java%E5%AF%B9%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86%E3%80%81System%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E3%80%81%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E3%80%81%E9%AB%98%E7%B2%BE%E5%BA%A6BigDecimal%E3%80%81%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Integer常用方法"><a href="#Integer常用方法" class="headerlink" title="Integer常用方法"></a>Integer常用方法</h2><span id="more"></span>

<ul>
<li><ul>
<li><ul>
<li><p>```<br>public int intValue()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      将 `Integer`的值作为 `int` 。 </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public static int parseInt(String s)</span><br><span class="line">                          throws NumberFormatException</span><br></pre></td></tr></table></figure>

<p>将字符串参数解析为带符号的十进制整数。  字符串中的字符都必须是十进制数字，除了第一个字符可能是ASCII减号<code>&#39;-&#39;</code> （ <code>&#39;\u002D&#39;</code>  ）以指示负值或ASCII加号<code>&#39;+&#39;</code> （ <code>&#39;\u002B&#39;</code> ）以指示正值。  返回所得到的整数值，就像参数和小数10被赋予<a href="../../java/lang/Integer.html#parseInt-java.lang.String-int-"><code>parseInt(java.lang.String,  int)</code></a>方法的参数一样。 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>//String转换为int，如果String为中文，则存在异常。</p>
<p>为：NumberFormatException异常</p>
<h2 id="String-int-Integer类型互转"><a href="#String-int-Integer类型互转" class="headerlink" title="String  int Integer类型互转"></a>String  int Integer类型互转</h2><p><img src="/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20027%EF%BC%88Integer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%81String%20%20int%20Integer%E7%B1%BB%E5%9E%8B%E4%BA%92%E8%BD%AC%E3%80%81java%E5%AF%B9%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86%E3%80%81System%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E3%80%81%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E3%80%81%E9%AB%98%E7%B2%BE%E5%BA%A6BigDecimal%E3%80%81%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%89/Users\樊飞扬\AppData\Roaming\Typora\typora-user-images\image-20210222092941876.png" alt="image-20210222092941876"></p>
<h2 id="java对日期的处理"><a href="#java对日期的处理" class="headerlink" title="java对日期的处理"></a>java对日期的处理</h2><h3 id="Date-转化为-String"><a href="#Date-转化为-String" class="headerlink" title="Date 转化为 String"></a>Date 转化为 String</h3><ul>
<li><ul>
<li><ul>
<li>```<br>public Date(long date)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      使用给定的毫秒时间值构造一个`Date`对象。  如果给定的毫秒值包含时间信息，则驱动程序将将时间组件设置为对应于零GMT的默认时区（运行应用程序的Java虚拟机的时区）。 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import java.util.Date;//导入untl下的</span><br><span class="line"></span><br><span class="line">public class Test01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Date nowTime = new Date();//获取精确到毫秒的系统当前时间</span><br><span class="line">        System.out.println(nowTime);//其toSting已经被重写</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>将日期类型Date，按照指定的格式进行转换，Date——转化成具有一定格式的日期字符串——String</p>
<p>SimpleDateFormat是java.text包下，专门负责日期格式化的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sdf =<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd:mm:ss SSS&quot;</span>);</span><br><span class="line"><span class="comment">//yyyy 年   MM 月   dd 日  HH 时   mm 分   ss 秒  SSS 毫秒</span></span><br><span class="line">String now= sdf.format(nowTime);</span><br><span class="line">System.out.prinln(now);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;<span class="comment">//导入untl下的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date nowTime = <span class="keyword">new</span> Date();<span class="comment">//获取精确到毫秒的系统当前时间</span></span><br><span class="line">        System.out.println(nowTime);</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">        String now=sdf.format(nowTime);</span><br><span class="line">        System.out.println(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mon Feb <span class="number">22</span> 09:<span class="number">50</span>:<span class="number">47</span> CST <span class="number">2021</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">02</span>-<span class="number">22</span> 09:<span class="number">50</span>:<span class="number">47</span> <span class="number">459</span></span><br></pre></td></tr></table></figure>

<h3 id="String-转换为-Date"><a href="#String-转换为-Date" class="headerlink" title="String 转换为 Date"></a>String 转换为 Date</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String s1=<span class="string">&quot;2021-02-22 09:50:47 459&quot;</span>;</span><br><span class="line">        SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);<span class="comment">//这里格式要对应这些、</span></span><br><span class="line">        Date nowTime = sdf.parse(s1);</span><br><span class="line">        System.out.println(nowTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Mon Feb <span class="number">22</span> 09:<span class="number">50</span>:<span class="number">47</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> now=System.currentTimeMillis();<span class="comment">//获取自1970年1月1日00：00：00到当前系统时间的总毫秒数</span></span><br></pre></td></tr></table></figure>

<p>统计一个程序运行的时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin=System.currentTimeMillis();</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">long</span> over= System.currentTimeMillis()-begin;</span><br><span class="line">        System.out.println(over);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="System类相关的属性和方法"><a href="#System类相关的属性和方法" class="headerlink" title="System类相关的属性和方法"></a>System类相关的属性和方法</h2><p>System.out  (out是System类的静态变量)</p>
<p>System.out.println()    是PrintStream类的方法</p>
<p>System.gc()   建议启动垃圾回收器</p>
<p>System.currentTimeMillis()   </p>
<p>System,exit(0)  退出jdk</p>
<h2 id="通过毫秒构建Date对象"><a href="#通过毫秒构建Date对象" class="headerlink" title="通过毫秒构建Date对象"></a>通过毫秒构建Date对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date time=<span class="keyword">new</span> Date(<span class="number">1</span>);<span class="comment">//参数是一个毫秒，表示1970年1月1日00:00:00 001 注意：时区</span></span><br></pre></td></tr></table></figure>

<h2 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h2><p>( # )  代表任意数字</p>
<p>( , )    代表千分位</p>
<p>( .  )    代表小数点</p>
<p>(  0  )   代表不够时补0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DecimalFormat df=<span class="keyword">new</span> DecimalFormat(<span class="string">&quot;###,###.##&quot;</span>);<span class="comment">//负责数字格式化</span></span><br><span class="line">        String s1=df.format(<span class="number">1123.12</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>,<span class="number">123.12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="高精度BigDecimal"><a href="#高精度BigDecimal" class="headerlink" title="高精度BigDecimal"></a>高精度BigDecimal</h2><p>BigDecimal  属于大数据，精度极高，属于java对象（引用数据类型），为一个类，专门用在财务软件当中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecmal v1=<span class="keyword">new</span> BigDecimal(<span class="number">100</span>);<span class="comment">//精度极高的100</span></span><br></pre></td></tr></table></figure>

<h2 id="产生随机数"><a href="#产生随机数" class="headerlink" title="产生随机数"></a>产生随机数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random=<span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> num=random.nextInt();<span class="comment">//随机产生一个int范围内的数字</span></span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random=<span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> num=random.nextInt(<span class="number">101</span>);<span class="comment">//随机产生一个小于101的数字</span></span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>try catch深入，异常对象的常用方法</title>
    <url>/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20030%EF%BC%88try%20catch%E6%B7%B1%E5%85%A5%E3%80%81%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="try-catch深入"><a href="#try-catch深入" class="headerlink" title="try catch深入"></a>try catch深入</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            FileInputStream fis= <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\game 盗版\\文明.txt&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;file not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            FileInputStream fis= <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\game 盗版\\文明.txt&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;<span class="comment">//多态：IOException e =new FileNotFoundException();或者Exception e =new FileNotFoundException();</span></span><br><span class="line">            System.out.println(<span class="string">&quot;file not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1、catch后面的小括号里的类型可以是具体的异常类型，也可以是该异常的父类型</p>
<p>2、catch可以写多个，建议catch的时候，精确的一个一个处理，这样有利于程序的调适</p>
<p>3、catch写多个的时候，从上到下，必须遵守从小到大</p>
<h2 id="异常对象的常用方法"><a href="#异常对象的常用方法" class="headerlink" title="异常对象的常用方法"></a>异常对象的常用方法</h2><h3 id="getMessage-和-printStackTrace"><a href="#getMessage-和-printStackTrace" class="headerlink" title="getMessage 和 printStackTrace()"></a>getMessage 和 printStackTrace()</h3><p>1、 String s = exception.getMessage();   获取异常简单的描述信息</p>
<p>2、exception.printStackTrace();    打印异常追踪的堆栈信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NullPointerException e=<span class="keyword">new</span> NullPointerException(<span class="string">&quot;空指针异常&quot;</span>);</span><br><span class="line">        String npe =e.getMessage();<span class="comment">//获取异常简单描述信息，这个信息实际上是构造方法上面String参数</span></span><br><span class="line">        System.out.println(npe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">空指针异常</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NullPointerException e=<span class="keyword">new</span> NullPointerException(<span class="string">&quot;空指针异常&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">java.lang.NullPointerException: 空指针异常</span><br><span class="line">	at ExceptionTest01.Test07.main(Test07.java:<span class="number">5</span>)</span><br><span class="line">hello world!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>finally子句，自定义异常，更新练习</title>
    <url>/2021/07/03/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20031%EF%BC%88finally%E5%AD%90%E5%8F%A5%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81final%E3%80%81finally%E5%92%8Cfinalize%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81java%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E3%80%81%E4%BB%A5%E5%8F%8A%E7%94%A8%E5%BC%82%E5%B8%B8%E6%9D%A5%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88%EF%BC%89/</url>
    <content><![CDATA[<h2 id="finally子句的使用"><a href="#finally子句的使用" class="headerlink" title="finally子句的使用"></a>finally子句的使用</h2><p>关于try..catch中的finally子句：</p>
<p>1、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。（finally子句必须和try一起使用）</p>
<span id="more"></span>

<p>2、finally语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;<span class="comment">//声明位置放到try外面，这样在finally中才能使用。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis =<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\game\\文明.txt&quot;</span>);</span><br><span class="line">            String s=<span class="keyword">null</span>;</span><br><span class="line">            s.toString();<span class="comment">//空指针异常</span></span><br><span class="line">            <span class="comment">//不能将fis.close();放到这里，因为异常被捕捉后这里的代码不会执行；</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//因为finally中的代码一定会执行，所以应该在此将流关闭；</span></span><br><span class="line">            <span class="comment">//因为要确保fis不为空</span></span><br><span class="line">            <span class="keyword">if</span> (fis !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();<span class="comment">//close方法有异常，采用捕捉方式</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、通常在finally语句块中完成资源的释放/关闭。</p>
<p>2、try和finally可以在没有catch的情况下使用。try不能单独使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line"><span class="keyword">finally</span></span><br></pre></td></tr></table></figure>

<p>注意：退出JVM，finally不执行</p>
<p>注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final、finally和finalize的区别"><a href="#final、finally和finalize的区别" class="headerlink" title="final、finally和finalize的区别"></a>final、finally和finalize的区别</h3><p>1、finally是一个关键字，和try联合使用，使用在异常处理机制中</p>
<p>2、finalize()是Object类中的一个方法，作为方法名出现</p>
<p>3、final修饰的方法不能覆盖</p>
<h2 id="java中如何自定义异常"><a href="#java中如何自定义异常" class="headerlink" title="java中如何自定义异常"></a>java中如何自定义异常</h2><p>1、第一步：编写一个类继承Exception或者RuntimeException</p>
<p>第二步：提供两个构造方法，一个无参数的，一个有参数的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyException01 e=<span class="keyword">new</span> MyException01(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyException.MyException01: hello world</span><br><span class="line">	at MyException.Test01.main(Test01.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h2 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h2><p>1、这个栈中可以存储引用数据类型</p>
<p>2、在栈中提供push方法模拟压栈</p>
<p>3、在栈中提供pop方法模拟弹栈</p>
<p>4、编写测试程序，new栈对象，调用push pop方法来模拟压栈弹栈的动作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//向栈中存储元素，因为Object类可以存储任何引用类型的数据</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elements=<span class="keyword">new</span> Object[<span class="number">10</span>];<span class="comment">//默认初始化数组容量为10</span></span><br><span class="line">        <span class="keyword">this</span>.index=-<span class="number">1</span>;<span class="comment">//栈帧</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.index&gt;=<span class="keyword">this</span>.elements.length-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;压栈失败,栈已满！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.index++;</span><br><span class="line">        <span class="keyword">this</span>.elements[index]=obj;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前为&quot;</span>+<span class="keyword">this</span>.elements[index]+<span class="string">&quot;栈帧为&quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;弹栈失败，栈已空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;弹出的为&quot;</span>+<span class="keyword">this</span>.elements[index]+<span class="string">&quot;栈帧为&quot;</span>+index--);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] getElements() &#123;</span><br><span class="line">        <span class="keyword">return</span> elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElements</span><span class="params">(Object[] elements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elements = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用自定义异常改良：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStackOperationException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStackOperationException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStackOperationException</span><span class="params">(String s )</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//向栈中存储元素，因为Object类可以存储任何引用类型的数据</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elements=<span class="keyword">new</span> Object[<span class="number">10</span>];<span class="comment">//默认初始化数组容量为10</span></span><br><span class="line">        <span class="keyword">this</span>.index=-<span class="number">1</span>;<span class="comment">//栈帧</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> MyStackOperationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.index&gt;=<span class="keyword">this</span>.elements.length-<span class="number">1</span>)&#123;</span><br><span class="line">          MyStackOperationException e=<span class="keyword">new</span> MyStackOperationException(<span class="string">&quot;栈已满！&quot;</span>);</span><br><span class="line">          <span class="keyword">throw</span> e;<span class="comment">//这里捕捉没有意义</span></span><br><span class="line">            <span class="comment">// trows new MyStackOperationException(&quot;栈已满！&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.index++;</span><br><span class="line">        <span class="keyword">this</span>.elements[index]=obj;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前为&quot;</span>+<span class="keyword">this</span>.elements[index]+<span class="string">&quot;栈帧为&quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;弹栈失败，栈已空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;弹出的为&quot;</span>+<span class="keyword">this</span>.elements[index]+<span class="string">&quot;栈帧为&quot;</span>+index--);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] getElements() &#123;</span><br><span class="line">        <span class="keyword">return</span> elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElements</span><span class="params">(Object[] elements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elements = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyStack stack =<span class="keyword">new</span> MyStack();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stack.push(<span class="keyword">new</span> Object());</span><br><span class="line">            stack.push(<span class="keyword">new</span> Object());</span><br><span class="line">            stack.push(<span class="keyword">new</span> Object());</span><br><span class="line">            stack.push(<span class="keyword">new</span> Object());</span><br><span class="line">            stack.push(<span class="keyword">new</span> Object());</span><br><span class="line">            stack.push(<span class="keyword">new</span> Object());</span><br><span class="line">            stack.push(<span class="keyword">new</span> Object());</span><br><span class="line">            stack.push(<span class="keyword">new</span> Object());</span><br><span class="line">            stack.push(<span class="keyword">new</span> Object());</span><br><span class="line">            stack.push(<span class="keyword">new</span> Object());</span><br><span class="line">            stack.push(<span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyStackOperationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：重写之后的方法不能比重写之前的方法抛出更多（更宽泛）的异常，可以更少</p>
<p>throws 在方法声明位置上使用，表示上报异常信息给调用者</p>
<p>throw 手动抛出异常</p>
<h2 id="异常练习"><a href="#异常练习" class="headerlink" title="异常练习"></a>异常练习</h2><p>一、模拟用户注册</p>
<p>1、程序开始执行时，提示用户输入“用户名”和”密码“信息。</p>
<p>2、输入信息之后，后台java程序模拟用户注册</p>
<p>3、注册时用户名要求长度在（6-14）之间，大于或者小于都表示异常</p>
<p>注意：完成注册的方法放到一个单独的类中，异常类自定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IllegalArgsException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IllegalArgsException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IllegalArgsException</span><span class="params">(String s)</span></span>&#123;<span class="keyword">super</span>(s);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String username,String password)</span> <span class="keyword">throws</span> IllegalArgsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (username ==<span class="keyword">null</span> || username.length()&lt;<span class="number">6</span> || username.length() &gt;<span class="number">14</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgsException(<span class="string">&quot;用户名异常！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;注册成功！&quot;</span>+username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService =<span class="keyword">new</span> UserService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userService.register(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgsException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>Collection常用方法以及迭代</title>
    <url>/2021/07/04/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20033%EF%BC%88%E5%85%B3%E4%BA%8E%E5%9C%A8java.util.Collection%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8CCollection%E9%9B%86%E5%90%88%E8%BF%AD%E4%BB%A3%EF%BC%89%20(2)/</url>
    <content><![CDATA[<p>1、Collection中能存放什么元素：</p>
<p>​    没有使用“泛型”之前，Collection中可以存放Object的所有子类型</p>
<p>​    使用了“泛型”之后，Collection中只能存储某个具体的类型</p>
<span id="more"></span>

<p>2、Collection中的常用方法</p>
<ul>
<li><ul>
<li><ul>
<li>```<br>boolean add(E e)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      确保此集合包含指定的元素（可选操作）。如果此集合由于调用而更改，则返回`true` 。（如果此集合不允许重复，并且已包含指定的元素，则返回`false。` ）</span><br><span class="line"></span><br><span class="line">      支持此操作的集合可能会限制可能添加到此集合的元素。  特别是一些集合拒绝添加`null种`元素，和其他人将强加可添加元素的类型限制。  收集类应在其文档中明确说明可能添加哪些元素的限制。 </span><br><span class="line"></span><br><span class="line">      如果一个集合拒绝添加一个特定的元素，除了它已经包含该元素之外，它*必须*抛出异常（而不是返回`false`  ）。 这保留了一个集合在此调用返回后始终包含指定元素的不变量。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `e` - 要确保在此集合中的存在的元素 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        `true`如果此集合由于调用而更改 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `UnsupportedOperationException`  - 如果此 `集合`不支持add操作 </span><br><span class="line"></span><br><span class="line">        `ClassCastException` -  如果指定元素的类阻止将其添加到此集合 </span><br><span class="line"></span><br><span class="line">        `NullPointerException`  - 如果指定的元素为空，并且该集合不允许空元素 </span><br><span class="line"></span><br><span class="line">        `IllegalArgumentException`  - 如果元素的某些属性阻止其添加到此集合 </span><br><span class="line"></span><br><span class="line">        `IllegalStateException`  - 如果由于插入限制，此时无法添加该元素 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line"></span><br><span class="line">public class Test01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection c =new ArrayList();</span><br><span class="line">        c.add(120);//自动装箱，Integer x =new Integer(120);</span><br><span class="line">        c.add(31.4);</span><br><span class="line">        c.add(new Object());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>int size()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回此集合中的元素数。  如果此收藏包含超过`Integer.MAX_VALUE个`元素，则返回`Integer.MAX_VALUE`  。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        此集合中的元素数 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">        System.out.println(c.size());</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>void clear()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      从此集合中删除所有元素（可选操作）。 此方法返回后，集合将为空。 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `UnsupportedOperationException`  - 如果此 `集合`不支持clear操作 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">c.clear</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>boolean contains(Object o)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      如果此集合包含指定的元素，则返回`true` 。  更正式地，返回`true`如果且仅当该集合至少包含一个元素`e`使得`(o==null ? e==null : o.equals(e))`  。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `o` - 要在此集合中存在的元素要进行测试 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        `true`如果此集合包含指定的元素 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `ClassCastException` -  如果指定元素的类型与此集合不兼容（ [optional](#optional-restrictions) ） </span><br><span class="line"></span><br><span class="line">        `NullPointerException`  - 如果指定的元素为空，并且此集合不允许空元素（ [optional](#optional-restrictions) ） </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">System.out.println(c.contains(120));</span><br><span class="line">true</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>boolean remove(Object o)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      从该集合中删除指定元素的单个实例（如果存在）（可选操作）。  更正式地，删除元素`e` ，使得`(o==null ? e==null : o.equals(e))`  ，如果该集合包含一个或多个这样的元素。  如果此集合包含指定的元素（或等效地，如果此集合由于调用而更改），则返回`true` 。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `o` - 要从此集合中删除的元素（如果存在） </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        `true`如果一个元素因此调用而被删除 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `ClassCastException` -  如果指定元素的类型与此集合不兼容（ [optional](#optional-restrictions) ） </span><br><span class="line"></span><br><span class="line">        `NullPointerException`  - 如果指定的元素为空，并且此集合不允许空元素（ [optional](#optional-restrictions) ） </span><br><span class="line"></span><br><span class="line">        `UnsupportedOperationException`  - 如果此 `集合`不支持remove操作 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">        c.remove(120);</span><br><span class="line">        System.out.println(c.contains(120));</span><br><span class="line">false</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>boolean isEmpty()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      如果此集合不包含元素，则返回 `true` 。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        `true`如果此集合不包含元素 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">System.out.println(c.isEmpty());</span><br><span class="line">false</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>Object[] toArray()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回一个包含此集合中所有元素的数组。如果此集合对其迭代器返回的元素的顺序做出任何保证，则此方法必须以相同的顺序返回元素。</span><br><span class="line"></span><br><span class="line">      返回的数组将是“安全的”，因为该集合不保留对它的引用。  （换句话说，这个方法必须分配一个新的数组，即使这个集合是由数组支持的）。  因此，调用者可以自由地修改返回的数组。 </span><br><span class="line"></span><br><span class="line">      此方法充当基于阵列和基于集合的API之间的桥梁。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        一个包含此集合中所有元素的数组 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">        c.add(120);</span><br><span class="line">        c.add(&quot;nihao&quot;);</span><br><span class="line">        Object[] obj= c.toArray();</span><br><span class="line">        for(int i=0;i&lt;obj.length;i++)&#123;</span><br><span class="line">            Object o= obj[i];</span><br><span class="line">            System.out.print(o+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">31.4 java.lang.Object@1b6d3586 120 nihao</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Collection集合迭代"><a href="#Collection集合迭代" class="headerlink" title="Collection集合迭代"></a>Collection集合迭代</h2><ul>
<li><ul>
<li><ul>
<li><h4 id="hasNext"><a href="#hasNext" class="headerlink" title="hasNext"></a>hasNext</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean hasNext()</span><br></pre></td></tr></table></figure>

<p>如果迭代具有更多的元素，则返回<code>true</code> 。  （换句话说，如果<a href="../../java/util/Iterator.html#next--"><code>next()</code></a>返回一个元素而不是抛出一个异常，则返回<code>true</code>  ） </p>
<ul>
<li><p>结果 </p>
<p><code>true</code>如果迭代有更多的元素 </p>
</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="next"><a href="#next" class="headerlink" title="next"></a>next</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E next()</span><br></pre></td></tr></table></figure>

<p>返回迭代中的下一个元素。 </p>
<ul>
<li><p>结果 </p>
<p>迭代中的下一个元素 </p>
</li>
<li><p>异常 </p>
<p><code>NoSuchElementException</code>  - 如果迭代没有更多的元素 </p>
</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default void remove()</span><br></pre></td></tr></table></figure>

<p>从底层集合中删除此迭代器返回的最后一个元素（可选操作）。 此方法只能调用一次<a href="../../java/util/Iterator.html#next--"><code>next()</code></a> 。  如果底层集合在迭代过程中以任何方式进行修改而不是通过调用此方法，则迭代器的行为是未指定的。 </p>
<ul>
<li><p>实现要求： </p>
<p>默认的实现抛出的一个实例<a href="../../java/lang/UnsupportedOperationException.html"><code>UnsupportedOperationException</code></a>并执行其他操作。 </p>
</li>
<li><p>异常 </p>
<p><code>UnsupportedOperationException</code>  -如果 <code>remove</code>操作不会被这个迭代器支持 </p>
<p><code>IllegalStateException</code>  - 如果 <code>next</code>方法尚未被调用，或者 <code>remove</code>方法在上次调用  <code>next</code>方法之后已经被调用 </p>
</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="forEachRemaining"><a href="#forEachRemaining" class="headerlink" title="forEachRemaining"></a>forEachRemaining</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default void forEachRemaining(Consumer&lt;? super E&gt; action)</span><br></pre></td></tr></table></figure>

<p>对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。  如果指定了该顺序，则按迭代的顺序执行操作。 动作抛出的异常被转发给呼叫者。 </p>
<ul>
<li><p>实现要求： </p>
<p>默认实现的行为如下： <code>  while (hasNext()) action.accept(next()); </code></p>
</li>
<li><p>参数 </p>
<p><code>action</code> - 要为每个元素执行的操作 </p>
</li>
<li><p>异常 </p>
<p><code>NullPointerException</code>  - 如果指定的动作为空 </p>
</li>
<li><p>从以下版本开始： </p>
<p>1.8 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//以下所有的遍历方式/迭代方式，是所有Collection通用的一种方式</span></span><br><span class="line">        Collection c =<span class="keyword">new</span> HashSet();</span><br><span class="line">        c.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        c.add(<span class="number">100</span>);</span><br><span class="line">        c.add(<span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">//对集合Collection进行遍历/迭代</span></span><br><span class="line">        <span class="comment">//第一步：获取集合对象的迭代器对象Iterator</span></span><br><span class="line">        Iterator it =  c.iterator();</span><br><span class="line">        <span class="comment">/*第二步：通过以上获取的迭代器对象开始迭代/遍历集合，使用Iterator中方法</span></span><br><span class="line"><span class="comment">        boolean hasNext() 如果仍有元素可以迭代，则返回true</span></span><br><span class="line"><span class="comment">        Object next（） 返回迭代的下一个元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Object obj=it.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abc</span><br><span class="line">def</span><br><span class="line"><span class="number">100</span></span><br><span class="line">java.lang.Object@1b6d3586</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection s=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        s.add(<span class="number">1</span>);</span><br><span class="line">        s.add(<span class="number">2</span>);</span><br><span class="line">        s.add(<span class="number">3</span>);</span><br><span class="line">        s.add(<span class="number">4</span>);</span><br><span class="line">        Iterator it=s.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>ArrayList是有序的，并且是可重复的。（存放和取出的类型一致，只不过在输入是会转换为字符串，因为println会调用toString()方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection a=<span class="keyword">new</span> HashSet();</span><br><span class="line">        a.add(<span class="number">100</span>);</span><br><span class="line">        a.add(<span class="number">200</span>);</span><br><span class="line">        a.add(<span class="number">300</span>);</span><br><span class="line">        a.add(<span class="number">90</span>);</span><br><span class="line">        a.add(<span class="number">45</span>);</span><br><span class="line">        a.add(<span class="number">100</span>);</span><br><span class="line">        Iterator it=a.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">300</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>

<p>HashSet是无序的，并且不可重复。</p>
<h2 id="深入Collection集合中contains方法"><a href="#深入Collection集合中contains方法" class="headerlink" title="深入Collection集合中contains方法"></a>深入Collection集合中contains方法</h2><p>1、判断集合中是否包含某个元素，如果包含返回true，如果不包含返回false</p>
<p>contains在底层调用了equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection c =<span class="keyword">new</span> ArrayList();</span><br><span class="line">        String s1=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        c.add(s1);</span><br><span class="line">        String s2=<span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        c.add(s2);</span><br><span class="line">        System.out.println(c.size());</span><br><span class="line">        String x=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(c.contains(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection s=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        User s1=<span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        User s2=<span class="keyword">new</span> User(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        s.add(s1);</span><br><span class="line">        s.add(s2);</span><br><span class="line">        User s3=<span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(s.contains(s3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || !(o <span class="keyword">instanceof</span> User)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        User u= (User) o;</span><br><span class="line">        <span class="keyword">return</span> u.name.equals(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>存放在集合中的类型，一定要重写equals方法</p>
<h2 id="Collection集合中remove方法"><a href="#Collection集合中remove方法" class="headerlink" title="Collection集合中remove方法"></a>Collection集合中remove方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection s1=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        String a1=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        s1.add(a1);</span><br><span class="line">        String a2=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        s1.remove(a2);<span class="comment">//java认为a1和a2是一样的，删除a2就是删除a1，换成其他重写equals方法的类结果也一样</span></span><br><span class="line">        System.out.println(s1.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：当集合的结构发生改变时，迭代器必须重新获取，如果还是使用一起的迭代器，会出现异常：java.util.ConcurrenModificationException</p>
<p>删除集合中元素后，集合结构也会发生改变，必须重新获取新的迭代器。 </p>
<p>注意：添加元素也意味着集合结构的改变</p>
<p><strong>所以删除元素时往往使用迭代器来删除</strong></p>
<p>重点：在迭代元素的过程当中，一定要使用迭代器Iterator的remove方法删除元素</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>集合概述</title>
    <url>/2021/07/04/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20032%EF%BC%88%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E3%80%81%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E5%9B%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>1、集合实际上就是就是一个 容器，可以来容纳其他类型的数据。</p>
<p>2、集合不能直接存储基本数据类型和java对象，集合当中存储的都是java对象的内存地址（引用）。</p>
<span id="more"></span>

<p>3、在java中每一个不同的集合，底层会对应不同 的数据结构，往不同的集合中存储元素，等于将数据放到了不同的数据结构中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ArrayList();<span class="comment">//创建一个集合，底层是数组结构</span></span><br><span class="line"><span class="keyword">new</span> LinkeList();<span class="comment">//创建一个集合对象，底层是链表</span></span><br><span class="line"><span class="keyword">new</span> TreeSet();<span class="comment">//创建一个集合对象，底层是二叉树</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>集合在<code>java.util.*</code></p>
<p>在java中集合分为两大类：</p>
<p>一类是单个方式存储元素：这一类集合中超级父接口：<code>java.util.Collection</code>;</p>
<p>一类是以键值对的方式存储元素：以键值对（key–value）的方式存储元素，这一类集合中超级父接口:<code>java.util.Map</code></p>
<p><code>java.util</code>包主要提供了以下三种类型的集合：<br>    1、<code>List</code>：一种有序列表的集合<br>    2、<code>Set</code>：一种保证没有重复元素的集合<br>    3、<code>Map</code>：一种通过键值（key-value）查找的映射表集合</p>
<p>所有集合继承Iterator的含义是，所有集合都是可迭代的</p>
<p>list集合存储元素的特点：有序可重复，存储的元素有下标。有序实际上是说存进去是这个顺序，取出来还是这个顺序，这里的顺序不是说按照大小顺序，有序是因为list集合有下标，下标从零开始</p>
<p><code>ArrayList</code>集合底层采用了数组这种数据结构，是非线程安全的 </p>
<p><code>LinkedList</code>集合底层采用了双向链表式数据结构</p>
<p><code>Vector</code>集合底层采用了数组这种数据结构，是线程安全的，其所有方法都有<code>synchronzied</code>关键字修饰，所以线程安全，但是效率较低，现在保证线程安全有别的方案，所以Vector使用较少</p>
<p><code>set</code>集合存储元素的特点：无序不可重复，无序表示存进去和取出来的顺序不一定相等，set集合中元素没有下标，而且set集合中的元素不能重复</p>
<p><code>HashSet</code>集合在new的时候，底层实际上new了一个<code>HashMap</code>集合，向<code>HashSet</code>集合中存储元素，实际上是存储到<code>HashMap</code>集合中，其是一个哈希表数据结构</p>
<p><code>SortedSet</code>集合存储元素的特点；由于继承了Set集合，所以他的特点也是无序不可重复，但是放在<code>SortedSet</code>集合中元素可以自动排序，我们称为可排序集合，放到该集合中的元素时自动按照大小排序的</p>
<p><code>TreeSet</code>，new一个<code>TreeSet</code>集合底层实际上是<code>TreeMap</code>集合，往<code>TreeMap</code>集合存放数据时，实际上是将数据放到了<code>TreeMap</code>集合中，<code>TreeMap</code>集合底层采用了二叉树数据结构</p>
<p><code>HashMap</code>：底层是哈希表</p>
<p><code>Hashtable</code>：底层也是哈希表，只不过线程安全的，效率较低，使用较少</p>
<p><code>Properties</code>：线程安全的，并且<code>key</code>和<code>value</code>只能存储字符串String</p>
<p><code>TreeMap</code>：底层是二叉树，<code>TreeMap</code>集合的<code>key</code>可以自动按照大小顺序排序</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>List接口的方法，ArrayList集合初始化容量扩容</title>
    <url>/2021/07/04/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20034%EF%BC%88list%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81ArrayList%E9%9B%86%E5%90%88%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E6%89%A9%E5%AE%B9%E3%80%81ArrayList%E9%9B%86%E5%90%88%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="list接口特有的方法"><a href="#list接口特有的方法" class="headerlink" title="list接口特有的方法"></a>list接口特有的方法</h2><p>1、list集合存储元素特点：有序可重复，每个元素都有下标。</p>
<span id="more"></span>
<ul>
<li><ul>
<li><ul>
<li>```<br>void add(int index,<pre><code>     E element)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      将指定的元素插入此列表中的指定位置（可选操作）。  将当前位于该位置的元素（如果有）和任何后续元素（向其索引添加一个）移动。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `index` - 要插入指定元素的索引 </span><br><span class="line"></span><br><span class="line">        `element` - 要插入的元素 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `UnsupportedOperationException`  -如果 `add`操作不受此列表支持 </span><br><span class="line"></span><br><span class="line">        `ClassCastException` -  如果指定元素的类阻止将其添加到此列表中 </span><br><span class="line"></span><br><span class="line">        `NullPointerException`  - 如果指定的元素为空，并且该列表不允许空元素 </span><br><span class="line"></span><br><span class="line">        `IllegalArgumentException`  - 如果指定元素的某些属性阻止其添加到此列表中 </span><br><span class="line"></span><br><span class="line">        `IndexOutOfBoundsException`  - 如果指数超出范围（ `index &lt; 0 || index &gt; size()` ） </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">public class Test01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List l1=new ArrayList();</span><br><span class="line">        l1.add(&#x27;A&#x27;);</span><br><span class="line">        l1.add(&#x27;B&#x27;);</span><br><span class="line">        l1.add(&#x27;C&#x27;);</span><br><span class="line">        l1.add(&#x27;D&#x27;);</span><br><span class="line">        l1.add(1,&quot;E&quot;);</span><br><span class="line">        Iterator it=l1.iterator();</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">            Object o1 =it.next();</span><br><span class="line">            System.out.print(o1+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A E B C D </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>E get(int index)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回此列表中指定位置的元素。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `index` - 要返回的元素的索引 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        该列表中指定位置的元素 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `IndexOutOfBoundsException`  - 如果索引超出范围（ `index &lt; 0 || index &gt;= size()` ） </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">System.out.println(l1.get(1));</span><br><span class="line">E</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>```<br>int indexOf(Object o)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。  更正式地，返回最低指数`i`  ，使`(o==null ? get(i)==null : o.equals(get(i)))` ，或-1如果没有这样的指数。 </span><br><span class="line"></span><br><span class="line">- 参数 </span><br><span class="line"></span><br><span class="line">  `o` - 要搜索的元素 </span><br><span class="line"></span><br><span class="line">- 结果 </span><br><span class="line"></span><br><span class="line">  此列表中指定元素的首次出现的索引，如果此列表不包含元素，则为-1 </span><br><span class="line"></span><br><span class="line">- 异常 </span><br><span class="line"></span><br><span class="line">  `ClassCastException` -  如果指定元素的类型与此列表不兼容（ [optional](Collection.html#optional-restrictions) ） </span><br><span class="line"></span><br><span class="line">  `NullPointerException`  - 如果指定的元素为空，并且此列表不允许空元素（ [optional](Collection.html#optional-restrictions) ）  </span><br><span class="line"></span><br><span class="line">  - - - ```</span><br><span class="line">        int lastIndexOf(Object o)</span><br></pre></td></tr></table></figure>

<pre><code>    返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。  更正式地，返回最高指数`i`使得`(o==null ? get(i)==null : o.equals(get(i)))`  ，或-1如果没有这样的索引。 

    - 参数 

      `o` - 要搜索的元素 

    - 结果 

      此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则为-1 

    - 异常 

      `ClassCastException` -  如果指定元素的类型与此列表不兼容（ [optional](Collection.html#optional-restrictions) ） 

      `NullPointerException`  - 如果指定的元素为空，并且该列表不允许空元素（ [optional](Collection.html#optional-restrictions) ） 
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(l1.indexOf(<span class="string">&#x27;C&#x27;</span>));</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        System.out.println(l1.indexOf(<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">        l1.add(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        System.out.println(l1.lastIndexOf(<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><ul>
<li>```<br>E remove(int index)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      删除该列表中指定位置的元素（可选操作）。  将任何后续元素移动到左侧（从其索引中减去一个元素）。 返回从列表中删除的元素。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `index` - 要删除的元素的索引 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        该元素以前在指定的位置 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `UnsupportedOperationException`  -如果 `remove`操作不受此列表支持 </span><br><span class="line"></span><br><span class="line">        `IndexOutOfBoundsException`  - 如果索引超出范围（ `index &lt; 0 || index &gt;= size()` ） </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">l1.remove(5);</span><br><span class="line">        Iterator it1 =l1.iterator();</span><br><span class="line">        while(it1.hasNext())&#123;</span><br><span class="line">            Object o1 =it1.next();</span><br><span class="line">            System.out.print(o1+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">A E B C D </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>```<br>boolean remove(Object o)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      **从列表中删除指定元素的第一个出现（如果存在）**（可选操作）。  如果此列表不包含该元素，则它将保持不变。  更正式地，删除具有最低索引`i`的元素，使得`(o==null ? get(i)==null : o.equals(get(i)))`  （如果这样的元素存在）。 如果此列表包含指定的元素（或等效地，如果此列表作为调用的结果而更改），则返回`true`  。 </span><br><span class="line"></span><br><span class="line">      - Specified by: </span><br><span class="line"></span><br><span class="line">        `remove`在接口  `Collection&lt;E&gt;` </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `o` - 要从此列表中删除的元素（如果存在） </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        `true`如果此列表包含指定的元素 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `ClassCastException` -  如果指定元素的类型与此列表不兼容（ [optional](Collection.html#optional-restrictions) ） </span><br><span class="line"></span><br><span class="line">        `NullPointerException`  - 如果指定的元素为空，并且该列表不允许空元素（ [optional](Collection.html#optional-restrictions) ） </span><br><span class="line"></span><br><span class="line">        `UnsupportedOperationException`  -如果 `remove`操作不受此列表支持 </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      E set(int index,</span><br><span class="line">            E element)</span><br></pre></td></tr></table></figure>

<p>用指定的元素（可选操作）替换此列表中指定位置的元素。 </p>
<ul>
<li><p>参数 </p>
<p><code>index</code> - 要替换的元素的索引 </p>
<p><code>element</code> - 要存储在指定位置的元素 </p>
</li>
<li><p>结果 </p>
<p>该元素以前在指定的位置 </p>
</li>
<li><p>异常 </p>
<p><code>UnsupportedOperationException</code>  -如果 <code>set</code>操作不受此列表支持 </p>
<p><code>ClassCastException</code> -  如果指定元素的类阻止将其添加到此列表中 </p>
<p><code>NullPointerException</code>  - 如果指定的元素为空，并且该列表不允许空元素 </p>
<p><code>IllegalArgumentException</code>  - 如果指定元素的某些属性阻止将其添加到此列表中 </p>
<p><code>IndexOutOfBoundsException</code>  - 如果指数超出范围（ <code>index &lt; 0 || index &gt;= size()</code> ） </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ArrayList集合初始化容量扩容"><a href="#ArrayList集合初始化容量扩容" class="headerlink" title="ArrayList集合初始化容量扩容"></a>ArrayList集合初始化容量扩容</h2><p>1、ArrayList集合初始化是10</p>
<p>2、ArrayList集合底层是Object类型的数组Object[ ]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list1=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        List list2=<span class="keyword">new</span> ArrayList(<span class="number">20</span>);</span><br><span class="line">        System.out.println(list1.size());</span><br><span class="line">        System.out.println(list2.size());<span class="comment">//size方法是获取当前集合中元素的个数，不是获取集合的容量</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二进制位运算"><a href="#二进制位运算" class="headerlink" title="二进制位运算"></a>二进制位运算</h2><p>1、位运算符：&gt;&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">10</span>&gt;&gt;<span class="number">1</span>);<span class="comment">//右移一位就是除以2</span></span><br><span class="line">        System.out.println(<span class="number">10</span>&lt;&lt;<span class="number">1</span>);<span class="comment">//左移一位，乘2</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList集合中一个构造方法"><a href="#ArrayList集合中一个构造方法" class="headerlink" title="ArrayList集合中一个构造方法"></a>ArrayList集合中一个构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List myList1=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        List myList2=<span class="keyword">new</span> ArrayList(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        Collection c=<span class="keyword">new</span> HashSet();</span><br><span class="line">        c.add(<span class="number">100</span>);</span><br><span class="line">        c.add(<span class="number">200</span>);</span><br><span class="line">        c.add(<span class="number">300</span>);</span><br><span class="line">        c.add(<span class="number">23</span>);</span><br><span class="line">        List myList3=<span class="keyword">new</span> ArrayList(c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;myList3.size();i++)&#123;</span><br><span class="line">            System.out.println(myList3.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">300</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>字符串首尾去空格，关于前面的补充</title>
    <url>/2021/07/04/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20035%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%A1%A5%E5%85%85%E3%80%81java%E5%8C%85%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A1%A5%E5%85%85%E3%80%81classpath%20%E5%92%8C%20jar%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%99%A4%E9%A6%96%E5%B0%BE%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6%EF%BC%89/</url>
    <content><![CDATA[<h2 id="抽象类和接口的补充"><a href="#抽象类和接口的补充" class="headerlink" title="抽象类和接口的补充"></a>抽象类和接口的补充</h2><p>因为抽象类本身被审计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错，因此，抽象方法实际上相当于定义了“规范”。而继承抽象类的子类必须实现其抽象方法，否则会报错。</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">abstract class</th>
<th>interface</th>
</tr>
</thead>
<tbody><tr>
<td align="center">继承</td>
<td align="left">只能extends一个class</td>
<td>可以implements多个interface</td>
</tr>
<tr>
<td align="center">字段</td>
<td align="left">可以定义实例字段</td>
<td>不能定义实例字段</td>
</tr>
<tr>
<td align="center">抽象方法</td>
<td align="left">可以定义抽象方法</td>
<td>可以定义抽象方法</td>
</tr>
<tr>
<td align="center">非抽象方法</td>
<td align="left">可以定义非抽象方法</td>
<td>可以定义default方法</td>
</tr>
</tbody></table>
<p>在接口中，可以定义default方法。例如：把Person接口的run()方法改为default方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>
<p>因为interface是一个纯抽象类，所以它不能定义实例字段，但是，interface是可以有静态字段的，并且静态字段必须为final类型，简单来说，interface定义的字段只能是常量。实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MALE =<span class="number">1</span>;</span><br><span class="line">    INT FEMALE =<span class="number">2</span>;<span class="comment">//常量变量名最好全用大写字母来表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java包机制的补充"><a href="#java包机制的补充" class="headerlink" title="java包机制的补充"></a>java包机制的补充</h2><p>在写<code>import</code>的时候，可以使用<strong>“*”</strong>，表示把这个包下面的所有class都导入进来（但不包括子包的class）</p>
<p>注意：不推荐使用该写法，因为在导入多个包后，很难看出要使用的类输入哪个包</p>
<p>还有一种import static 的语法，他可以导入一个类的静态字段和静态方法（很少使用）</p>
<p>在编写class的时候，编译器会自动帮我们做两个import动作：</p>
<p>1、默认自动import当前package的其他class</p>
<p>2、默认自动<code>import java.lang.*</code></p>
<p>注意：自动导入的是<code>java.lang</code>包，但类似<code>java.lang.reflect</code>这些包仍需要手动导入</p>
<h2 id="classpath-和-jar"><a href="#classpath-和-jar" class="headerlink" title="classpath 和 jar"></a><code>classpath 和 jar</code></h2><p>1、<code>classpath</code>是一个JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code></p>
<p>2、因为java是编译型语言，源码文件<code>.java</code>需要编译成<code>.class</code>文件才能真正可以被JVM执行的字节码，因此，JVM需要知道，如果要加载一个类，应该去哪搜索对应的文件。</p>
<p>3、<code>classpath</code>是一组目录的集合，它设置的搜索路径与操作系统相关，（windows和Linux系统上不一样）</p>
<p>现在我们假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p>
<ul>
<li><code>&lt;当前目录&gt;\abc\xyz\Hello.class</code></li>
<li><code>C:\work\project1\bin\abc\xyz\Hello.class</code></li>
<li><code>C:\shared\abc\xyz\Hello.class</code></li>
</ul>
<p>注意到<code>.</code>代表当前目录。如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p>
<p> 注意：不要把任何Java核心库添加到<code>classpath</code>中！JVM根本不依赖<code>classpath</code>加载核心库！</p>
<h3 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h3><p>如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p>
<p>jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。</p>
<h2 id="字符串去除首尾空白字符"><a href="#字符串去除首尾空白字符" class="headerlink" title="字符串去除首尾空白字符"></a>字符串去除首尾空白字符</h2><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符串。<em><strong>空白字符串包括：<code>\t</code>,<code>\r</code>,<code>\n</code>。</strong></em></p>
<p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回一个新字符串。</p>
<p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;name&quot;</span>;</span><br><span class="line">        System.out.println(s1.replace(<span class="string">&quot;l&quot;</span>,<span class="string">&quot;w&quot;</span>));</span><br><span class="line">        System.out.println(s2.replace(<span class="string">&quot;m&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">        String s=<span class="string">&quot;A,B;C,D&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种是通过正则表达式替换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = &quot;A,,B;C ,D&quot;;</span><br><span class="line">s.replaceAll(&quot;[\\,\\;\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot;</span><br></pre></td></tr></table></figure>

<p>上面的代码通过正则表达式，把匹配的子串统一替换为<code>&quot;,&quot;</code>。关于正则表达式的用法我们会在后面详细讲解。</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>泛型机制，自定义泛型，Map接口中的常用方法</title>
    <url>/2021/07/04/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20036%EF%BC%88%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E3%80%81%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%E3%80%81Map%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="泛型机制"><a href="#泛型机制" class="headerlink" title="泛型机制"></a>泛型机制</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List myList =<span class="keyword">new</span> ArrayList();</span><br><span class="line">        Animal a1=<span class="keyword">new</span> Cat();</span><br><span class="line">        Animal a2=<span class="keyword">new</span> Bird();</span><br><span class="line">        myList.add(a1);</span><br><span class="line">        myList.add(a2);</span><br><span class="line">        Iterator it =myList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            Object obj=it.next();</span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">                Cat c=(Cat) obj;</span><br><span class="line">                c.catchMouse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal move&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;catchMouse&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">catchMouse</span><br></pre></td></tr></table></figure>

<p>使用JDK的泛型机制，（以下仅修改主方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Animal&gt; myList =<span class="keyword">new</span> ArrayList&lt;Animal&gt;();<span class="comment">//使用泛型List&lt;Animal&gt;之后，表示List集合中只允许存储Animal类型的数据。</span></span><br><span class="line">    <span class="comment">//List&lt;Animal&gt; myList =new ArrayList&lt;&gt;();JKD8之后可以这样写，叫做自动类型推断（钻石表达式）</span></span><br><span class="line">        <span class="comment">//用泛型来指定集合中存储的数据类型</span></span><br><span class="line">        Animal a1=<span class="keyword">new</span> Cat();</span><br><span class="line">        Animal a2=<span class="keyword">new</span> Bird();</span><br><span class="line">        myList.add(a1);</span><br><span class="line">        myList.add(a2);</span><br><span class="line">        <span class="comment">//获取迭代器</span></span><br><span class="line">        Iterator&lt;Animal&gt; it =myList.iterator();<span class="comment">//这个表示迭代器迭代的是Animal类型。</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            Animal a =it.next();</span><br><span class="line">            a.move();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>泛型主要在编译阶段的特性，在运行阶段没什么卵用。</p>
<p>好处：1、集合中存储的集合类型统一，从集合中取出的元素是泛型指定的类型，不需要大量的“向下转型”，</p>
<p>坏处：导致集合中存储的元素缺少多样性</p>
<p>在泛型机制中，可以在集合中添加指定类型的子类，但如果想要使用子类特有的方法，也需要向下转型。</p>
<h2 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericTest02&lt;String&gt; gt=<span class="keyword">new</span> GenericTest02&lt;&gt;();</span><br><span class="line">        gt.doSome(<span class="string">&quot;abc&quot;</span>);<span class="comment">//因为定义的泛型为String，所以在调用方法是参数必须为String类型</span></span><br><span class="line">        GenericTest02&lt;Integer&gt; gt1=<span class="keyword">new</span> GenericTest02&lt;&gt;();</span><br><span class="line">        gt1.doSome(<span class="number">100</span>);<span class="comment">//因为定义的泛型为Integer，所以在调用方法是参数必须为Integer类型</span></span><br><span class="line">        <span class="comment">//gt1.doSome(&quot;abc&quot;);在此使用String类型会报错</span></span><br><span class="line">        GenericTest02&lt;String&gt; gt2=<span class="keyword">new</span> GenericTest02&lt;&gt;();</span><br><span class="line">        gt2.get();<span class="comment">//这里返回的是String类型的</span></span><br><span class="line">        GenericTest02&lt;Integer&gt; gt3=<span class="keyword">new</span> GenericTest02&lt;&gt;();</span><br><span class="line">        gt3.get();<span class="comment">//这里返回的是Integer类型的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericTest02</span>&lt;<span class="title">abc</span>&gt;</span>&#123;<span class="comment">//在&lt;&gt;里面的参数起的是“标识符”的意义，因此命名没有过多的规则，abc为标识符。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">(abc o)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> abc <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">doSome</span><br><span class="line">doSome</span><br></pre></td></tr></table></figure>

<p>&lt;&gt;中的标识符一般写为T或者E，没有特殊含义。</p>
<p>如果定义了泛型，而在定义时并不使用，则会返回一个Object类型</p>
<h2 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h2><p>在JDK5之后出现的新特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            System.out.print(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for(元素类型 变量名:数组或集合)&#123; 变量名 &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)&#123;<span class="comment">//i代表数组中的元素</span></span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456781</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        strList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        strList.add(<span class="string">&quot;Kitty&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it=strList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String s=it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strList.size();i++)&#123;</span><br><span class="line">            System.out.println(strList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s:strList)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Hello</span><br><span class="line">Kitty</span><br><span class="line">Hello</span><br><span class="line">Kitty</span><br><span class="line">Hello</span><br><span class="line">Kitty</span><br></pre></td></tr></table></figure>

<h2 id="Map接口中常用的方法"><a href="#Map接口中常用的方法" class="headerlink" title="Map接口中常用的方法"></a>Map接口中常用的方法</h2><p>1、Map和Collection没有继承关系</p>
<p>2、Map集合以key和value的方式存储数据：键值对</p>
<p>​     key和value都是引用数据类型</p>
<p>​     key和value都是存储对象的内存地址</p>
<p>​     key起到主导的地位，value时key一个附属品</p>
<ul>
<li><ul>
<li><ul>
<li><p>```<br>void clear()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      从该地图中删除所有的映射（可选操作）。 此呼叫返回后，地图将为空。 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `UnsupportedOperationException`  -如果 `clear`操作不受此地图支持</span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      V put(K key,</span><br><span class="line">            V value)</span><br></pre></td></tr></table></figure>

<p>将指定的值与该映射中的指定键相关联（可选操作）。  如果映射先前包含了密钥的映射，则旧值将被指定的值替换。  （映射<code>m</code>被认为包含关键字的映射<code>k</code>当且仅当<a href="../../java/util/Map.html#containsKey-java.lang.Object-"><code>m.containsKey(k)</code></a>将返回<code>true</code>  ）。 </p>
<ul>
<li><p>参数 </p>
<p><code>key</code> - 指定值与之关联的键 </p>
<p><code>value</code> - 与指定键相关联的值 </p>
</li>
<li><p>结果 </p>
<p>前一个值与<code>key相关联</code> ，或<code>null，</code>如果没有<code>key的</code>映射。  （A <code>null</code>返回也可以表示该地图以前关联的<code>null</code>与<code>key</code>  ，如果实现支持<code>null的</code>值） </p>
</li>
<li><p>异常 </p>
<p><code>UnsupportedOperationException</code>  -如果 <code>put</code>操作不受此地图支持 </p>
<p><code>ClassCastException</code> -  如果指定的键或值的类阻止它存储在此映射中 </p>
<p><code>NullPointerException</code>  - 如果指定的键或值为空，并且此映射不允许空值或值 </p>
<p><code>IllegalArgumentException</code>  - 如果指定键或值的某些属性阻止其存储在此映射中 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>V get(Object key)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回到指定键所映射的值，或`null`如果此映射包含该键的映射。</span><br><span class="line"></span><br><span class="line">      更正式地，如果该映射包含从键`k`到值`v` ，使得`(key==null ?  k==null : key.equals(k))` ，则该方法返回`v` ;  否则返回`null` 。 （最多可以有一个这样的映射。） </span><br><span class="line"></span><br><span class="line">      如果此映射允许空值，则返回值`null`并不*一定*表明该映射不包含该键的映射关系;  地图也可能明确地将密钥映射到`null` 。 可以使用[`containsKey`](../../java/util/Map.html#containsKey-java.lang.Object-)操作来区分这两种情况。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `key` - 要返回其关联值的键 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        指定键映射到的值，如果此映射不包含键的映射， `null` </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `ClassCastException` -  如果密钥是该地图不合适的类型（ [optional](Collection.html#optional-restrictions) ） </span><br><span class="line"></span><br><span class="line">        `NullPointerException`  - 如果指定的键为空，并且此映射不允许空键</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Test01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map1=new HashMap&lt;&gt;();</span><br><span class="line">        map1.put(1,&quot;张三&quot;);//&quot;1&quot;有自动装箱的操作</span><br><span class="line">        map1.put(2,&quot;李四&quot;);</span><br><span class="line">        map1.put(3,&quot;王五&quot;);</span><br><span class="line">        map1.put(4,&quot;李六&quot;);</span><br><span class="line">        System.out.println(map1.get(1));</span><br><span class="line">        System.out.println(map1.get(2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">张三</span><br><span class="line">李四</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>int size()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回此地图中键值映射的数量。  如果地图包含超过`Integer.MAX_VALUE个`元素，则返回`Integer.MAX_VALUE`  。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        该地图中键值映射的数量 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">System.out.println(map1.size());</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>V remove(Object key)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      如果存在（从可选的操作），从该地图中删除一个键的映射。更正式地，如果该映射包含从关键字`k`到值`v的`映射，使得`(key==null ? k==null :  key.equals(k))` ，该映射被去除。（地图最多可以包含一个这样的映射。）</span><br><span class="line"></span><br><span class="line">      返回此地图先前相关联的密钥，或`null`如果映射包含该键的映射值。 </span><br><span class="line"></span><br><span class="line">      如果此映射允许空值，那么`null`返回值并不*一定*表明此映射不包含该键的映射关系;  地图也可能显式地将密钥映射到`null` 。 </span><br><span class="line"></span><br><span class="line">      一旦呼叫返回，该映射将不包含指定键的映射。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `key` - 其映射将从地图中删除的密钥 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        前一个值与 `key相关联` ，或 `null，`如果没有 `key的`映射。 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `UnsupportedOperationException`  -如果 `remove`操作不受此地图支持 </span><br><span class="line"></span><br><span class="line">        `ClassCastException` -  如果密钥对于此地图是不合适的类型（ [optional](Collection.html#optional-restrictions) ） </span><br><span class="line"></span><br><span class="line">        `NullPointerException`  - 如果指定的键为空，并且此映射不允许空键（ [optional](Collection.html#optional-restrictions) ）</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">map1.remove(1);</span><br><span class="line">System.out.println(map1.get(1));</span><br><span class="line">System.out.println(map1.size());</span><br><span class="line">null</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>```<br>boolean containsKey(Object key)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      如果此映射包含指定键的映射，则返回`true` 。  更正式地，返回`true`当且仅当该地图包含关键字`k`的映射，使得`(key==null ? k==null :  key.equals(k))` 。 （最多可以有一个这样的映射。） </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `key` - 要在此地图中存在的密钥要进行测试 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        `true`如果此映射包含指定键的映射 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `ClassCastException` -  如果密钥对于该地图是不合适的类型（ [optional](Collection.html#optional-restrictions) ） </span><br><span class="line"></span><br><span class="line">        `NullPointerException`  - 如果指定的键为空，并且此映射不允许空键（ [optional](Collection.html#optional-restrictions) ） </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      boolean containsValue(Object value)</span><br></pre></td></tr></table></figure>

<p>如果此映射将一个或多个键映射到指定的值，则返回<code>true</code> 。  更正式地，返回<code>true</code>当且仅当此映射包含至少一个映射到值<code>v</code> ，使得<code>(value==null ?  v==null : value.equals(v))</code> 。  对于Map接口的大多数实现，此<code>操作</code>对于地图大小可能需要时间线性。 </p>
<ul>
<li><p>参数 </p>
<p><code>value</code> - 要在此地图中存在的值要进行测试 </p>
</li>
<li><p>结果 </p>
<p><code>true</code>如果该地图将一个或多个键映射到指定的值 </p>
</li>
<li><p>异常 </p>
<p><code>ClassCastException</code> -  如果该值对于该地图是不合适的类型（ <a href="Collection.html#optional-restrictions">optional</a> ） </p>
<p><code>NullPointerException</code>  - 如果指定的值为空，并且此映射不允许空值（ <a href="Collection.html#optional-restrictions">optional</a> ） </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(map1.containsKey(<span class="number">1</span>));</span><br><span class="line">        System.out.println(map1.containsKey(<span class="number">2</span>));</span><br><span class="line">        System.out.println(map1.containsValue(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        System.out.println(map1.containsValue(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>注意：contains方法底层调用的都是equals进行比对的，所以自定义的类型需要重写equals方法</p>
<ul>
<li><ul>
<li><ul>
<li><pre><code>boolean isEmpty()
</code></pre>
<p>如果此地图不包含键值映射，则返回 <code>true</code> 。 </p>
<ul>
<li><p>结果 </p>
<p><code>true</code>如果此映射不包含键值映射 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>遍历Map集合，重写两个方法，属性类Properties类</title>
    <url>/2021/07/04/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20037%EF%BC%88%E9%81%8D%E5%8E%86Map%E9%9B%86%E5%90%88%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%90%8C%E6%97%B6%E9%87%8D%E5%86%99%60equals%60%E5%92%8C%60hashCode%60%E3%80%81%60HashMap%60%E5%92%8C%60Hashtable%60%E5%8C%BA%E5%88%AB%E3%80%81%E5%B1%9E%E6%80%A7%E7%B1%BB%60Properties%60%E7%B1%BB%EF%BC%89/</url>
    <content><![CDATA[<h2 id="遍历Map集合"><a href="#遍历Map集合" class="headerlink" title="遍历Map集合"></a>遍历Map集合</h2><p>第一种：获取所有的key，通过遍历key，来遍历value、</p>
<span id="more"></span>

<ul>
<li><ul>
<li><ul>
<li>```<br>Set<K> keySet()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回此地图中包含的键的[`Set`](../../java/util/Set.html)视图。  该集合由地图支持，因此对地图的更改将反映在集合中，反之亦然。  如果在集合中的迭代正在进行中修改映射（除了通过迭代器自己的`remove`操作），迭代的结果是未定义的。  该组支持元件移除，即从映射中相应的映射，经由`Iterator.remove，Set.remove，removeAll，retainAll`和`clear`操作。  它不支持`add`或`addAll`操作。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        该地图中包含的键的集合视图 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Test02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map1=new HashMap&lt;&gt;();</span><br><span class="line">        map1.put(1,&quot;张三&quot;);</span><br><span class="line">        map1.put(2,&quot;李四&quot;);</span><br><span class="line">        map1.put(3,&quot;王五&quot;);</span><br><span class="line">        map1.put(4,&quot;李六&quot;);</span><br><span class="line">//通过迭代器的方式来遍历集合</span><br><span class="line">        Set&lt;Integer&gt; keys=map1.keySet();//注意：此方法返回的是一个Set集合；</span><br><span class="line">        Iterator&lt;Integer&gt; it=keys.iterator();</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">            Integer key=it.next();</span><br><span class="line">            System.out.println(key+&quot;=&quot;+map1.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">//通过增强for的方式来遍历集合</span><br><span class="line">        for (Integer key:keys)&#123;</span><br><span class="line">            System.out.println(key+&quot;=&quot;+map1.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></K></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>第二种方式：把Map集合转换为Set集合</p>
<ul>
<li><ul>
<li><ul>
<li>```<br>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回此地图中包含的映射的[`Set`](../../java/util/Set.html)视图。  该集合由地图支持，因此对地图的更改将反映在集合中，反之亦然。  如果在集合中的迭代正在进行时修改映射（除了通过迭代器自己的`remove`操作，或者通过迭代器返回的映射条目上的`setValue`操作），迭代的结果是未定义的。  该组支持元件移除，即从映射中相应的映射，经由`Iterator.remove，Set.remove，removeAll，retainAll`和`clear`操作。  它不支持`add`或`addAll`操作。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        该地图中包含的映射的集合视图 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br><span class="line">        //以上这个方法是哪Map集合直接全部转换成Set集合</span><br><span class="line">        //Set集合中元素的类型是：Map.Entry</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set=map1.entrySet();</span><br><span class="line">        //遍历Set集合，每一次取出一个Node</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it1=set.iterator();</span><br><span class="line">        while(it1.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;Integer,String&gt; node =it1.next();</span><br><span class="line">            Integer key=node.getKey();</span><br><span class="line">            String value=node.getValue();</span><br><span class="line">            System.out.println(key+&quot;=&quot;+value);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="哈希表数据结构"><a href="#哈希表数据结构" class="headerlink" title="哈希表数据结构"></a>哈希表数据结构</h2><p>1、HashMap集合底层是哈希表/散列表的数据结构</p>
<p>2、是一个数组和单向链表的结合体</p>
<p>3、其是一个一位数组，每一个元素都是一个单向链表</p>
<h3 id="Map-put-k-v-的底层原理："><a href="#Map-put-k-v-的底层原理：" class="headerlink" title="Map.put(k,v)的底层原理："></a><code>Map.put(k,v)</code>的底层原理：</h3><p>第一步：先将k，v封装到<code>Node</code>对象当中</p>
<p>第二步：底层会调用k的<code>hashCode()</code>方法得出hash</p>
<p>然后通过哈希函数/哈希算法，将hash值转换成数组的下标，下标位置上如果没有任何元素，就把Node添加到这个位置上，如果说下标对应的位置上有链表，此时会拿着k和链表上每一个节点中的k进行<code>equals</code>，如果所有的<code>equals</code>方法返回的都是false，那么这个新节点被添加到链表的末尾，如果其中一个<code>equals</code>返回了true，那么这个节点的value将会被覆盖。</p>
<h3 id="Map-get-k-的底层原理："><a href="#Map-get-k-的底层原理：" class="headerlink" title="Map.get(k)的底层原理："></a><code>Map.get(k)</code>的底层原理：</h3><p>先调用k的<code>HashCode()</code>方法得出哈希值，通过哈希算法转换成数组下标，通过数组下标快速定位到某个位置上，如果这个位置上什么也没有，返回null，如果这个位置上有单向链表，那么会拿着参数k和单向链表上的每个节点中的k进行<code>equals</code>，如果所有<code>equals</code>方法返回false，那么get方法返回null，只要其中有一个节点的k和参数k <code>equals</code>的时候返回true，那么此时这个节点的value就是我们要找的<code>value</code>，<code>get</code>方法最终返回这个要找的<code>vlaue</code>。</p>
<h2 id="同时重写equals和hashCode"><a href="#同时重写equals和hashCode" class="headerlink" title="同时重写equals和hashCode"></a>同时重写<code>equals</code>和<code>hashCode</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String &gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//Integer,String的hashCode和equals都重写了</span></span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>,<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>,<span class="string">&quot;KING&quot;</span>);<span class="comment">//key相同，会自动覆盖value</span></span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set=map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,String&gt; entry:set)&#123;</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">&quot;=&quot;</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span>=张三</span><br><span class="line"><span class="number">2</span>=李四</span><br><span class="line"><span class="number">3</span>=王五</span><br><span class="line"><span class="number">4</span>=KING</span><br></pre></td></tr></table></figure>

<p>注意：放在<code>HashMap</code>集合key部分的元素，以及放在<code>HashSet</code>集合中的元素，需要同时重写<code>hashCode</code>和<code>equals</code>方法。</p>
<p><code>HashMap</code>集合的默认初始化容量是16，默认加载因子是0.75。这个默认加载因子是当<code>HashMap</code>集合底层数组的容量达到75%的时候，数组开始扩容。</p>
<p>***<code>hashCode()</code>方法和<code>equasl()</code>方法都可以用IDEA工具生成，但是这两个方法需要同时生成。**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* public boolean equals(Object obj)&#123;</span></span><br><span class="line"><span class="comment">        if (obj==null || !(obj instanceof Student)) return  false;</span></span><br><span class="line"><span class="comment">        if (obj== this) return  true;</span></span><br><span class="line"><span class="comment">        Student s=(Student) obj;</span></span><br><span class="line"><span class="comment">        return this.name.equals(s.name);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1=<span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Student s2=<span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        System.out.println(s1.hashCode());</span><br><span class="line">        System.out.println(s2.hashCode());</span><br><span class="line">        Set&lt;Student&gt; students=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        students.add(s1);</span><br><span class="line">        students.add(s2);</span><br><span class="line">        System.out.println(students.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">774920</span></span><br><span class="line"><span class="number">774920</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="HashMap和Hashtable区别"><a href="#HashMap和Hashtable区别" class="headerlink" title="HashMap和Hashtable区别"></a><code>HashMap</code>和<code>Hashtable</code>区别</h3><p>1、<code>Hashtable</code>的key和value都是不能为null的</p>
<p>​      <code>HashMap</code>集合的key和value都是可以为null的</p>
<p>2、<code>Hashtable</code>方法都带有synchronized：线程安全的</p>
<p>线程安全有其他的方案，这个<code>Hashtable</code>对线程的处理导致效率较低，使用较少</p>
<p>3、<code>Hashtable</code>和<code>HashMap</code>一样，底层都是哈希表数据结构</p>
<h2 id="属性类Properties类"><a href="#属性类Properties类" class="headerlink" title="属性类Properties类"></a>属性类<code>Properties</code>类</h2><p>1、<code>properties</code>是一个Map集合、继承<code>Hashtable</code>,<code>properties</code>的key和value都是String类型</p>
<p>2、其被称为属性类对象</p>
<p>3、是线程安全的</p>
<ul>
<li><ul>
<li><ul>
<li><p>```<br>public Object setProperty(String key,                       String value)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      致电`Hashtable`方法`put` 。  提供与`getProperty`方法的`并行性` 。  强制使用字符串的属性键和值。  返回的值是`Hashtable`调用`put`的结果。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `key` - 要放入此属性列表的关键字。 </span><br><span class="line"></span><br><span class="line">        `value` - 对应的值为 `key` 。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        此属性列表中指定键的上一个值，如果没有一个， `null` 。 </span><br><span class="line"></span><br><span class="line">      - 从以下版本开始： </span><br><span class="line"></span><br><span class="line">        1.2 </span><br><span class="line"></span><br><span class="line">      - 另请参见： </span><br><span class="line"></span><br><span class="line">        [`getProperty(java.lang.String)`](../../java/util/Properties.html#getProperty-java.lang.String-) </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public String getProperty(String key)</span><br></pre></td></tr></table></figure>

<p>使用此属性列表中指定的键搜索属性。  如果在此属性列表中找不到该键，则会默认属性列表及其默认值递归。  如果找不到属性，该方法返回<code>null</code> 。 </p>
<ul>
<li><p>参数 </p>
<p><code>key</code> - 属性键。 </p>
</li>
<li><p>结果 </p>
<p>该属性列表中具有指定键值的值。 </p>
</li>
<li><p>另请参见： </p>
<p><a href="../../java/util/Properties.html#setProperty-java.lang.String-java.lang.String-"><code>setProperty(java.lang.String,  java.lang.String)</code></a> ， <a href="../../java/util/Properties.html#defaults"><code>defaults</code></a> </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line">        pro.setProperty(<span class="string">&quot;url&quot;</span>,<span class="string">&quot;jdbc:mysql://localhost:3306/bjpowernode&quot;</span>);</span><br><span class="line">        pro.setProperty(<span class="string">&quot;dirver&quot;</span>,<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        pro.setProperty(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        pro.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String url= pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String dirver= pro.getProperty(<span class="string">&quot;dirver&quot;</span>);</span><br><span class="line">        String username= pro.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password= pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(url);</span><br><span class="line">        System.out.println(dirver);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        System.out.println(password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/bjpowernode</span></span><br><span class="line">com.mysql.jdbc.Driver</span><br><span class="line">root</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h2 id="TreeSet对String是可排序的"><a href="#TreeSet对String是可排序的" class="headerlink" title="TreeSet对String是可排序的"></a><code>TreeSet</code>对String是可排序的</h2><p>1、<code>Treeset</code>集合底层实际是一个<code>TreeMap</code></p>
<p>2、<code>TreeMap</code>集合底层是一个二叉树</p>
<p>3、放到<code>TreeSet</code>集合中的元素，等同于放到<code>TreeMap</code>集合key部分</p>
<p>4、<code>TreeSet</code>集合中的元素：无序不可重复，但是可以按照元素大小顺序自动排序，称为；可排序集合</p>
<p> <code>TreeSet</code>对自定义类型是不可排序的</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>集合总结，IO流概述及主要的流</title>
    <url>/2021/07/04/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20038%EF%BC%88%E9%9B%86%E5%90%88%E7%9A%84%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9%E3%80%81IO%E6%B5%81%E6%A6%82%E8%BF%B0%E3%80%81%E4%B8%BB%E8%A6%81%E7%9A%84%E6%B5%81%E3%80%81FileInputStream%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<h2 id="集合的主要内容"><a href="#集合的主要内容" class="headerlink" title="集合的主要内容"></a>集合的主要内容</h2><p>1、每个集合对象的创建</p>
<p>2、向集合中添加元素</p>
<span id="more"></span>
<p>3、从集合中取出某个元素</p>
<p>4、遍历集合</p>
<p>5、主要的集合类：<code>ArrayList</code>  <code>LinkedList</code> <code>HashSet</code> <code>TreeSet</code> <code>HashMap</code> <code>Properties</code> <code>TreeMap</code></p>
<h2 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h2><p>I:Input</p>
<p>O:Output</p>
<h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><p><strong>按照流的方向进行分类</strong>：往内存中去，叫做输入（读）</p>
<p>​                                        从内存中出来，叫做输出（写）</p>
<p><strong>按照读取数据方式：</strong> 按照字节的方式读取数据，一次读取1个字节byte，等同于一次读取8个二进制，（万能）</p>
<p>​                                  按照字符的方式读取数据，一次读取一个字符，这种流是为了方便读取普通文本文件而存在的。</p>
<p>***<code>java.io.InputStream</code>字节输入流                     <code>java.io.OutputStream</code>字节输出流                              <code>java.io.Reader</code>  字符输入流                                <code>java.io.Writer</code>字符输出流  ***</p>
<p>其都是抽象类 （abstract class）</p>
<p>“a”英文字母，再windows操作系统当中是一个字节，但在java中占有2个字节</p>
<p>java中所有的流都在<code>java.io</code>包下</p>
<p>*** 注意：java中只要“类名”以Stream结尾的都是字节流，以”Reader/Writer“结尾的都是字符流 ***</p>
<p>所有的流都是可关闭的</p>
<h2 id="流的close和flush方法"><a href="#流的close和flush方法" class="headerlink" title="流的close和flush方法"></a>流的close和flush方法</h2><p>所有的输出流都实现了：<code>java.io.Flushable</code>接口，是可刷新的，都有<code>flush()</code>方法。（输出流再输出完毕后，记得flush()）刷新一下，这个刷新表示将通道/管道当中剩余为输出的数据强行输出完，刷新的作用就是清空数值。</p>
<p>注意：如果没有<code>flush()</code>，可能会导致数据丢失</p>
<h2 id="主要的流"><a href="#主要的流" class="headerlink" title="主要的流"></a>主要的流</h2><p>文件专属：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.FileInputStream</span><br><span class="line">java.io.FileOutputStream</span><br><span class="line">java.io.FileReader</span><br><span class="line">java.io.FileWriter</span><br></pre></td></tr></table></figure>

<p>转换流：（将字节流转化成字符流）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.InputStreamReader</span><br><span class="line">java.io.OutputStreamWriter</span><br></pre></td></tr></table></figure>

<p>缓冲流专属：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.BufferedReader</span><br><span class="line">java.io.BufferedWriter</span><br><span class="line">java.io.BufferedInputStream</span><br><span class="line">java.io.BufferedOutputStream</span><br></pre></td></tr></table></figure>

<p>数据流专属：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.DataInputStream</span><br><span class="line">java.io.DataOutputStream</span><br></pre></td></tr></table></figure>

<p>标准输出流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.PrintWriter</span><br><span class="line">java.io.PrintStream</span><br></pre></td></tr></table></figure>

<p>对象专属流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.ObjectInputStream</span><br><span class="line">java.io.ObjectOutputStream</span><br></pre></td></tr></table></figure>

<h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a><code>FileInputStream</code></h2><p>1、文件字节输入流，万能的，任何类型的文件都可以采用这个流来读</p>
<p>2、字节的方式，</p>
<ul>
<li><ul>
<li><ul>
<li>```<br>public int read()<pre><code>     throws IOException
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      从该输入流读取一个字节的数据。 如果没有输入可用，此方法将阻止。 </span><br><span class="line"></span><br><span class="line">      - Specified by: </span><br><span class="line"></span><br><span class="line">        `read`在  `InputStream` </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        **数据的下一个字节，如果达到文件的末尾， `-1` 。** </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `IOException` - 如果发生I / O错误。 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Test01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建文件字节输入流对象</span><br><span class="line">        //文件路径：E:\study\Test03\IO_Test\temp.txt,但需要把单斜杠转化为双斜杠</span><br><span class="line">        FileInputStream f1=null;</span><br><span class="line">        try &#123;</span><br><span class="line">             f1=new FileInputStream(&quot;E:\\study\\Test03\\IO_Test\\temp.txt&quot;);</span><br><span class="line">             int readDate=f1.read();//此方法返回值是：读取到的“字节”本身；</span><br><span class="line">            System.out.println(readDate);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;//再finally语句块当中要确保把流关闭！</span><br><span class="line">            if (f1!=null)&#123;//关闭流的前提是：流不为空</span><br><span class="line">                try&#123;</span><br><span class="line">                    f1.close();</span><br><span class="line">                &#125;catch (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">97</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>改进后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream f2=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f2=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\temp.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> readDate=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readDate = f2.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(readDate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (f2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f2.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br></pre></td></tr></table></figure>

<p>以上程序的缺点：一次读取一个字节，内存和硬盘交互过于频繁，资源耗费大。</p>
<ul>
<li><ul>
<li><ul>
<li><p>```<br>public int read(byte[] b)</p>
<pre><code>     throws IOException
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      从该输入流读取最多`b.length`字节的数据到字节数组。  此方法将阻塞，直到某些输入可用。 </span><br><span class="line"></span><br><span class="line">      - 重写： </span><br><span class="line"></span><br><span class="line">        `read`在  `InputStream`类 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `b` - 读取数据的缓冲区。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        读入缓冲区的总字节数，如果没有更多的数据，因为文件的结尾已经到达， `-1` 。 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `IOException` - 如果发生I / O错误。 </span><br><span class="line"></span><br><span class="line">      - 另请参见： </span><br><span class="line"></span><br><span class="line">        [`InputStream.read(byte[\],  int, int)`](../../java/io/InputStream.html#read-byte:A-int-int-) </span><br><span class="line"></span><br><span class="line">IDEA 默认的当前路径是：工程Project的根</span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      ublic String(byte[] bytes)</span><br></pre></td></tr></table></figure>

<p>通过使用平台的默认字符集解码指定的字节数组来构造新的<code>String</code> 。新的<code>String</code>的长度是字符集的函数，因此可能不等于字节数组的长度。</p>
<p>指定字节在默认字符集中无效时，此构造函数的行为是未指定的。 当需要对解码过程进行更多的控制时，应使用<a href="../../java/nio/charset/CharsetDecoder.html"><code>CharsetDecoder</code></a>类。 </p>
<ul>
<li><p>参数 </p>
<p><code>bytes</code> - 要解码为字符的字节 </p>
</li>
<li><p>从以下版本开始： </p>
<p>JDK1.1 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>public String(byte[] bytes,<pre><code>          int offset,
          int length)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      通过使用平台的默认字符集解码指定的字节子阵列来构造新的`String` 。新的`String`的长度是字符集的函数，因此可能不等于子数组的长度。</span><br><span class="line"></span><br><span class="line">      指定字节在默认字符集中无效时，此构造函数的行为是未指定的。 当需要更多的解码过程控制时，应使用[`CharsetDecoder`](../../java/nio/charset/CharsetDecoder.html)类。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `bytes` - 要解码为字符的字节 </span><br><span class="line"></span><br><span class="line">        `offset` - 要解码的第一个字节的索引 </span><br><span class="line"></span><br><span class="line">        `length` - 要解码的字节数 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `IndexOutOfBoundsException`  - 如果 `offset`和 `length`参数的索引字符在 `bytes`数组的边界之外 </span><br><span class="line"></span><br><span class="line">      - 从以下版本开始： </span><br><span class="line"></span><br><span class="line">        JDK1.1 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Test03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileInputStream f3=null;</span><br><span class="line">        try &#123;</span><br><span class="line">            f3=new FileInputStream(&quot;E:\\study\\Test03\\IO_Test\\temp.txt&quot;);</span><br><span class="line">            byte[] bytes1=new byte[4];//创建一个4个长度的byte数组，表示一次可读取4个字节</span><br><span class="line">            int readCount = f3.read(bytes1);//这个方法的返回值：读取的字节数量（并不是字节本身），它将字节读取到了bytes数组中</span><br><span class="line">            System.out.println(readCount);//4,第一次读取到4个字节</span><br><span class="line">            //System.out.println(new String(bytes1));//abcd</span><br><span class="line">            //不应该全部都转换，应该是读取了多少个字节，转换多少个</span><br><span class="line">            System.out.println(new String(bytes1,0,readCount));//abcd</span><br><span class="line">            readCount = f3.read(bytes1);</span><br><span class="line">            System.out.println(readCount);//2,第二次读取到2个字节，同样存放在数组中，但会把头两个数据覆盖</span><br><span class="line">            //如果在调用这个方法，则会返回-1</span><br><span class="line">            //System.out.println(new String(bytes1));//efcd</span><br><span class="line">            System.out.println(new String(bytes1,0,readCount));//ef</span><br><span class="line"></span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (f3 != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    f3.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>改进后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream f3=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f3=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\temp.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            while(true)&#123;</span></span><br><span class="line"><span class="comment">                int readCount =f3.read(bytes);</span></span><br><span class="line"><span class="comment">                if (readCount == -1)&#123;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                //把byte数组转换成字符串</span></span><br><span class="line"><span class="comment">                System.out.println(new String(bytes,0,readCount));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> readCount =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount = f3.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,readCount));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (f3 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f3.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abcdef</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>标准输出流，File类的理解，序列化和反序列化</title>
    <url>/2021/07/04/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20040%EF%BC%88%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%8CFile%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89/</url>
    <content><![CDATA[<h2 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.PrintWriter</span><br><span class="line">java.io.PrintStream</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>1、<code>java.io.PrintStream</code>：标准的字节输出流，默认输出到控制台</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">        PrintStream p1=System.out;</span><br><span class="line">        p1.println(<span class="string">&quot;hello,kitty&quot;</span>);</span><br><span class="line">        <span class="comment">//标准输出流不需要手动close（）关闭</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//改变标准输出流的输出方向</span></span><br><span class="line">        <span class="comment">//标准输出流不再指向控制台，指向E:\study\Test03\IO_Test\printstream文件</span></span><br><span class="line">        PrintStream printStream=<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\printstream&quot;</span>));</span><br><span class="line">        System.setOut(printStream);</span><br><span class="line">        System.out.println(printStream);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,kitty&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志工具</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//指向一个日志文件</span></span><br><span class="line">            PrintStream out=<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;log.txt&quot;</span>,<span class="keyword">true</span>));</span><br><span class="line">            <span class="comment">//改变输出方向</span></span><br><span class="line">            System.setOut(out);</span><br><span class="line">            <span class="comment">//日期当前时间</span></span><br><span class="line">            Date nowTime =<span class="keyword">new</span> Date();</span><br><span class="line">            SimpleDateFormat sdf =<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">            String strTime=sdf.format(nowTime);</span><br><span class="line">            System.out.println(strTime+<span class="string">&quot;:&quot;</span>+msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="File类的理解"><a href="#File类的理解" class="headerlink" title="File类的理解"></a>File类的理解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.File</span><br></pre></td></tr></table></figure>

<p>1、File类和四大家族没有关系，File类无法完成文件的读写。</p>
<p>2、其代表文件和目录路径名的抽象表示形式</p>
<p><code>E:\study\Test03\IO_Test</code></p>
<p><code>E:\study\Test03\IO_Test\a.txt</code></p>
<p>其都是File对象，其可能是目录也可能是文件</p>
<h3 id="File类的常用方法"><a href="#File类的常用方法" class="headerlink" title="File类的常用方法"></a>File类的常用方法</h3><ul>
<li><ul>
<li><ul>
<li><p>```<br>public boolean createNewFile()</p>
<pre><code>                  throws IOException
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      当且仅当具有该名称的文件尚不存在时，原子地创建一个由该抽象路径名命名的新的空文件。检查文件的存在和文件的创建（如果不存在）是对可能影响文件的所有其他文件系统活动是单一的操作。</span><br><span class="line"></span><br><span class="line">      注意：此方法*不*应用于文件锁定，因为生成的协议不能使其可靠地工作。 应该使用[`FileLock`](../../java/nio/channels/FileLock.html)设施。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        `true`如果命名文件不存在并被成功创建;  `false`如果命名文件已经存在 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `IOException` - 如果发生I / O错误 </span><br><span class="line"></span><br><span class="line">        `SecurityException` -  如果存在安全管理员，并且其 `SecurityManager.checkWrite(java.lang.String)`方法拒绝对该文件的写入访问 </span><br><span class="line"></span><br><span class="line">      - 从以下版本开始： </span><br><span class="line"></span><br><span class="line">        1.2 </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public boolean exists()</span><br></pre></td></tr></table></figure>

<p>测试此抽象路径名表示的文件或目录是否存在。 </p>
<ul>
<li><p>结果 </p>
<p><code>true</code>当且仅当存在由此抽象路径名表示的文件或目录时;  <code>false</code>否则 </p>
</li>
<li><p>异常 </p>
<p><code>SecurityException</code> -  如果安全管理器存在，并且其 <code>SecurityManager.checkRead(java.lang.String)</code>方法拒绝对文件或目录的读取访问 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>```<br>public boolean mkdir()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      创建由此抽象路径名命名的目录。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        `true`当且仅当该目录被创建时; `false`否则 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `SecurityException` -  如果存在安全管理员，并且其 `SecurityManager.checkWrite(java.lang.String)`方法不允许创建命名目录 </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public boolean mkdirs()</span><br></pre></td></tr></table></figure>

<p>创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录。  请注意，如果此操作失败，它可能已成功创建一些必需的父目录。 </p>
<ul>
<li><p>结果 </p>
<p><code>true</code>当且仅当该目录已创建，以及所有必需的父目录;  <code>false</code>否则 </p>
</li>
<li><p>异常 </p>
<p><code>SecurityException</code> -  如果安全管理器存在，并且其<code>SecurityManager.checkRead(java.lang.String)</code>方法不允许验证命名目录和所有必需的父目录的存在;  或者如果<code>SecurityManager.checkWrite(java.lang.String)</code>方法不允许创建命名目录和所有必需的父目录 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>```<br>public String getParent()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回此抽象路径名的父`null`的路径名字符串，如果此路径名未命名为父目录，则返回null。</span><br><span class="line"></span><br><span class="line">      抽象路径名的*父项*由路径名的前缀（如果有）和路径名的名称序列中的每个名称组成，除了最后一个。  如果名称序列为空，则路径名不会指定父目录。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        由此抽象路径名命名的父目录的路径名字符串，或 `null`如果此路径名未命名为父</span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public File getParentFile()</span><br></pre></td></tr></table></figure>

<p>返回此抽象路径名的父<code>null</code>抽象路径名，如果此路径名未命名为父目录，则返回null。</p>
<p>抽象路径名的<em>父项</em>由路径名的前缀（如果有）和路径名的名称序列中的每个名称组成，除了最后一个。  如果名称序列为空，则路径名不会指定父目录。 </p>
<ul>
<li><p>结果 </p>
<p>由此抽象路径名命名的父目录的抽象路径名，或 <code>null</code>如果此路径名未命名为父 </p>
</li>
<li><p>从以下版本开始： </p>
<p>1.2 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean delete()</span><br></pre></td></tr></table></figure>

<p>删除由此抽象路径名表示的文件或目录。如果此路径名表示目录，则目录必须为空才能删除。</p>
<p>请注意， <a href="../../java/nio/file/Files.html"><code>Files</code></a>类定义了一个<a href="../../java/nio/file/Files.html#delete-java.nio.file.Path-"><code>delete</code></a>方法，当一个文件不能被删除时，它会抛出一个<a href="../../java/io/IOException.html"><code>IOException</code></a> 。  这对于错误报告和诊断文件无法被删除的原因很有用。 </p>
<ul>
<li><p>结果 </p>
<p><code>true</code>当且仅当文件或目录被成功删除时;  <code>false</code>否则 </p>
</li>
<li><p>异常 </p>
<p><code>SecurityException</code> -  如果安全管理器存在，并且其 <code>SecurityManager.checkDelete(java.lang.String)</code>方法拒绝对该文件的删除访问 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>```<br>public String getName()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回由此抽象路径名表示的文件或目录的名称。  这只是路径名称序列中的最后一个名字。 如果路径名的名称序列为空，则返回空字符串。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        由此抽象路径名表示的文件或目录的名称，如果此路径名的名称序列为空，则为空字符串 </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public boolean isDirectory()</span><br></pre></td></tr></table></figure>

<p>测试此抽象路径名表示的文件是否为目录。</p>
<p>在需要区分I / O异常和文件不是目录的情况下，或同时需要同一文件的几个属性的情况下，可以使用<a href="../../java/nio/file/Files.html#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-"><code>Files.readAttributes</code></a>方法。 </p>
<ul>
<li><p>结果 </p>
<p><code>true</code>当且仅当该抽象路径名表示的文件存在<em>且</em>为目录时;  <code>false</code>否则 </p>
</li>
<li><p>异常 </p>
<p><code>SecurityException</code> -  如果安全管理器存在，并且其 <code>SecurityManager.checkRead(java.lang.String)</code>方法拒绝对该文件的读取访问 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>```<br>public boolean isFile()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      测试此抽象路径名表示的文件是否为普通文件。如果文件不是目录，并且另外满足其他依赖于系统的条件，文件是*正常的* 。Java应用程序创建的任何非目录文件都保证是一个普通文件。</span><br><span class="line"></span><br><span class="line">      在需要区分I / O异常与文件不是正常文件的情况下，或同时需要同一文件的几个属性的情况下，可以使用[`Files.readAttributes`](../../java/nio/file/Files.html#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-)方法。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        `true`当且仅当该抽象路径名表示的文件存在*且*为普通文件时;  `false`否则 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `SecurityException` -  如果安全管理器存在，并且其 `SecurityManager.checkRead(java.lang.String)`方法拒绝对该文件的读取访问 </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public long lastModified()</span><br></pre></td></tr></table></figure>

<p>返回此抽象路径名表示的文件上次修改的时间。</p>
<p>凡需要从那里的情况下区分I /  O异常<code>0L</code>返回，或者在同一时间都需要在同一文件的多个属性，或者在需要的上次访问或创建时间的时间，那么可以使用<a href="../../java/nio/file/Files.html#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-"><code>Files.readAttributes</code></a>方法。 </p>
<ul>
<li><p>结果 </p>
<p><code>long</code>值表示上次修改文件的时间，以时间为单位（1970年1月1日00:00:00 GMT）测量，或者如果文件不存在  <code>0L</code> ，或者如果发生I / O错误 </p>
</li>
<li><p>异常 </p>
<p><code>SecurityException</code> -  如果存在安全管理员，并且其 <code>SecurityManager.checkRead(java.lang.String)</code>方法拒绝对文件的读取访问 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>```<br>public File[] listFiles()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回一个抽象路径名数组，表示由该抽象路径名表示的目录中的文件。</span><br><span class="line"></span><br><span class="line">      如果此抽象路径名不表示目录，则此方法返回`null` 。  否则将返回一个`File`对象的数组，一个用于目录中的每个文件或目录。  表示目录本身和目录的父目录的路径名不包括在结果中。 每个生成的抽象路径名由使用[`File(File, String)`](../../java/io/File.html#File-java.io.File-java.lang.String-)构造函数的抽象路径名构造。  因此，如果这个路径名是绝对的，那么每个生成的路径名是绝对的;  如果此路径名是相对的，那么每个生成的路径名将相对于相同的目录。 </span><br><span class="line"></span><br><span class="line">      不保证结果数组中的名称字符串将以任何特定的顺序出现; 他们不是特别保证按字母顺序出现。 </span><br><span class="line"></span><br><span class="line">      请注意， [`Files`](../../java/nio/file/Files.html)类定义了[`newDirectoryStream`](../../java/nio/file/Files.html#newDirectoryStream-java.nio.file.Path-)方法来打开目录并遍历目录中文件的名称。  当使用非常大的目录时，这可能会减少资源。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        一组抽象路径名，表示由此抽象路径名表示的目录中的文件和目录。 如果目录为空，则该数组将为空。  如果此抽象路径名不表示目录，或返回I / O错误，则返回`null` 。 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `SecurityException` -  如果存在安全管理员，并且其 [`SecurityManager.checkRead(String)`](../../java/lang/SecurityManager.html#checkRead-java.lang.String-)方法拒绝对目录的读取访问 </span><br><span class="line"></span><br><span class="line">      - 从以下版本开始： </span><br><span class="line"></span><br><span class="line">        1.2 </span><br><span class="line"></span><br><span class="line">## 序列化和反序列化的理解</span><br><span class="line"></span><br><span class="line">序列化：`Serialize`   java对象存储到文件中，将java对象的状态保存下来</span><br><span class="line"></span><br><span class="line">反序列化：`DeSerialize`   将硬盘上的数据重新恢复到内存当中，恢复成java对象</span><br><span class="line"></span><br><span class="line">1、参与序列化和反序列化的对象，必须实现Serializable接口</span><br><span class="line"></span><br><span class="line">2、这个接口只是一个标志接口</span><br><span class="line"></span><br><span class="line">一个Java对象要能序列化，必须实现一个特殊的`java.io.Serializable`接口，它的定义如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>  <span class="keyword">implements</span>  <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  String no;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,String no)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.no=no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(String no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Student s=<span class="keyword">new</span> Student(<span class="string">&quot;1111&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;student&quot;</span>));</span><br><span class="line">        oos.writeObject(s);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">        Object obj=ois.readObject();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>java集合框架，具体集合及映射</title>
    <url>/2021/08/04/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%85%B7%E4%BD%93%E9%9B%86%E5%90%88%E5%8F%8A%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id="集合接口与实现分离"><a href="#集合接口与实现分离" class="headerlink" title="集合接口与实现分离"></a>集合接口与实现分离</h2><p>以队列（queue）为例，说明接口与实现分离</p>
<span id="more"></span>
<p><code>队列接口</code>指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查找队列中元素的个数，并按照“先进先出”方式检索对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口并没有说明队列是如何实现的，队列通常有两种实现方式：一种是使用循环数组，另一种是使用链表。如果需要一个循环数组队列，可以使用<code>ArrayDeque</code>类，如果需要一个链表队列，就直接使用<code>LinkedList</code>类，这个类实现了<code>Queue</code>接口</p>
<p>当在程序中使用队列时，一旦已经构造了集合，就不需要知道究竟使用了哪种实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> ArrayDeque&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> LinkedList&lt;&gt;(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>循环数组是一个有界集合，即容量有限，如果要收集的对象没有上限，就要使用链表来实现。</p>
<p>如果想要实现自己的队列类，会发现扩展<code>AbstractQueue</code>类要比实现<code>Queue</code>接口中的所有方法轻松得多。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>集合类的基本接口是Collection接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    ……</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>add方法用于向集合中添加元素，如果添加成功，返回true，否则返回false。</li>
<li>iterator方法用于返回一个实现了Iterator接口的对象，可以使用这个迭代器对象依次访问集合中的元素。</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Iterator接口包含4个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Cusumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用next方法访问集合中元素时，需要提前使用hasNext方法，如果迭代器对象还有多个可以访问的元素，则返回true，再使用next方法访问集合中的下一个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; c =……;</span><br><span class="line">Iterator&lt;String&gt; iter =c.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">    String element =iter.next();</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样使用<code>for-each</code>循环可以更加简介</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String element:c)&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器简单地将<code>for-each</code>循环转换为带有迭代器的循环。<code>for-each</code>循环可以处理任何实现了Iterable接口的对象，这个接口只包含一个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Collection接口扩展了Iterable接口，因此，对于标准类库中的任何集合都可以使用<code>for-each</code>循环。</p>
<p>java迭代器位于两个元素之间，当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。Iterator接口的remove方法会删除上次调用next方法时返回的元素，这意味着remove和next之间存在依赖性，在大多数情况下，在决定删除某个元素之前应该先看一下这个元素，这是合理的，不过，如果想要删除指定位置上的元素，仍然需要迭代器越过这个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">it.next();</span><br><span class="line">it.remove();</span><br></pre></td></tr></table></figure>

<p>如果要删除两个相邻的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">it.remove();</span><br><span class="line">it.remove();</span><br></pre></td></tr></table></figure>

<p>这是不合法的，必须先调用next越过将要删除的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">it.remove();</span><br><span class="line">it.next();</span><br><span class="line">it.remove();</span><br></pre></td></tr></table></figure>

<h2 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h2><p><img src="/2021/08/04/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%85%B7%E4%BD%93%E9%9B%86%E5%90%88%E5%8F%8A%E6%98%A0%E5%B0%84/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E6%8E%A5%E5%8F%A3.png"></p>
<p>集合有两个基本接口：Collection和Map。</p>
<p>List是一个有序集合，元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问，后面这种方法称为随机访问。</p>
<p>ListIterator接口是Iterator的一个子接口，它定义了一个方法用于在迭代器位置前面增加一个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Set接口等同于Collection接口，不过其方法的行为有更严谨的定义，集（Set）的add方法不允许增加重复的元素，要适合地定义集的equals方法：只要两个集包含同样的元素就认为它们是相等的，而不要求这些元素有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码。</p>
<h2 id="具体集合"><a href="#具体集合" class="headerlink" title="具体集合"></a>具体集合</h2><p>除了以Map结尾的类之外，其他类都实现了Collection接口，而以Map结尾的类实现了Map接口</p>
<table>
<thead>
<tr>
<th>集合类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可以动态增长和缩减的一个索引序列</td>
</tr>
<tr>
<td>LinkedList</td>
<td>可以在任何位置高效插入和删除的一个有序序列</td>
</tr>
<tr>
<td>ArrayDeque</td>
<td>实现为循环数组的一个双端队列</td>
</tr>
<tr>
<td>HashSet</td>
<td>没有重复元素的一个无序集合</td>
</tr>
<tr>
<td>TreeSet</td>
<td>一个有序集</td>
</tr>
<tr>
<td>EnumSet</td>
<td>一个包含枚举类型值的集</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>一个可以记住元素插入次序的集</td>
</tr>
<tr>
<td>PriorityQueue</td>
<td>允许高效删除最小元素的一个集合</td>
</tr>
<tr>
<td>HashMap</td>
<td>存储键/值关联的一个数据结构</td>
</tr>
<tr>
<td>TreeMap</td>
<td>键有序的一个映射</td>
</tr>
<tr>
<td>EnumMap</td>
<td>键属于枚举类型的一个映射</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>可以记住键/值项添加次序的一个映射</td>
</tr>
<tr>
<td>WeakHashMap</td>
<td>值不会再别处使用时就可以被垃圾回收的一个映射</td>
</tr>
<tr>
<td>IdentityHashMap</td>
<td>用==而不是用equals比较键的一个映射</td>
</tr>
</tbody></table>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>因为在数组或者数组列表中删除某个元素需要将这个元素之后的所有元素向前移动，所需的开销很大，而在链表中，删除某个元素只需更新元素周围的链接即可。</p>
<p>java集合类库提供的LinkedList可以很方便的删除和添加元素。</p>
<p>例如：先添加3个元素，在将第二个元素删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> staff = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">staff.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iter = staff.iterator();</span><br><span class="line">String first=iter.next();</span><br><span class="line">String second=iter.next();</span><br><span class="line">iter.remove();</span><br></pre></td></tr></table></figure>

<p>在实际开发中，我们常常需要将一个元素添加到链表中间的某个位置，但使用LinkedList.add方法会把元素添加到链表的末尾，实际上，集合类库提供了一个子接口ListIterator，其中包含add方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ListTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test001</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个集合，先添加三个元素，abc，再将b删除，然后使用迭代器恢复原状</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        staff.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        staff.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        staff.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iter =  staff.iterator();</span><br><span class="line">        String first = iter.next();</span><br><span class="line">        String second = iter.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;first=&quot;</span>+first+<span class="string">&quot;   second=&quot;</span>+second);</span><br><span class="line">        iter.remove();<span class="comment">//将“b“删除掉</span></span><br><span class="line">        ListIterator&lt;String&gt; liter = staff.listIterator();</span><br><span class="line">        <span class="comment">/*使用LinkedList.add方法会将对象添加到链表的尾部，</span></span><br><span class="line"><span class="comment">        但如果想要将某个元素添加到链表的中间，则需要使用集合</span></span><br><span class="line"><span class="comment">        类库提供的一个子接口ListIterator，其中包含add方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        liter.next();</span><br><span class="line">        liter.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//再创建一个迭代器，遍历整个集合</span></span><br><span class="line">        Iterator&lt;String&gt; iter2 = staff.iterator();</span><br><span class="line">        String one = iter2.next();</span><br><span class="line">        String two = iter2.next();</span><br><span class="line">        String three= iter2.next();</span><br><span class="line">        System.out.println(one+<span class="string">&quot; &quot;</span>+two+<span class="string">&quot; &quot;</span>+three);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first=a   second=b</span><br><span class="line">a b c</span><br></pre></td></tr></table></figure>

<p>ListIterator接口还有两个方法，可以用来反向遍历链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">previous</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>当用一个刚由ListIterator方法返回并指向链表表头的迭代器调用add操作时，新添加的元素将变成列表的新表头，当迭代器越过链表的最后一个元素时（即hasNext返回为false），添加的元素将成为列表的新表尾。</p>
<p>set方法用一个新元素替换调用next或previous方法返回的上一个元素。下面代码将用一个新值替换链表的第一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListIterator&lt;String&gt; iter=list.listIterator();</span><br><span class="line">String oldValue = iter.next();</span><br><span class="line">iter.set(newValue);</span><br></pre></td></tr></table></figure>

<p>再某些情况下，某个迭代器修改集合时，另一个迭代器正在遍历集合，那么一定会出现错误。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list=……;</span><br><span class="line">ListIterator&lt;String&gt; iter1=list.ListIterator();</span><br><span class="line">ListIterator&lt;String&gt; iter2=list.ListIterator();</span><br><span class="line">iter1.next();</span><br><span class="line">iter1.remove();</span><br><span class="line">iter2.next;<span class="comment">//会抛出一个ConcurrentModificationException异常</span></span><br></pre></td></tr></table></figure>

<p>为了避免发生并发修改异常，需遵循一个简单的规则：可以根据需要为一个集合关联多个迭代器，前提是这些迭代器只能读取集合，或者，再关联一个能同时读写的迭代器。</p>
<h3 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h3><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>散列表可以快速的查找对象，散列表为每个对象计算一个整数，成为散列码。有不同数据的对象将产生不同的散列码，注意：如果定义自己的类，必须实现自己的hashCode方法，实现的应该与equals方法兼容，即如果a.equals(b)为true，a与b必须有相同的散列码。</p>
<p>在java中，散列表用链表数组实现，每个列表被称为桶，查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。在实际存储中，如果一个对象得出的散列码在链表的位置上已经存在对象，这种情况称为散列冲突。</p>
<p>如果大致知道最终会有多少个元素插入到散列表中，就可以设置桶数，桶数是指用于收集有相同散列值的桶的数目，通常，将桶数设置成预计元素个数的百分之七十五至百分之一百五左右。</p>
<p>散列表如果太满，就需要<strong>再散列</strong>，创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。<strong>装填因子</strong>可以确定何时对散列表进行再散列。</p>
<p>对于java来说，它提供了一个HashSet类，其实现了基于散列表的集，可以用add方法添加元素，contains方法已经被重新定义，用来快速查找某个元素是否已经在集中。</p>
<p> 散列表迭代器将依次访问所有的桶，由于散列将元素分散在表中，所以会有一种随机的顺序访问元素，所以只有在不关心元素存储顺序的情况下才使用HashSet。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SetTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;China&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Chinese&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;America&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;美国&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;American&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;美国人&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Japan&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iter =set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">            System.out.print(iter.next()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">美国 美国人 中文 American China Japan America 中国 Chinese </span><br></pre></td></tr></table></figure>



<h4 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h4><p>在了解树集之间，需要了解Comparable和Comparator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：Arrays类中的sort方法承诺可以对对象数组进行排序，但要求对象所属的类必须实现Comparable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ComparableTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee[] staff= <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">        staff[<span class="number">0</span>]=<span class="keyword">new</span> Employee(<span class="string">&quot;red&quot;</span>,<span class="number">100000</span>);</span><br><span class="line">        staff[<span class="number">1</span>]=<span class="keyword">new</span> Employee(<span class="string">&quot;blue&quot;</span>,<span class="number">2000</span>);</span><br><span class="line">        staff[<span class="number">2</span>]=<span class="keyword">new</span> Employee(<span class="string">&quot;green&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Arrays.sort(staff);</span><br><span class="line">        <span class="keyword">for</span> (Employee e:staff)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name=&quot;</span>+e.getName()+<span class="string">&quot;  salary=&quot;</span>+e.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,<span class="keyword">double</span> salary)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.salary=salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise=salary * byPercent /<span class="number">100</span>;</span><br><span class="line">        salary+=raise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary,o.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name=blue  salary=<span class="number">2000.0</span></span><br><span class="line">name=green  salary=<span class="number">5000.0</span></span><br><span class="line">name=red  salary=<span class="number">100000.0</span></span><br></pre></td></tr></table></figure>

<p>注意：String和Double都实现了Comparable接口</p>
<h4 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h4><p>在实际开发中，有些情况我们希望按长度递增的顺序对字符串进行排序，而不是按字典顺序进行排序，要处理这些情况，Array.sort方法还有第二个版本，有一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要按照长度比较字符串，需要定义一个实现了<code>Comparator&lt;String&gt;</code>的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first,String second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.length()-second.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ComparableTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test002</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在比较器上进行比较</span></span><br><span class="line">        AgeComparator comp =<span class="keyword">new</span> AgeComparator();</span><br><span class="line">        home a1 = <span class="keyword">new</span> home(<span class="string">&quot;001&quot;</span>,<span class="string">&quot;小明&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        home a2= <span class="keyword">new</span> home(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;小红&quot;</span>,<span class="number">15</span>);</span><br><span class="line">        <span class="keyword">if</span>(comp.compare(a1,a2)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小明更大&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小红更大&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对数组进行排序</span></span><br><span class="line">        home[] staff = <span class="keyword">new</span> home[<span class="number">2</span>];</span><br><span class="line">        staff[<span class="number">0</span>]=<span class="keyword">new</span> home(<span class="string">&quot;003&quot;</span>,<span class="string">&quot;小军&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        staff[<span class="number">1</span>]=<span class="keyword">new</span> home(<span class="string">&quot;004&quot;</span>,<span class="string">&quot;小菊&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Arrays.sort(staff,<span class="keyword">new</span> AgeComparator());</span><br><span class="line">        <span class="keyword">for</span> (home e:staff)&#123;</span><br><span class="line">            System.out.println(e.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">home</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(home first,home second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.getAge()-second.getAge();<span class="comment">//比较两者年龄的大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">home</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  String id;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">home</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">home</span><span class="params">(String id ,String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">小红更大</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<h4 id="树集"><a href="#树集" class="headerlink" title="树集"></a>树集</h4><p>树集是一个有序集合，可以以任意顺序将元素插入到集合中，但在对集合进行遍历时，会自动按照排序后的顺序呈现。排序是用一个树数据结构完成的，每次将一个元素添加到树中时，都会将其放置在正确的排序位置上，因此，迭代器总是以有序的顺序访问每个元素。</p>
<p>要使用树集，必须能够比较元素，这些元素必须实现Comparable接口，或者构造集时必须提供一个Comparator。</p>
<p>将一个元素添加到树中要比添加到散列表中慢，有些情况下，我们可能会想是否应该总是用树集而不是散列集，毕竟，添加一个元素所花费的时间看上去并不很长，而且元素是自动排序的。注意如果不需要数组是有序的，就没有必要付出排序的开销。</p>
<p>从java 6 起，TreeSet类实现了NavigableSet接口，这个接口增加了几个查找元素以及反向遍历的遍历方法。</p>
<h4 id="队列与双端队列"><a href="#队列与双端队列" class="headerlink" title="队列与双端队列"></a>队列与双端队列</h4><p>队列允许在尾部添加元素，并在头部删除元素。双端队列允许在头部和尾部都高效地添加或删除元素。</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>映射查找元素更为快捷和方便，其存放键/值对，如果提供了键，就能够查找到值。</p>
<h4 id="基本映射操作"><a href="#基本映射操作" class="headerlink" title="基本映射操作"></a>基本映射操作</h4><p>java类库为映射提供了两个通用的实现：HashMap和TreeMap，这两个类都实现了Map接口。散列映射对键进行散列，树映射根据键的顺序将元素组织为一个搜索树，散列或比较函数只应用于键，与键关联的值不进行散列或比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> staff = <span class="keyword">new</span> HashMap&lt;String,Employee&gt;();</span><br><span class="line"><span class="keyword">var</span> harry=<span class="keyword">new</span> Employee(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">staff.put(<span class="string">&quot;001&quot;</span>,harry);</span><br></pre></td></tr></table></figure>

<p>当往集合中存储元素时，必须同时提供一个键，以上的键是一个字符串，值是一个对象。如果想要检索一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&quot;0001&quot;</span>;</span><br><span class="line">Employee e = staff.get(id);</span><br></pre></td></tr></table></figure>

<p>如果映射没有存储与给定键对应的信息，则返回null，如果返回null不符合开发时的需要，则可以使用一个好的默认值，然后使用getOrDefault方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Interger&gt; sorces=……;</span><br><span class="line"><span class="keyword">int</span> sorces = sorces.getOrDefault(id,<span class="number">0</span>);<span class="comment">//如果查找不到id，则返回一个0</span></span><br></pre></td></tr></table></figure>

<p>键必须是唯一的，不能同时存放两个一样的键。</p>
<p>remove方法从映射中删除给定键对应的元素，size方法返回映射中的元素数。</p>
<h4 id="更新映射条目"><a href="#更新映射条目" class="headerlink" title="更新映射条目"></a>更新映射条目</h4><p>正常情况下，可以得到与一个键关联的原值，完成更新，再放回更新后的值，不过当键第一次出现时，可能会出现异常。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.put(word,counts.get(word)+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这是可以的，不过有一种情况除外：第一次看到word时，这种情况下，get会返回null，因此会出现一个NullPointerException异常。简单的补救方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.put(world,counts.getOrDefault(world,<span class="number">0</span>)+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>另一种方法是首先调用putIfAbsent方法，只有当键原先存在（或者映射到null）时才会放入一个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.putIfAbsent(word,<span class="number">0</span>);</span><br><span class="line">counts.put(word,counts.get(word)+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>不过merge方法可以简化这个常见操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.merge(word,<span class="number">1</span>,Integer::sum);</span><br></pre></td></tr></table></figure>

<p>将把word与1关联，否则使用Interger::sum函数组合原值和1（将原值与1求和）。</p>
<h4 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h4><p>可以得到映射的视图——这是实现了Collection接口或某个子接口的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span><span class="comment">//键集</span></span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span><span class="comment">//值集合</span></span></span><br><span class="line"><span class="function">Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span><span class="comment">//键/值对</span></span></span><br></pre></td></tr></table></figure>

<p>注意：映射条目集的元素是实现了Map.Entry接口的类的对象</p>
<p>如果想同时查看键和值，可以通过枚举映射条目来避免查找值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Employee&gt; entry : staff.entrySet())&#123;</span><br><span class="line">    String k = entry.getKey();</span><br><span class="line">    Employee v = entry.getValue();</span><br><span class="line">    <span class="keyword">do</span> something with k,v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="弱散列映射"><a href="#弱散列映射" class="headerlink" title="弱散列映射"></a>弱散列映射</h4><p>当一个值所对应的键已经不在程序的任何位置使用时，那么不再有任何途径可以引用这个值的对象了，程序的任何位置不会再有这个键了，无法从映射中删除这个键值对。同时，垃圾回收器也不能删除它，因为垃圾回收器会跟踪活动的对象，只要映射对象时活动的，其中的所有桶也就是活动的，不能被回收，只能由程序来负责从映射表中删除无用的键。</p>
<p>WeakHashMap就是为了解决这个问题而生的，当对键的唯一引用来自散列表映射的值时，WeakHashMap会和垃圾回收器一起删除键值对。怎么做到的呢？WeakHashMap使用弱引用保存键，WeakReference对象将包含另一个对象的引用，在这里，就是一个散列表键。当垃圾回收器发现某个对象只能由WeakReference引用时，垃圾回收器会将其回收，并且将引用这个对象的弱引用放入一个队列中，定期检查这个队列中新添加的弱引用，删除该弱引用对应的键的键值对。</p>
<h4 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h4><p>LinkedHashSet和LinkedHashMap类会记住插入元素项的顺序，可以避免散列表中的项看起来是随机的，或者可以使用访问顺序而不是插入顺序来迭代处理映射条目，每次调用get或put时，受到影响的项将从当前的位置删除，并放到项链表的尾部（只影响项在链表中的位置，而散列表的桶不会受影响，映射条目总是在键散列码对应的桶中）</p>
<h4 id="枚举集与映射"><a href="#枚举集与映射" class="headerlink" title="枚举集与映射"></a>枚举集与映射</h4><p>EnumSet是一个枚举类型元素集的高效实现。EnumSet类没有公共的构造器，要使用静态工厂方法构造这个集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY&#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);</span><br><span class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);</span><br><span class="line">EnumSet&lt;Weekday&gt; workday =  EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);</span><br><span class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY,Weekday.WEDNESDAY,Weekday.FRIDAY);</span><br></pre></td></tr></table></figure>

<h4 id="标识散列映射"><a href="#标识散列映射" class="headerlink" title="标识散列映射"></a>标识散列映射</h4><p>该映射的键的散列值不是用hashCode方法计算的，而是用System.identityHashCode方法计算的，这是Object.hashCode根据对象的内存地址计算散列码时使用的方法。且在比较对象时，使用的是“==”，而不是equals，这说明即使两个对象的内容相同，也被视为不同的对象，通常被用于实现对象遍历算法，跟踪哪些对象已经被遍历过。</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
  <entry>
    <title>FileInputStream、FileOutputStream常用方法，文件复制，FileReader、FileWriter的使用，普通文本的复制，带有缓冲区的字符流、转换流</title>
    <url>/2021/07/04/%E8%BF%9B%E9%98%B6%E7%AF%87%20Day%20039%EF%BC%88FileInputStream%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%81FileOutputStream%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E3%80%81FileReader%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81FileWriter%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%99%AE%E9%80%9A%E6%96%87%E6%9C%AC%E7%9A%84%E5%A4%8D%E5%88%B6%E3%80%81%E5%B8%A6%E6%9C%89%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81%EF%BC%89/</url>
    <content><![CDATA[<h2 id="FileInputStream中常用方法"><a href="#FileInputStream中常用方法" class="headerlink" title="FileInputStream中常用方法"></a>FileInputStream中常用方法</h2><span id="more"></span>

<ul>
<li><ul>
<li><ul>
<li><p>```<br>public int available()</p>
<pre><code>          throws IOException
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      返回从此输入流中可以读取（或跳过）的剩余字节数的估计值，而不会被下一次调用此输入流的方法阻塞。当文件位置超出EOF时返回0。下一个调用可能是同一个线程或另一个线程。这个多个字节的单个读取或跳过将不会被阻塞，但可以读取或跳过较少的字节。</span><br><span class="line"></span><br><span class="line">      在某些情况下，非阻塞读取（或跳过）在缓慢时可能会被阻止，例如在慢速网络中读取大文件时。 </span><br><span class="line"></span><br><span class="line">      - 重写： </span><br><span class="line"></span><br><span class="line">        `available`在 `InputStream` </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        可以从该输入流中读取（或跳过）而不阻塞的剩余字节数的估计。 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `IOException` - 如果此文件输入流已通过调用  `close`关闭或发生I / O错误。</span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public long skip(long n)</span><br><span class="line">                throws IOException</span><br></pre></td></tr></table></figure>

<p>跳过并从输入流中丢弃<code>n</code>个字节的数据。</p>
<p>由于各种原因， <code>skip</code>方法可能会跳过一些较小数量的字节，可能是<code>0</code> 。  如果<code>n</code>为负，则该方法将尝试向后跳。  如果后台文件不支持其当前位置的向后跳过，则会抛出<code>IOException</code> 。  返回实际跳过的字节数。 如果它向前跳，它返回一个正值。  如果它向后跳，它返回一个负值。 </p>
<p>该方法可能会跳过比后备文件中剩余的字节更多的字节。  这不会产生异常，并且跳过的字节数可能包括超出后台文件的EOF的一些字节数。  尝试在跳过结束后从流中读取将导致-1表示文件的结尾。 </p>
<ul>
<li><p>重写： </p>
<p><code>skip</code>在  <code>InputStream</code> </p>
</li>
<li><p>参数 </p>
<p><code>n</code> - 要跳过的字节数。 </p>
</li>
<li><p>结果 </p>
<p>实际跳过的字节数。 </p>
</li>
<li><p>异常 </p>
<p><code>IOException</code> -  如果n为负，如果流不支持查询，或者发生I / O错误。 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream f1=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f1=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\temp.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> readDate= f1.read();</span><br><span class="line">            System.out.println(readDate);</span><br><span class="line">            System.out.println(f1.available());<span class="comment">//此方法返回文件中还未读取的字节数量</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (f1 != <span class="keyword">null</span> )&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f1.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream f1=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f1=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\temp.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[f1.available()];</span><br><span class="line">            <span class="keyword">int</span> readCount=f1.read(bytes);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (f1 != <span class="keyword">null</span> )&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f1.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abcdef</span><br></pre></td></tr></table></figure>

<p>注意：以上方式不太适用于大文件，因为byte[]数组不能太大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream f1=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f1=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\temp.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> readDate1=f1.read();</span><br><span class="line">            System.out.println(readDate1);</span><br><span class="line">            f1.skip(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">int</span> readDate2=f1.read();</span><br><span class="line">            System.out.println(readDate2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (f1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f1.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">101</span></span><br></pre></td></tr></table></figure>

<h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><ul>
<li><ul>
<li><ul>
<li><p>```<br>public void write(byte[] b)</p>
<pre><code>       throws IOException
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      将 `b.length`字节从指定的字节数组写入此文件输出流。 </span><br><span class="line"></span><br><span class="line">      - 重写： </span><br><span class="line"></span><br><span class="line">        `write`在 `OutputStream` </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `b` - 数据。 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `IOException` - 如果发生I / O错误。 </span><br><span class="line"></span><br><span class="line">      - 另请参见： </span><br><span class="line"></span><br><span class="line">        [`OutputStream.write(byte[\],  int, int)`](../../java/io/OutputStream.html#write-byte:A-int-int-) </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public void write(byte[] b,</span><br><span class="line">                        int off,</span><br><span class="line">                        int len)</span><br><span class="line">                 throws IOException</span><br></pre></td></tr></table></figure>

<p>从位于偏移量 <code>off</code>的指定字节数组写入 <code>len</code>字节到该文件输出流。 </p>
<ul>
<li><p>重写： </p>
<p><code>write</code>在  <code>OutputStream</code> </p>
</li>
<li><p>参数 </p>
<p><code>b</code> - 数据。 </p>
<p><code>off</code> - 数据中的起始偏移量。 </p>
<p><code>len</code> - 要写入的字节数。 </p>
</li>
<li><p>异常 </p>
<p><code>IOException</code> - 如果发生I / O错误。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileOutputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fileTest01&quot;</span>);<span class="comment">//文件不存在会新建</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes=&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>&#125;;</span><br><span class="line">            fis.write(bytes);<span class="comment">//abcdef</span></span><br><span class="line">            fis.write(bytes,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//abcdefab</span></span><br><span class="line">            <span class="comment">//不管运行几次结果都是一样的，因为在再一次执行程序时，会把文件内容清空，重新写入</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*** 注意：清空文件意味着原本的文件数据丢失，谨慎使用***</p>
<ul>
<li><ul>
<li><ul>
<li>```<br>public FileOutputStream(String name,<pre><code>                    boolean append)
             throws FileNotFoundException
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      创建文件输出流以指定的名称写入文件。如果第二个参数是`true`  ，则字节将写入文件的末尾而不是开头。创建一个新的`FileDescriptor`对象来表示此文件连接。</span><br><span class="line"></span><br><span class="line">      首先，如果有一个安全管理员，它的`checkWrite`方法是以`name`作为参数来调用的。 </span><br><span class="line"></span><br><span class="line">      如果文件存在但是是一个目录而不是常规文件，不存在但不能创建，或者由于任何其他原因无法打开，那么抛出一个`FileNotFoundException`  。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `name` - 与系统相关的文件名 </span><br><span class="line"></span><br><span class="line">        `append` - 如果是 `true` ，那么字节将被写入文件的末尾，而不是开头 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `FileNotFoundException`  - 如果文件存在但是是一个目录而不是常规文件，不存在但不能创建，或由于任何其他原因无法打开。 </span><br><span class="line"></span><br><span class="line">        `SecurityException` -  如果安全管理器存在，并且其 `checkWrite`方法拒绝对该文件的写入访问。 </span><br><span class="line"></span><br><span class="line">      - 从以下版本开始： </span><br><span class="line"></span><br><span class="line">        JDK1.1 </span><br><span class="line"></span><br><span class="line">      - 另请参见： </span><br><span class="line"></span><br><span class="line">        [`SecurityManager.checkWrite(java.lang.String)`](../../java/lang/SecurityManager.html#checkWrite-java.lang.String-) </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Test02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileOutputStream fis=null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fis=new FileOutputStream(&quot;IO_Test\\fileTest03.txt&quot;,true);</span><br><span class="line">            byte[] bytes=&#123;97,98,99,100&#125;;</span><br><span class="line">            fis.write(bytes);</span><br><span class="line">            fis.flush();//最后一定要刷新</span><br><span class="line">            </span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (fis != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h2><p>使用FileInputStream +  FileOutputStream 完成文件的拷贝，过程应该是一边读一边写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个输入流对象</span></span><br><span class="line">            fis =<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\hobby\\学习资料\\IPX-534.mp4&quot;</span>);</span><br><span class="line">            <span class="comment">//创建一个输出流对象</span></span><br><span class="line">            fos =<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\Study\\IPX-534.mp4&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1MB（一次最多拷贝1MB）</span></span><br><span class="line">            <span class="keyword">int</span> readCount=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(bytes,<span class="number">0</span>,readCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//刷新</span></span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//异常要分开捕捉</span></span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：要拷贝的项目在目标位置需要指定文件名。</p>
<p>*<strong>FileInputStream和FileOutputStream是万能的，不管图片，视频，文档都可以使用</strong></p>
<h2 id="FileReader的使用"><a href="#FileReader的使用" class="headerlink" title="FileReader的使用"></a>FileReader的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.FileReader</span><br></pre></td></tr></table></figure>



<p>1、是一个文件字符输入流，只能读取普通文本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileReader fr=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\temp.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">char</span>[] chars=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((readCount =fr.read(chars))!= -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> String(chars,<span class="number">0</span>,readCount));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abcdef</span><br></pre></td></tr></table></figure>

<h2 id="FileWriter的使用"><a href="#FileWriter的使用" class="headerlink" title="FileWriter的使用"></a>FileWriter的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.FileWriter</span><br></pre></td></tr></table></figure>



<p>1、文件字符输出流，写</p>
<ul>
<li><ul>
<li><ul>
<li><p>```<br>public void write(char[] cbuf)</p>
<pre><code>       throws IOException
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      写入一个字符数组。 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `cbuf` - 要写入的字符数组 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `IOException` - 如果发生I / O错误 </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public abstract void write(char[] cbuf,int off,  int len)</span><br><span class="line">                          throws IOException</span><br></pre></td></tr></table></figure>

<p>写入字符数组的一部分。 </p>
<ul>
<li><p>参数 </p>
<p><code>cbuf</code> - <code>cbuf</code>数组 </p>
<p><code>off</code> - 从中开始编写字符的偏移量 </p>
<p><code>len</code> - 要写入的 <code>len</code>数 </p>
</li>
<li><p>异常 </p>
<p><code>IOException</code> - 如果发生I / O错误 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>```<br>public void write(String str)</p>
<pre><code>       throws IOException
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      写一个字符串 </span><br><span class="line"></span><br><span class="line">      - 参数 </span><br><span class="line"></span><br><span class="line">        `str` - 要写入的字符串 </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `IOException` - 如果发生I / O错误 </span><br><span class="line"></span><br><span class="line">- - - ```</span><br><span class="line">      public void write(String str,</span><br><span class="line">                        int off,</span><br><span class="line">                        int len)</span><br><span class="line">                 throws IOException</span><br></pre></td></tr></table></figure>

<p>写一个字符串的一部分。 </p>
<ul>
<li><p>参数 </p>
<p><code>str</code> - 字符串 </p>
<p><code>off</code> - 开始编写字符的偏移量 </p>
<p><code>len</code> - 要写入的 <code>len</code>数 </p>
</li>
<li><p>异常 </p>
<p><code>IndexOutOfBoundsException</code>  - 如果 <code>off</code>为负数，或 <code>len</code>为负数，或 <code>off+len</code>为负数或大于给定字符串的长度 </p>
<p><code>IOException</code> - 如果发生I / O错误 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>*** 注意：word文档不是普通文本 ***</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileWriter fw=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fw=<span class="keyword">new</span> FileWriter(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\temp1.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">char</span>[] chars=&#123;<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;给&#x27;</span>,<span class="string">&#x27;爷&#x27;</span>,<span class="string">&#x27;死&#x27;</span>&#125;;</span><br><span class="line">            fw.write(chars);</span><br><span class="line">            fw.write(chars,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;系内&quot;</span>);</span><br><span class="line">            fw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="普通文本的复制"><a href="#普通文本的复制" class="headerlink" title="普通文本的复制"></a>普通文本的复制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileReader fr=<span class="keyword">null</span>;</span><br><span class="line">        FileWriter fw=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\temp1.txt&quot;</span>);</span><br><span class="line">            fw=<span class="keyword">new</span> FileWriter(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\temp2.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">char</span>[] chars= <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span> * <span class="number">521</span>];</span><br><span class="line">            <span class="keyword">int</span> readCount =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount = fr.read(chars))!= -<span class="number">1</span>)</span><br><span class="line">                fw.write(chars,<span class="number">0</span>,readCount);</span><br><span class="line"></span><br><span class="line">            fw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="带有缓冲区的字符流、转换流"><a href="#带有缓冲区的字符流、转换流" class="headerlink" title="带有缓冲区的字符流、转换流"></a>带有缓冲区的字符流、转换流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.BufferedReader</span><br><span class="line">java.io.BufferedWriter</span><br><span class="line">java.io.BufferedInputStream</span><br><span class="line">java.io.BufferedOutputStream</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.InputStreamReader</span><br><span class="line">java.io.OutputStreamWriter</span><br></pre></td></tr></table></figure>



<h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p>注意：以下代码将异常抛出</p>
<ul>
<li><ul>
<li><ul>
<li>```<br>public String readLine()<pre><code>            throws IOException
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      读一行文字。 一行被视为由换行符（&#x27;\ n&#x27;），回车符（&#x27;\  r&#x27;）中的任何一个或随后的换行符终止。 </span><br><span class="line"></span><br><span class="line">      - 结果 </span><br><span class="line"></span><br><span class="line">        包含行的内容的字符串，不包括任何行终止字符，如果已达到流的末尾，则为null </span><br><span class="line"></span><br><span class="line">      - 异常 </span><br><span class="line"></span><br><span class="line">        `IOException` - 如果发生I / O错误 </span><br><span class="line"></span><br><span class="line">      - 另请参见： </span><br><span class="line"></span><br><span class="line">        [`Files.readAllLines(java.nio.file.Path,  java.nio.charset.Charset)`](../../java/nio/file/Files.html#readAllLines-java.nio.file.Path-java.nio.charset.Charset-) </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Test01 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileReader reader =new FileReader(&quot;E:\\study\\Test03\\IO_Test\\a.txt&quot;);</span><br><span class="line">        //当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做“节点流”</span><br><span class="line">        //外部包装的这个流，叫做：包装流/处理流。关闭的话：只需要关闭外层的流</span><br><span class="line">        BufferedReader br=new BufferedReader(reader);</span><br><span class="line"></span><br><span class="line">        String s=null;</span><br><span class="line">        while((s= br.readLine()) != null)&#123;</span><br><span class="line">            System.out.println(s);//readLine方法是不会读出换行符的，此处可以换行是因为println</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //字节流</span></span><br><span class="line"><span class="comment">        FileInputStream fi=new FileInputStream(&quot;E:\\study\\Test03\\IO_Test\\a.txt&quot;);</span></span><br><span class="line"><span class="comment">        //通过转换流转化,(将字节流转换为字符流）</span></span><br><span class="line"><span class="comment">        InputStreamReader reader =new InputStreamReader(fi);//reader是包装流， fi是节点流</span></span><br><span class="line"><span class="comment">        //br是包装流，reader是节点流</span></span><br><span class="line"><span class="comment">        BufferedReader br=new BufferedReader(reader);//这个构造方法只能传一个字符流，不能穿字节流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//合并写法</span></span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\a.txt&quot;</span>)));</span><br><span class="line">        String line =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line=br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedWriter bw=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\b.txt&quot;</span>));</span><br><span class="line">        BufferedWriter bw1=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\c.txt&quot;</span>)));</span><br><span class="line">        bw.write(<span class="string">&quot;Hello,world&quot;</span>);</span><br><span class="line">        bw.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        bw.write(<span class="string">&quot;Hello,kitty&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw1.write(<span class="string">&quot;Hello,world&quot;</span>);</span><br><span class="line">        bw1.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        bw1.write(<span class="string">&quot;Hello,kitty&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line"></span><br><span class="line">        bw1.flush();</span><br><span class="line">        bw1.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.DataInputStream</span><br><span class="line">java.io.DataOutputStream</span><br></pre></td></tr></table></figure>

<p>1、<code>java.io.DataOutputStream</code>：数据专属的流</p>
<p>这个流可以将数据连同数据类型一并写入文件</p>
<p>注意：这个文件不是普通文本文档。（记事本打不开）</p>
<p>2、<code>java.io.DataInputStream</code>：数据字节输入流，<strong>用<code>DataOutputStream</code>写的文件，只能使用<code>DataInputStream</code>去读，并且读的时候需要知道写入的顺序，读和写的顺序一致，才能取出数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        DataOutputStream dos=<span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:\\study\\\\Test03\\IO_Test\\outputstream&quot;</span>));</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">float</span> f=<span class="number">3.14f</span>;</span><br><span class="line">        <span class="keyword">double</span> d=<span class="number">3.00</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">long</span> l=<span class="number">400l</span>;</span><br><span class="line">        <span class="keyword">byte</span> bytes=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">short</span> s=<span class="number">200</span>;</span><br><span class="line">        <span class="comment">//把数据以及数据的类型一并写入到文件当中</span></span><br><span class="line">        dos.writeInt(i);</span><br><span class="line">        dos.writeFloat(f);</span><br><span class="line">        dos.writeDouble(d);</span><br><span class="line">        dos.writeBoolean(b);</span><br><span class="line">        dos.writeChar(c);</span><br><span class="line">        dos.writeLong(l);</span><br><span class="line">        dos.writeByte(bytes);</span><br><span class="line">        dos.writeShort(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DataInputStream dis=<span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\study\\Test03\\IO_Test\\outputstream&quot;</span>));</span><br><span class="line">        <span class="keyword">int</span> i=dis.readInt();</span><br><span class="line">        <span class="keyword">float</span> f=dis.readFloat();</span><br><span class="line">        <span class="keyword">double</span> d=dis.readDouble();</span><br><span class="line">        <span class="keyword">boolean</span> b=dis.readBoolean();</span><br><span class="line">        <span class="keyword">char</span> c=dis.readChar();</span><br><span class="line">        <span class="keyword">long</span> l=dis.readLong();</span><br><span class="line">        <span class="keyword">byte</span> bytes=dis.readByte();</span><br><span class="line">        <span class="keyword">short</span> s=dis.readShort();</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(l);</span><br><span class="line">        System.out.println(bytes);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        dis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
  </entry>
</search>
